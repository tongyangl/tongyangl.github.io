<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android四大组件-Broadcas]]></title>
    <url>%2F2017%2F07%2F20%2FAndroid%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Broadcas%2F</url>
    <content type="text"><![CDATA[广播作为四大组件之一，平时我们也不少用到，广播广播，顾名思自然有发送者和接受者，广播作为Android组件之间的通讯方式，有如下五中使用场景 同一app内部的同一组件内的消息通信（单个或多个线程之间）； 同一app内部的不同组件之间的消息通信（单个进程）； 同一app具有多个进程的不同组件之间的消息通信； 不同app之间的组件之间消息通信； Android系统在特定情况下与App之间的消息通信。 ​ BroadcastReceiver我们自定义的BroadcastReceiver需要继承BroadcastReceiver这个抽象基类，并且实现抽象方法onReceive(context, intent)。这个方法也是运行在UI线程的，所以也不要在这个方法中作过多了耗时操作。。不然就ANR了。。 例子 12345678class MyBroadcastReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent) &#123; Log.d(&quot;MyBroadcastReceiver:&quot;,intent.getStringExtra(&quot;name&quot;)); &#125;&#125; 广播的注册类型分为两种，一种是静态注册一种是动态注册 动态注册动态注册时，无须在AndroidManifest中注册组件。直接在代码中通过调用Context的registerReceiver函数，可以在程序中动态注册BroadcastReceiver。registerReceiver的定义形式如下： 12345678910111213141516171819202122232425262728293031323334public class MainActivity extends Activity &#123; private MyBroadcastReceiver receiver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); IntentFilter intentFilter=new IntentFilter(); intentFilter.addAction(&quot;MyBroadcastReceiver&quot;); receiver=new MyBroadcastReceiver(); registerReceiver(receiver,intentFilter); Intent intent=new Intent(); intent.setAction(&quot;MyBroadcastReceiver&quot;); intent.putExtra(&quot;name&quot;,&quot;name&quot;); sendBroadcast(intent); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(receiver); &#125; class MyBroadcastReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent) &#123; Log.d(&quot;MyBroadcastReceiver:&quot;,intent.getStringExtra(&quot;name&quot;)); &#125; &#125;&#125; 当此Activity实例化时，会动态将MyBroadcastReceiver注册到系统中。当此Activity销毁时，动态注册的MyBroadcastReceiver将不再接收到相应的广播。 切记一定要进行解绑定unregisterReceiver(mBroadcastReceiver)。 静态注册直接在配置文件AndroidManifest.xml进行注册。 123456789&lt;receiver android:enabled=[&quot;true&quot; | &quot;false&quot;]android:exported=[&quot;true&quot; | &quot;false&quot;]android:icon=&quot;drawable resource&quot;android:label=&quot;string resource&quot;android:name=&quot;string&quot;android:permission=&quot;string&quot;android:process=&quot;string&quot; &gt;. . .&lt;/receiver&gt; 其中，需要注意的属性android:exported ——此broadcastReceiver能否接收其他App的发出的广播，这个属性默认值有点意思，其默认值是由receiver中有无intent-filter决定的，如果有intent-filter，默认值为true，否则为false。（同样的，activity/service中的此属性默认值一样遵循此规则）同时，需要注意的是，这个值的设定是以application或者application user id为界的，而非进程为界（一个应用中可能含有多个进程）；android:name —— 此broadcastReceiver类名；android:permission ——如果设置，具有相应权限的广播发送方发送的广播才能被此broadcastReceiver所接收；android:process ——broadcastReceiver运行所处的进程。默认为app的进程。可以指定独立的进程（Android四大基本组件都可以通过此属性指定自己的独立进程） 广播的类型 Normal Broadcast：普通广播 此处将普通广播界定为：开发者自己定义的intent，以context.sendBroadcast_”AsUser”(intent, …)形式。具体可以使用的方法有：sendBroadcast(intent)/sendBroadcast(intent, receiverPermission)/sendBroadcastAsUser(intent, userHandler)/sendBroadcastAsUser(intent, userHandler,receiverPermission)。普通广播会被注册了的相应的感兴趣（intent-filter匹配）接收，且顺序是无序的。如果发送广播时有相应的权限要求，BroadCastReceiver如果想要接收此广播，也需要有相应的权限。 System Broadcast: 系统广播 Android系统中内置了多个系统广播，只要涉及到手机的基本操作，基本上都会发出相应的系统广播。如：开启启动，网络状态改变，拍照，屏幕关闭与开启，点亮不足等等。每个系统广播都具有特定的intent-filter，其中主要包括具体的action，系统广播发出后，将被相应的BroadcastReceiver接收。系统广播在系统内部当特定事件发生时，有系统自动发出。 Ordered broadcast：有序广播 有序广播的有序广播中的“有序”是针对广播接收者而言的，指的是发送出去的广播被BroadcastReceiver按照先后循序接收。有序广播的定义过程与普通广播无异，只是其的主要发送方式变为：sendOrderedBroadcast(intent, receiverPermission, …)。 对于有序广播，其主要特点总结如下： 1&gt;多个具当前已经注册且有效的BroadcastReceiver接收有序广播时，是按照先后顺序接收的，先后顺序判定标准遵循为：将当前系统中所有有效的动态注册和静态注册的BroadcastReceiver按照priority属性值从大到小排序，对于具有相同的priority的动态广播和静态广播，动态广播会排在前面。 2&gt;先接收的BroadcastReceiver可以对此有序广播进行截断，使后面的BroadcastReceiver不再接收到此广播，也可以对广播进行修改，使后面的BroadcastReceiver接收到广播后解析得到错误的参数值。当然，一般情况下，不建议对有序广播进行此类操作，尤其是针对系统中的有序广播。 Sticky Broadcast：粘性广播(在 android 5.0/api 21中deprecated,不再推荐使用，相应的还有粘性有序广播，同样已经deprecated)。 既然已经deprecated，此处不再多做总结。 Local Broadcast：App应用内广播（此处的App应用以App应用进程为界 由前文阐述可知，Android中的广播可以跨进程甚至跨App直接通信，且注册是exported对于有intent-filter的情况下默认值是true，由此将可能出现安全隐患如下： 1.其他App可能会针对性的发出与当前App intent-filter相匹配的广播，由此导致当前App不断接收到广播并处理； 2.其他App可以注册与当前App一致的intent-filter用于接收广播，获取广播具体信息。 无论哪种情形，这些安全隐患都确实是存在的。由此，最常见的增加安全性的方案是： 1.对于同一App内部发送和接收广播，将exported属性人为设置成false，使得非本App内部发出的此广播不被接收； 2.在广播发送和接收时，都增加上相应的permission，用于权限验证； 3.发送广播时，指定特定广播接收器所在的包名，具体是通过intent.setPackage(packageName)指定在，这样此广播将只会发送到此包中的App内与之相匹配的有效广播接收器中。 App应用内广播可以理解成一种局部广播的形式，广播的发送者和接收者都同属于一个App。实际的业务需求中，App应用内广播确实可能需要用到。同时，之所以使用应用内广播时，而不是使用全局广播的形式，更多的考虑到的是Android广播机制中的安全性问题。 相比于全局广播，App应用内广播优势体现在： 1.安全性更高； 2.更加高效。 ​ 1).对于静态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是ReceiverRestrictedContext； 2).对于全局广播的动态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是Activity Context； 3).对于通过LocalBroadcastManager动态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是Application Context。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android四大组件-Activity]]></title>
    <url>%2F2017%2F07%2F20%2FAndroid%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Activity%2F</url>
    <content type="text"><![CDATA[Activity作为Android四大组件之一想必重要性不用多说。 Activity可以理解为Android程序我们看到的界面都是承载在Activity上。 Activity的生命周期 正常Activity的启动经历以下过程 onCreat Activity的创建，做一切初始化的操作，这个时候Activity还不可见。 onStart Activity已经展现在前台页面，但是还是不可以交互。 onResume Activity可见，并且可以交互。可以做一些onPause或者onStop释放资源的的回收操作 Activity进入运行状态 onPause Activity进入后台之前可见的时候做一些回收工作，只有当前Activity的onpause方法执行完事之后下个Activity的onResume方法才会执行 onStop Activity不可见。回收操作，不能太过于耗时。 onDestory Activity销毁，可以做一些大量的回收操作 ​ 如果ACtivity在进入onStop方法后未被销毁，而又被展现到前台页面则会调用onRestart()方法 onCreate的方法 123protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState);&#125; 其中savedInstanceState是一个Bundle类型的参数，会在onPause()或onStop()之前执行，在她和map差不多，都是键值对形式，我们可以在Activity快被销毁的时候储存一些东西 调用方法 1234@Overrideprotected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState);&#125; 在这里进行存储。 onRestoreInstanceState 这个方法会在Activity真正被销毁的时候才会执行。比如按下bcak键。 Activity的四种LaunchMode standard 模式 这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。使用场景：大多数Activity。 singleTop 模式 如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。使用场景如新闻类或者阅读类App的内容页面。 singleTask 模式 如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。使用场景如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。 singleInstance 模式 在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。使用场景如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -&gt; B (singleInstance) -&gt; C，完全退出后，在此启动，首先打开的是B。 如何判断一个Activity加载完毕。使用onResume方法？ 错。。这个不知道为啥就是错误的， 因为之前做过一个播放器，里面的mediaController是一个自定义的Popuwindow，需要加载玩Activity就显示，但是我放在onResume里面总是报错，显示窗口泄露，找不到Activity于是高了半天才发现这个方法。这个方法表示Activity加载完毕，可以做一些加载完毕就做得事情，如popuwindow的展示，测量加载完毕的View长度，如果在其他方法里面测量的话会导致长度错误或者为0 12345@Overridepublic void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); &#125; 这个方法是屏幕的旋转。当屏幕旋转的时候可以在这个方法进行操作。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA FIle的排序]]></title>
    <url>%2F2017%2F07%2F19%2FJAVA-FIle%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF%2F</url>
    <content type="text"><![CDATA[之前搞了一个Android 的播放器，里面涉及到了好多关于java file文件的东西。 其中就有一个关于file的排序问题。 自己天真的以为用TreeSet就可以了。。但是发现是可以了，但是他是分大小写的，我们平常都是不分大小写的，所以自己鼓捣了一会发现 12Collections.sort();这个方法 123456789101112131415private List&lt;File&gt; sortFileList(List&lt;File&gt; list) &#123; Collections.sort(list, new Comparator&lt;File&gt;() &#123; @Override public int compare(File o1, File o2) &#123; if (o1.isDirectory() &amp;&amp; o2.isFile()) return -1; if (o1.isFile() &amp;&amp; o2.isDirectory()) return 1; return o1.getName().compareToIgnoreCase(o2.getName()); &#125; &#125;); return list; &#125; 实现 Comparator接口。就可以实现排序了 同样对于filelist这个方法也有一个FileFilter的接口传入，比如一些隐藏文件我们可以直接让他不显示 1234567891011121314file.listFiles(new FileFilter() &#123; @Override public boolean accept(File pathname) &#123; if(pathname.getName().startsWith(&quot;.&quot;))&#123; return false; &#125;else&#123; return true; &#125; &#125;&#125;); 这样就可以了。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试]]></title>
    <url>%2F2017%2F07%2F15%2F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能优化]]></title>
    <url>%2F2017%2F05%2F11%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[布局优化尽量少用嵌套，能用linearLayout和frameLayout解决最好不要用RelativeLayout。 因为view的绘制会花更多的时间。 使用 和ViewStub 不用多说，大家应该很熟悉，可以指定一个布局文件到当前布局中，比如toolbar的设置，很多的app 中activity的toolbar都是相同的，没必要每个都写，这个标签是可以有id 的，并且可以设置宽高。其他的不行 它一般和标签一起使用用来减少布局的层数 ViewStub 他继承于view，并且非常轻量级，宽高都是0，所以它本身不参与绘制过程。它的意义在于在需要的时候加载所需的布局文件。比如一些隐藏的布局，在需要的时候显示！ 12345678&lt;ViewStub android:inflateId=&quot;@id/inflateid&quot; android:id=&quot;@+id/viewstub_demo_image&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;5dip&quot; android:layout_marginRight=&quot;5dip&quot; android:layout=&quot;@layout/viewstub_demo_image_layout&quot;/&gt; inflateid是加载布局的根元素的id，viewstub_demo_image是viewStub的id， 1((viewstub)findviewbyId(R.id.viewstub_demo_image)).setVisibility(View.Visible); 1View myview=((ViewStub)findViewById(R.id.viewstub_demo_image)).infalte(); 这时候布局会被替换掉，但是目前Viewstub不支持标签 ​ 绘制优化 尽量不要在onDraw方法中进行大量的运算，循环，创建性的布局对象（会频繁调用onDraw方法） 内存泄漏优化不要让静态变量持有禁用activity，会导致activity无法被销毁。或者progressDialog 123private static ProgressDialog dialog; dialog=new ProgressDialog(this); 这个this也对activity有引用，所以无法被销毁。 单利对象— 因为单例模式的对象适合applicantion的生命周期是一样的，所以当有时候我们不去解除绑定的话，activity会一直持有这个单例对象，会导致无法被销毁 属性动画在activity被销毁时要调用 animator.cancle()方法 不要在主线程中去做过多复杂的操作，这些都尽量去异步的放在子线程中去执行。 不然很容易anr，如果产生anr 系统会在/data/anr 目录下创建一个traces.txt文件。通过分析这个文件我们就能分析出ANR产生的原因。 Listview不要在getView方法中进行耗时操作。或者开启大量的异步任务。可以尝试开启硬件加速。和使用viewHolder减少findviewById方法。或者监听话筒状态比如，滑动的时候不要加载图片。分页加载等 线程的优化尽量使用线程池，避免程序中存在大量的THread。线程池可以重用内部的线程，避免了创建和销毁的开销。而且还可以控制线程的最大并发数。避免线程强占系统资源导致阻塞。 杂七杂八不要创建过多的对象，不重要的对象可以使用 软引用和弱引用 不要使用枚举 常量使用 static final修饰 使用Android 特有的数据结构。 SparesArray 和Pair等 缓存采用三级缓存，内存，磁盘，网络 使用静态内部类，不然由于内部类对外存在持有，导致外部类不会被销毁]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片缓存与bitmap的加载]]></title>
    <url>%2F2017%2F05%2F07%2F%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98%E4%B8%8Ebitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"></content>
      <tags>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[drawable]]></title>
    <url>%2F2017%2F05%2F04%2Fdrawable%2F</url>
    <content type="text"><![CDATA[drawable他是一个图像的概念，不完全是指图片，一般是通过xml文件定义，她是一个抽象类，有着非常多的子类，子类都是直接继承它。 bitmapdrawable 代表一张图片. xml 属性有几个比较常用 src —代表资源id antialias —抗锯齿（开） dither—抖动效果（开）开启会更好的适配 filter —在拉伸等情况下可以更好的显示（开启） gravity—当图片小于容器的时候选择的属性 有很多 mipMap— 一种文理映射，不常用 titleMode—平铺模式 ​ ShapeDrawable 非常常见的drawable shape :有四个属性 rectangle：矩形 oval：椭圆 line ：横线 ring ：圆环 corners :表示shape四个角的角度。只适用于矩形 radius：四个角的角度，优先度低，会被其它属性覆盖 topLeftRadius：左上角 topRightRadius:右上角 bottomLeftRadius：左下角 bottomRightRadius：右下角 ​ gradient 和solid 互斥，表示渐变，而solid表示纯色填充 angle :渐变的角度，默认为0,值必须是45的倍数，0表示从左到右，90表示从上到下 centerX：渐变的中心横坐标 centerY：渐变中心的纵坐标 startColor：渐变变的起始颜色 centerColor：渐变的中间色 endColor：渐变的结束颜色 gradientRadius：渐变半径 useLevel：一半为false，当drawable作为statelistDrawable的时候为true type：渐变类别，linear（线性）radoal（径向渐变）sweep（扫描渐变） ​ solid:填充的颜色，全色填充 stroke:shape的描边 width:描边的宽度 color：描边的颜色 dashWidth：虚线的线段宽度 dashGap：虚线的线段之间的间隔 ​ padding 表示空白，表示包含它的view的空白 size shape的大小 ​ LayerDrawable 层次化的drawable集合，标签为 ,通过item实现叠加效果 StateListDrawable 标签，表示Drawable集合，每个drawable对应着view的一种状态 比如button的点击等等 view的常见状态 state_pressed，表示按下的状态，比如button被按下，但是没有松开 state_focused ,表示view获取了焦点 state_selected,表示选择了view state_checked,表示用户选中的view 一般在checkbox state_enabled,表示view处于可用状态 ​ TransitionDrawable 用于实现两个Drawable之间的淡入淡出效果 insetDrawable 可以将其他Drawable内嵌到自己当中并且可以在四周留出间距 当自己的drawable需要和实际的view有大小区别的时候 scale 根据自己等级 level将指定的Drawable缩放到一定的比例 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;scale android:interpolator= &quot;@android:anim/decelerate_interpolator&quot; android:fromXScale=&quot;0.0&quot; android:toXScale=&quot;1.5&quot; android:fromYScale=&quot;0.0&quot; android:toYScale=&quot;1.5&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:startOffset=&quot;0&quot; android:duration=&quot;10000&quot; android:repeatCount=&quot;1&quot; android:repeatMode=&quot;reverse&quot; /&gt; &lt;/set&gt; &lt;!-- fromXDelta,fromYDelta 起始时X，Y座标,屏幕右下角的座标是X:320,Y:480 toXDelta， toYDelta 动画结束时X,Y的座标 --&gt; &lt;!-- interpolator 指定动画插入器 常见的有加速减速插入器 accelerate_decelerate_interpolator 加速插入器 accelerate_interpolator， 减速插入器 decelerate_interpolator。 fromXScale,fromYScale， 动画开始前X,Y的缩放，0.0为不显示， 1.0为正常大小 toXScale，toYScale， 动画最终缩放的倍数， 1.0为正常大小，大于1.0放大 pivotX， pivotY 动画起始位置，相对于屏幕的百分比,两个都为50%表示动画从屏幕中间开始 startOffset， 动画多次执行的间隔时间，如果只执行一次，执行前会暂停这段时间， 单位毫秒 duration，一次动画效果消耗的时间，单位毫秒， 值越小动画速度越快 repeatCount，动画重复的计数，动画将会执行该值+1次 repeatMode，动画重复的模式，reverse为反向，当第偶次执行时，动画方向会相反。 restart为重新执行，方向不变 --&gt; ​ CliPDrawable 可以通过自己等级来剪裁另一个Drawable clipOrientation表示剪裁的方向 1testClipDrawable.setLevel(3000) level 为0-10000 ，例如3000表示剪裁了30%；]]></content>
      <tags>
        <tag>drawable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[view的工作原理]]></title>
    <url>%2F2017%2F05%2F02%2Fview%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[ViewRoot是对应ViewRootImpl类，他是连接windowmangager和DecorView的纽带。 view的三大绘制流程都是从viewroot开始的，在ActivityThread中，activity对象被创建完成后，会把decorview添加到window中。同时创建vIewrootImpl对象。 view的绘制从viewroot的performTraversals方法开始分别对应 measure，layout，和draw，分别对应 测量宽高 确定view在父容器中的位置 绘制 ​ performTraversals会依次调用perfromMeasure，performLayout,performDraw 方法，这三个方法会完成顶级view的 三个绘制过程，其中的performMeasure会调用measure ，然后再调用onmeasure 然后再onmeasure方法中会继续对子view进行measure过程，这样就遍历了整个view树。 其他两个方法也是类似 DecorView作为顶级的view其实包含一个linearlayout，分为两个部分，一个titlebar和content，所以我们的oncreate方法中是setcontentview而不是setview MeasureSpecmeasureSpec会根据view的layoutparams和父容器施加的规则转换而来 MeasureSpec是一个32位的int值，前两位代表测量模式SpecMode，后面代代表SpecSize测量大小 SpecMode分为三种 UNSPECIFIED 父容器对view的宽高没有任何的限制，要多打给多大，一般出现在系统内部 EXACTLY 精确大小，表示view的大小就是spceSize， 如match_parent，或者精确的一个数值 AT_MOST 父容器给顶了一个大小，view的大小不能超过它，比如wrap_contet ​ 最顶级的view decorview的大小是由他自己的layoutparams和窗口的尺寸决定，而其他的view都是父容器的规则和自身的layoutparams决定。 MeasureSpec一旦确定后 onMeasure就可以确定view的最终宽高 padding代表父容器已经占用的大小，所以实际可用大小为父容器大小减去padding。 1int size=Math.max(0,specSize-padding); view的工作流程———–Measure————layout———–draw measure如果是viewgroup则除了测量自己的大小，还要去遍历调用字view 的measure的方法如果是view则只调用measure view的measure方法是一个final方法，不能被重写而在measrue方法中会调用onMseasure方法。 viewgroup的measure过程viewgroup是抽象类没有实现onMeasure，但是有一个measureChildren方法。 之所以它没有实现测量方法，是因为他需要子类去实现这个方法如linearlayout等，因为每个的布局特性导致他们的测量方法不同。 记住 view的onMeasure过程不是和acitvity同步的，所以在oncreate和onstart或者onresume中无法获取到真正的宽高 所以要使用如下方法调用是比较正确的 通过onWindowFocusChanged方法 12345678public void onWindowFocusChanged(boolean hasFocus)&#123; surper.onWindowFocusChanged(hasFocus); if(hasFocus)&#123; int height=view.getmeasureheight（）； int width=view.getmeasureWidth（）； &#125; &#125; 通过view.post方法 post一个runable投入到消息队列，然后等待Looper调用runable的时候view已经初始化好了 123456789view.post(new runable()&#123; @Override public void run()&#123; // 获取宽高 int height=view.getmeasureheight（）； int width=view.getmeasureWidth（）； &#125;); ​ 通过ViewTreeObserver的回调方法 通过view.measure(int WidthMeasureSpec,int HeightMeasureSpec) match_parent 直接放弃，无法获取 具体的数值 ​ warp_content layoutViewGroup调用layout方法确定自己的位置，当自己的位置确定后他会调用onlayout方法遍历子元素的laout方法，然后子元素在去调用layout方法 layout方法确定本身的位置，onlayout确定子元素的位置 layout方法会通过 setfrme 确定view的四个顶点位置mLeft，mRight,mTop,mbottom.四个点确定了位置也就确定了然后调用onlayout方法 ，它和onmeasure方法一样，viewgroup没有具体的实现， drawdraw的过程遵循四步骤 绘制背景 绘制自己（onDraw） 绘制children（dispatchDraw） 绘制装饰（onDrawScrollBars） View的特殊方法 ——–setWillNotDraw 表示一个view如果不需要绘制则可以设置为ture，这样系统会进行优化。viewgroup会默认的开启这个方法，如果我们的自定义view需要onDraw方法来绘制东西，则我们需要关闭这个方法]]></content>
      <tags>
        <tag>view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[希尔排序]]></title>
    <url>%2F2017%2F04%2F28%2F%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324static void xier()&#123; int i,j,h,v; for (h=1;h==test.length/9;h=h*3+1); for (;h&gt;0;h=h/3)&#123; for (i=h+1;i==test.length;i+=1)&#123; v=test[i]; j=i; while (j&gt;h&amp;&amp;test[j-h]&gt;v) &#123; test[j]=test[j-h]; j-=h; &#125; test[j]=v; &#125; &#125;&#125; 通过设置一个间距在可以在较远的距离进行位置交换，并且不断缩小这个间距知道距离变为1，这个时候的数组已经变得基本有序，最后的一次排序也就成为了插入排序，但是因为数组有序度高所以耗时短、]]></content>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序（冒泡排序，插入排序）]]></title>
    <url>%2F2017%2F04%2F28%2F%E6%8E%92%E5%BA%8F%EF%BC%88%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最常见也是最简单的冒泡排序时间复杂度0（n^2）; 1234567891011for (int i = 0; i &lt; test.length-1; i++) &#123; for (int j = i+1; j &lt; test.length; j++) &#123; if (test[j] &lt; test[i]) &#123; int temp = test[j]; test[j] = test[i]; test[i] = temp; &#125; &#125;&#125; 插入排序； 数据量较小时速度很快。 进行局部排序，一部分一部分来。 123456789101112131415private static void charu() &#123; int v ,j; for (int i=1;i&lt;test.length;i++)&#123; v=test[i]; j=i; while (test[j-1]&gt;v&amp;&amp;j&gt;=1)&#123; test[j]=test[j-1]; j--; &#125; test[j]=v; &#125;]]></content>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序（选择排序）]]></title>
    <url>%2F2017%2F04%2F27%2F%E6%8E%92%E5%BA%8F%EF%BC%88%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[假定第一个就是最小的然后遍历所有后面的数值，一旦比他小就把最小的下标改为它，直到遍历了所有的数据 1234567891011121314151617181920212223242526272829package com.company;public class Main &#123; static int test[] = &#123; 3, 15, 48, 7, 89, 45646, 145, 156, 484, 4, 56, 456, 18478, &#125;; public static void main(String[] args) &#123; for (int i = 0; i &lt; test.length - 1; i++) &#123; int min = i; for (int j = i+1; j &lt; test.length; j++) &#123; if (test[j] &lt; test[min]) &#123; min = j; &#125; &#125; int temp = test[min]; test[min] = test[i]; test[i] = temp; &#125; for (int i = 0; i &lt; test.length; i++) &#123; System.out.print(test[i]+&quot;,&quot;); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8-行为参数传递代码]]></title>
    <url>%2F2017%2F04%2F22%2Fjava8-%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[handler和messsage]]></title>
    <url>%2F2017%2F04%2F19%2Fhandler%E5%92%8Cmesssage%2F</url>
    <content type="text"><![CDATA[handler和message的原理这里总结一下handler和message的原理和需要注意的一些问题！ 首先安卓的主线程是不安全的，我们的耗时操作需要在子线程运行 ​ 于是产生了handler和message 这里需要记一下 handler的创建是不能再子线程的，除非在子线程创建之前调用了 1Looper.prepare(); 其实到这里就应该明白了，我们的主线程，app启动的时候在activitythread里就已经初始化了一个 Looper.prepareMainLooper(); 因为activity要执行attach ，而attach则会初始化这些东西。似的looper处于无限循环等待的状态中 一个线程只能创建一个looper， 123456public static final void prepare() &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper()); &#125; 从源码可以看出 如果线程不为空的话会抛出这个异常。 然而我们的message是如何通过handler把自己消息传送到handlerMessage的方法中的呢？ 这就涉及到了sendMessageAtTime（）的方法。 123456789101112131415public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; boolean sent = false; MessageQueue queue = mQueue; if (queue != null) &#123; msg.target = this; sent = queue.enqueueMessage(msg, uptimeMillis); &#125; else &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); &#125; return sent; &#125; 一个message对象和时间，时间表示发送消息的时间，若不是sendMessageDelayed 则时间为0，立即发送，然后将msg发送到MessageQueue的enqueueMessage方法中，他是一个消息队列，这个方法实在looper的构造函数中创建的 12345678910111213141516171819202122232425262728293031323334final boolean enqueueMessage(Message msg, long when) &#123; if (msg.when != 0) &#123; throw new AndroidRuntimeException(msg + &quot; This message is already in use.&quot;); &#125; if (msg.target == null &amp;&amp; !mQuitAllowed) &#123; throw new RuntimeException(&quot;Main thread not allowed to quit&quot;); &#125; synchronized (this) &#123; if (mQuiting) &#123; RuntimeException e = new RuntimeException(msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(&quot;MessageQueue&quot;, e.getMessage(), e); return false; &#125; else if (msg.target == null) &#123; mQuiting = true; &#125; msg.when = when; Message p = mMessages; if (p == null || when == 0 || when &lt; p.when) &#123; msg.next = p; mMessages = msg; this.notify(); &#125; else &#123; Message prev = null; while (p != null &amp;&amp; p.when &lt;= when) &#123; prev = p; p = p.next; &#125; msg.next = prev.next; prev.next = msg; this.notify(); &#125; &#125; return true; &#125; 在 msg.when = when; 开始如果当前处理的消息为空或者时间为0.或者时间小于当前待处理消息的时间，则把当前的消息插入队列，如果时间为零的话，则把这个mMessage赋值为新的msg，然后这个msg的next指向刚才的message，这样就把消息插在头部了 消息的出队123456789101112131415161718192021public static final void loop() &#123; Looper me = myLooper(); MessageQueue queue = me.mQueue; while (true) &#123; Message msg = queue.next(); // might block if (msg != null) &#123; if (msg.target == null) &#123; return; &#125; if (me.mLogging!= null) me.mLogging.println( &quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what ); msg.target.dispatchMessage(msg); if (me.mLogging!= null) me.mLogging.println( &quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); msg.recycle(); &#125; &#125; &#125; 一个死循环，它的简单逻辑就是如果当前MessageQueue中存在mMessages(即待处理消息)，就将这个消息出队，然后让下一条消息成为mMessages，否则就进入一个阻塞状态，一直等到有新的消息入队， msg.target.dispatchMessage(msg); 注意这个方法的dispatchMessage， 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; 这个就是mCallback的调用然后handlerMessage。 12345另外除了发送消息之外，我们还有以下几种方法可以在子线程中进行UI操作：1. Handler的post()方法2. View的post()方法3. Activity的runOnUiThread()方法 handler的post方法其实就是把runnable传入callback中然后再主线程中 调用run方法 view的post是直接调用handler的post方法 Activity的runOnUiThread()方法 1234567public final void runOnUiThread(Runnable action) &#123; if (Thread.currentThread() != mUiThread) &#123; mHandler.post(action); &#125; else &#123; action.run(); &#125; &#125; 如果当前的线程不是主线程的话则会自动调用handler的post方法 实际可以这么理解 Message 意为消息，发送到Handler进行处理的对象，携带描述信息和任意数据。 MessageQueue 意为消息队列，Message的集合。 Looper 有着一个很难听的中文名字，消息泵，用来从MessageQueue中抽取Message，发送给Handler进行处理。 Handler 处理Looper抽取出来的Message。 （抄来的，很好理解）]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bitmap上写字]]></title>
    <url>%2F2017%2F04%2F17%2Fbitmap%E4%B8%8A%E5%86%99%E5%AD%97%2F</url>
    <content type="text"><![CDATA[网易云的锁屏歌词是如何实现的？？学长突然问了我这个问题，是啊，怎麼实现的呢？貌似google并没有给我们这个接口，可是这些巨头却实现了，考虑了半天，也百度 google了一会，最后才知道 这些歌词是通过bitmap的实时渲染文字更新呢，可是这又有个问题，如果使用bitmap的话，那么多图片肯定会内存爆炸的！ 所以这里用到了个软引用（我觉得弱引用也可以） 所以话不过说，开写！ 界面非常简单就一个按钮和图片 可是我们要实现歌词的实时变换，怎麼实现呢。。我这就简化了下，用了个定时气 timer； 没个3秒钟就会自己自动渲染。 1234567891011imageView = (ImageView) findViewById(R.id.img);button = (Button) findViewById(R.id.button);button.setOnClickListener(this);list = new ArrayList&lt;&gt;();list.add(&quot;陪你把沿路感想活出了答案&quot;);list.add(&quot;陪你把独自孤单变成了勇敢&quot;);list.add(&quot;一次次失去又重来 我没离开&quot;);list.add(&quot;陪伴是 最长情的告白&quot;);list.add(&quot;陪你把想念的酸 拥抱成温暖&quot;);list.add(&quot;未来多漫长 再漫长 还有期待&quot;);list.add(&quot;陪伴你 一直到 故事给说完&quot;); list 就是歌词了，这里简化了 12345678910111213141516171819202122232425@Override public void onClick(View v) &#123; final Timer timer = new Timer(); final Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.ic_b33); timer.schedule(new TimerTask() &#123; int i = 0; @Override public void run() &#123; i++; if (i == list.size()) &#123; //timer.cancel(); i=0; &#125; Message message = new Message(); message.obj = getNewBitMap(list.get(i), bitmap,i); handler.sendMessage(message); &#125; &#125;, 200, 3000); &#125; 这是点击事件 这是 渲染图片的方法。 123456789101112131415161718192021222324public Bitmap getNewBitMap(String text, Bitmap bitmap,int i) &#123; if (mImageCache.containsKey(i))&#123; if (mImageCache.get(i).get()!=null)&#123; Log.d(&quot;===&quot;,&quot;return&quot;); return mImageCache.get(i).get(); &#125; &#125; WindowManager windowManager=getWindowManager(); Bitmap newBitmap = Bitmap.createBitmap(windowManager.getDefaultDisplay().getWidth(),windowManager.getDefaultDisplay().getHeight(), Bitmap.Config.ARGB_4444); Canvas canvas = new Canvas(newBitmap); canvas.drawBitmap(bitmap, 0, 0, null); TextPaint textPaint = new TextPaint(); textPaint.setAntiAlias(true); textPaint.setTextSize(160F); StaticLayout sl = new StaticLayout(text, textPaint, newBitmap.getWidth(), Layout.Alignment.ALIGN_CENTER, 1.0f, 0.0f, false); canvas.translate(6, 40); sl.draw(canvas); mImageCache.put(i,new SoftReference&lt;Bitmap&gt;(newBitmap)); return newBitmap; &#125; 还有通过hander 更新画面 123456789Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; Bitmap bitmap = (Bitmap) msg.obj; imageView.setImageBitmap(bitmap); super.handleMessage(msg); &#125; &#125;; 这里的图片方法就比较好理解了，首先new一个新的bitmap对象，它代表新的要加载的bitmap，它是用来加载原来的bitmap和文字的，然后文字卸载上面，填到map中，如果他因为内存原因被回收了，则重新渲染这个图片。。非常好理解！ http://i4.buimg.com/567571/a15846a46351cfc0.jpg http://i4.buimg.com/567571/e0299fd22afae178.jpg]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svg]]></title>
    <url>%2F2017%2F04%2F12%2Fsvg%2F</url>
    <content type="text"><![CDATA[SVG 意为可缩放矢量图形（Scalable Vector Graphics），是使用 XML 来描述二维图形和绘图程序的语言；使用 SVG 的优势在于： 1.SVG 可被非常多的工具读取和修改（比如记事本）,由于使用xml格式定义，所以可以直接被当作文本文件打开，看里面的数据； 2.SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强，SVG 图就相当于保存了关键的数据点，比如要显示一个圆，需要知道圆心和半径，那么SVG 就只保存圆心坐标和半径数据，而平常我们用的位图都是以像素点的形式根据图片大小保存对应个数的像素点，因而SVG尺寸更小； 3.SVG 是可伸缩的，平常使用的位图拉伸会发虚，压缩会变形，而SVG格式图片保存数据进行运算展示，不管多大多少，可以不失真显示； 4.SVG 图像可在任何的分辨率下被高质量地打印; 5.SVG 可在图像质量不下降的情况下被放大; 6.SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图）; 7.SVG 可以与 Java 技术一起运行; 8.SVG 是开放的标准; 9.SVG 文件是纯粹的 XML; 指令12345678910M = moveto 相当于 android Path 里的moveTo(),用于移动起始点 L = lineto 相当于 android Path 里的lineTo()，用于画线 H = horizontal lineto 用于画水平线 V = vertical lineto 用于画竖直线 C = curveto 相当于cubicTo(),三次贝塞尔曲线 S = smooth curveto 同样三次贝塞尔曲线，更平滑 Q = quadratic Belzier curve quadTo()，二次贝塞尔曲线 T = smooth quadratic Belzier curveto 同样二次贝塞尔曲线，更平滑 A = elliptical Arc 相当于arcTo()，用于画弧 Z = closepath 相当于closeTo(),关闭path]]></content>
      <tags>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法基础]]></title>
    <url>%2F2017%2F04%2F10%2F%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[searchview]]></title>
    <url>%2F2017%2F04%2F10%2Fsearchview%2F</url>
    <content type="text"><![CDATA[toolbar toolbar自带的搜索框其实非常实用 首先就是穿件menu的菜单！ 1234567891011121314@Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.search, menu); SearchManager searchManager = (SearchManager) getSystemService(Context.SEARCH_SERVICE); searchView = (SearchView) menu.findItem(R.id.ab_search).getActionView(); searchView.setSearchableInfo( searchManager.getSearchableInfo(getComponentName())); searchView.setOnQueryTextListener(this); return true; &#125; search.xml (menu)1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;item android:id=&quot;@+id/ab_search&quot; android:orderInCategory=&quot;60&quot; android:title=&quot;action_search&quot; app:actionViewClass=&quot;android.support.v7.widget.SearchView&quot; app:showAsAction=&quot;ifRoom&quot;/&gt;&lt;/menu&gt; xml12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;searchable xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:label=&quot;@string/app_name&quot; android:imeOptions=&quot;actionSearch&quot; android:hint=&quot;搜索&quot; /&gt; 上面这三行代码就是为了创建菜单而实现的。 12searchView.setOnQueryTextListener(this);实现setOnQueryTextListener接口判断数据的变化 和listview或者recycleview实现实时数据的搜索！这个刚开始觉得挺难的，试着写了一下，其实还可以！ 这需要adapter实现 filter的接口 重写 publishResults 和performFiltering方法！ 1234567891011121314151617181920212223242526@Override public Filter getFilter() &#123; return new Filter() &#123; @Override protected FilterResults performFiltering(CharSequence constraint) &#123; FilterResults results = new FilterResults(); List&lt;Map&lt;String, String&gt;&gt; datalist = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; mlist.size(); i++) &#123; if (mlist.get(i).get(&quot;title&quot;).contains(constraint)) &#123; datalist.add(mlist.get(i)); &#125; &#125; results.values = datalist; return results; &#125; @Override protected void publishResults(CharSequence constraint, FilterResults results) &#123; list=((List&lt;Map&lt;String, String&gt;&gt;) results.values); notifyDataSetChanged(); &#125; &#125;; 这里需要注意一下！因为你的数据实在实时刷新的，所以一旦回删数据的时候会导致数据恢复不了，所以初始化数据的时候一定要注意初始化一个 mdatalist 用来存放所有的数据，list用来实时更新加载数据！]]></content>
      <tags>
        <tag>toolbar的搜索框</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android头像缓存]]></title>
    <url>%2F2017%2F04%2F08%2FAndroid%E5%A4%B4%E5%83%8F%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[其实没那么难！之前一直抵触写这些东西，而且很多都是直接百度的，根本没有去想怎么回事。这不，今天下午有遇到这些问题了，无奈找了个网上的例子，看似很简单，可是使用中却发现根本不是那回事！ 当我们遇到listview 或者recycleview加载图片或者头像的时候 如果直接在getview的方法里面写一个异步的方法来加载图片的话写起来是简单，但是这样会导致item每次被重绘的时候都会去执行这个异步任务！导致app变卡，以及耗费流量等等有损用户体验的事情！ 于是今天下午自己逼着自己写了一个！才发现其实根本没有那么难。。。 思想其实就是每次加载的时候去你的本地文件夹判断是否有这个图片，如果有就直接加载，如果没有就去网络获取加载，在保存到本地！ 123456789String path=context.getExternalFilesDir(Environment.DIRECTORY_PICTURES).getPath(); imageView.setBackgroundResource(R.drawable.ic_img_load); final File file = new File(path + &quot;/iv2ex&quot;); String u = url.replace(&quot;/&quot;, &quot;!&quot;); u = u.replace(&quot;.&quot;, &quot;!&quot;); if (!file.exists()) &#123; file.mkdirs(); &#125; final File f = new File(file, u ); 这是文件夹的判断，如果没有父类文件夹直接创建！，然后记得吧图片的地址给转义下里面的“ /”不然会导致找不到文件。然后如果文件存在直接加载 12345678910if (f.exists()) &#123; try &#123; FileInputStream fos = new FileInputStream(f); Bitmap bitmap = BitmapFactory.decodeStream(fos); Drawable drawable = new BitmapDrawable(bitmap); imageView.setImageDrawable(drawable); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); imageView.setBackgroundResource(R.drawable.ic_person_outline_black_24dp); &#125; 如果文件不存在！ 1234567891011URL picUrl = null; try &#123; picUrl = new URL(url); Bitmap bitmap = BitmapFactory.decodeStream(picUrl.openStream()); OutputStream os = new FileOutputStream(f); bitmap.compress(Bitmap.CompressFormat.JPEG, 100, os); os.flush(); os.close(); subscriber.onNext(bitmap); subscriber.onCompleted(); 12Drawable drable = new BitmapDrawable(bitmap); imageView.setImageDrawable(drable); 我的异步任务是用rxjava写的。。很方便链式的。。 到这里就结束了，其实真的很简单，之前总是把事情想的非常复杂。。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统分享]]></title>
    <url>%2F2017%2F04%2F04%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[系统分享Android手机调用系统分享是个很常见的事情，所以今天来总结下分享的功能。 当分享单个文本的时候 1234567Intent shareIntent = new Intent(); shareIntent.setAction(Intent.ACTION_SEND); shareIntent.putExtra(Intent.EXTRA_TEXT, &quot;你要分享的文本&quot;); shareIntent.setType(&quot;text/plain&quot;); //设置分享列表的标题，并且每次都显示分享列表 startActivity(Intent.createChooser(shareIntent, &quot;分享到&quot;));//分享的标题 分享单个照片的时候 12345678910String imagePath =&quot;-------------&quot;//由文件得到uriUri imageUri = Uri.fromFile(new File(imagePath));Log.d(&quot;share&quot;, &quot;uri:&quot; + imageUri); //输出：Intent shareIntent = new Intent();shareIntent.setAction(Intent.ACTION_SEND);shareIntent.putExtra(Intent.EXTRA_STREAM, imageUri);shareIntent.setType(&quot;image/*&quot;);startActivity(Intent.createChooser(shareIntent, &quot;分享到&quot;)); 分享多个照片的时候 1234567891011ArrayList&lt;uri&gt; uriList = new ArrayList&lt;&gt;();String path = Environment.getExternalStorageDirectory() + File.separator;uriList.add(Uri.fromFile(new File(path+&quot;1.jpg&quot;)));uriList.add(Uri.fromFile(new File(path+&quot;2.jpg&quot;)));uriList.add(Uri.fromFile(new File(path+&quot;3.jpg&quot;)));Intent shareIntent = new Intent();shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE);shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, uriList);shareIntent.setType(&quot;image/*&quot;);startActivity(Intent.createChooser(shareIntent, &quot;分享到&quot;));]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓图库那些事]]></title>
    <url>%2F2017%2F04%2F04%2F%E5%AE%89%E5%8D%93%E5%9B%BE%E5%BA%93%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[相机的调用调用Intent的参数MediaStore.ACTION_IMAGE_CAPTURE实现 然后在startActivityForResult方法实现返回的数据。 12345678Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);//存放相机返回的图片File file = new File(filePath);if(file.exists())&#123;file.delete()&#125;Uri uri = Uri.fromFile(file);intent.putExtra(MediaStore.EXTRA_OUTPUT,uri);startActivityForResult(intent1,TAKE_PHOTO); 调用图库Intent的Action参数Intent.ACTION_GET_CONTENT 实现 12345Intent intent = new Intent(Intent.ACTION_GET_CONTENT);//选择图片格式intent.setType(&quot;image/*&quot;);intent.putExtra(&quot;return-data&quot;,true);startActivityForResult(intent,1); 这里在startActivityForResult 返回的是一个图片的uri； 调用系统的照片剪裁功能1234567891011Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;); intent.setDataAndType(uri, &quot;image/*&quot;); intent.putExtra(&quot;crop&quot;, &quot;true&quot;); intent.putExtra(&quot;aspectX&quot;, background.getWidth());//图片的关高比 intent.putExtra(&quot;aspectY&quot;, background.getHeight()); intent.putExtra(&quot;outputX&quot;, 500); intent.putExtra(&quot;outputY&quot;, 500);//图片的宽高 intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG);输出的图片格式 intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(file));输出的图片位置 intent.putExtra(&quot;return-data&quot;, false);是否有返回值？ startActivityForResult(intent, 3); 这里要注意系统剪裁完的图片会返回一个缩略图，具体为啥会这样因为内存原因，如果内存太大了的话在内存间传递会导致oom，我也是搞了好久才发现，所以不要返回值，直接记住他的uri，然后再回调方法里面去找到图片在进行其他处理。 备注如果存放照片的值出现filenotfound的异常的时候注意看看文件夹的父文件夹是否存在，最好用file.mkdirs()方法。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发布了人生第一款应用]]></title>
    <url>%2F2017%2F03%2F30%2F%E5%8F%91%E5%B8%83%E4%BA%86%E4%BA%BA%E7%94%9F%E7%AC%AC%E4%B8%80%E6%AC%BE%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[downloadmangager的使用]]></title>
    <url>%2F2017%2F03%2F29%2Fdownloadmangager%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[downloadmangager这是一个Android 2.3自带的一个下载api，它非常的方便，自动帮你写好了下载，暂停，和下载失败等等需要我们自己写的东西。 简单的使用 调用downloadmanger的requset方法 12DownloadManager.Request request = new DownloadManager.Request (Uri.parse(&quot;http://7xstld.com1.z0.glb.clouddn.com/kechengbiao.apk&quot;));// 字符串网址 request方法： 1setAllowedNetworkTypes\\设置允许下载的网络类型 1setNotificationVisibility \\设置下载在下拉菜单是否可见 (DownloadManager.Request.VISIBILITY_VISIBLE) 1setTitle 设置标题 1setDescription 设置描述 1setAllowedOverRoaming 设置是否可以被移除 123setDestinationInExternalFilesDir 设置下载地址 因人而异(SettingActivity.this, Environment.DIRECTORY_DOWNLOADS, &quot;kbdown&quot;)； ​ 1DownloadManager downloadManager = (DownloadManager) getSystemService(DOWNLOAD_SERVICE); enqueue 12long id = downloadManager.enqueue(request);// 返回一个id ，可以用这个id来查询下载信息 下载成功后会发出一个DownloadManager.ACTION_DOWNLOAD_COMPLETE这个广播并传递downloadId作为参数。通过接受广播我们可以打开对下载完成的内容进行操作 取消删除下载 1downloadManager.remove(REFERENCE_1, REFERENCE_2, REFERENCE_3); 查询状态 你可以通过查询Download Manager来获得下载任务的状态，进度，以及各种细节，通过query方法返回一个包含了下载任务细节的Cursor。 query方法传递一个DownloadManager.Query对象作为参数，通过DownloadManager.Query对象的setFilterById方法可以筛选我们希望查询的下 载任务的ID。也可以使用setFilterByStatus方法筛选我们希望查询的某一种状态的下载任务，传递的参数是DownloadManager.STATUS_*常量，可以指定 正在进行、暂停、失败、完成四种状态。 Download Manager包含了一系列COLUMN_*静态String常量，可以用来查询Cursor中的结果列索引。我们可以查询到下载任务的各种细节，包括状态， 文件大小，已经下载的字节数，标题，描述，URI，本地文件名和URI，媒体类型以及Media Provider download URI 对于暂停和失败的下载，我们可以通过查询COLUMN_REASON列查询出原因的整数码。对于STATUSPAUSED状态的下载，可以通过DownloadManager.PAUSED静态常量来翻译出原因的整数码，进而判断出下载是由于等待网络连接还是等待WiFi连接还是准备重新下载三种原因而暂停。对于STATUSFAILED状态的下载，我们可以通过DownloadManager.ERROR来判断失败的原因，可能是错误码（失败原因）包括没有存储设备，存储空间不足，重复的文件名，或者HTTP errors。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView的使用]]></title>
    <url>%2F2017%2F03%2F28%2FRecyclerView%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[之前写Android程序遇到列表显示都是使用listview，可能因为自己要写的东西比较简单吧，所以一直没去用recycleview。但是今天遇到了个让人恼火的事情，就是listview和CollapsingToolbarLayout不兼容，无法实现toolbar的折叠效果，即使外面裹上了一层NestedScrollView 还要自己去重写listview的方法，非常麻烦，而且貌似在Android5.0有bug？就是他的下面会溢出屏幕一个toolbar的高度，数据显示不全，于是今天去搞了下recyclevierecycleview和listview的思想差不多。虽然他的实现方法和listview差不多，但是还是有很大不同的，而且recycleview比listview比起来优势更多，更适合自定义，而且性能也很好，因为recycleview是直接继承groupview的，减少了图像的一层层的绘制，而listview则继承listview的抽象类。 具体recycle 的实现方法 12345recyclerView= (RecyclerView) findViewById(R.id.Recycle);final LinearLayoutManager manager=new LinearLayoutManager(this);recyclerView.setLayoutManager(manager);recyclerView.setHasFixedSize(true);recyclerView.addItemDecoration(new SpacesItemDecoration(3));//给recycleview添加分割线，因为recycle没有自带类似listview的driver; SpacesItemDecoration方法（下划线）12345678910111213141516171819public class SpacesItemDecoration extends RecyclerView.ItemDecoration &#123; private int space; public SpacesItemDecoration(int space) &#123; this.space = space; &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; outRect.left = space; outRect.right = space; outRect.bottom = space; // Add top margin only for the first item to avoid double space between items if (parent.getChildPosition(view) == 0) outRect.top = space; &#125; &#125; recycleview的adapter12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class GradeRecyclerAdapter extends RecyclerView.Adapter&lt;GradeRecyclerAdapter.ViewHolder&gt; &#123; private List&lt;Map&lt;String, String&gt;&gt; list; private Activity activity; //构造方法 public GradeRecyclerAdapter(List&lt;Map&lt;String, String&gt;&gt; list, Activity activity) &#123; this.list = list; this.activity = activity; &#125;//viewholder @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_list_library, parent,false); ViewHolder viewHolder = new ViewHolder(view); return viewHolder; &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; holder.bookname.setText(list.get(position).get(&quot;name&quot;)); holder.place.setText(list.get(position).get(&quot;palce&quot;)); holder.writer.setText(list.get(position).get(&quot;writer&quot;)); holder.num.setText(list.get(position).get(&quot;num&quot;)); final int a=position; holder.more.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(activity, BookDetalActivity.class); intent.putExtra(&quot;url&quot;, list.get(a).get(&quot;url&quot;)); activity.startActivity(intent); &#125; &#125;); &#125; @Override public int getItemCount() &#123; return list.size(); &#125; public static class ViewHolder extends RecyclerView.ViewHolder &#123; TextView bookname; TextView place; TextView writer; TextView num; TextView more; public ViewHolder(View itemView) &#123; super(itemView); bookname = (TextView) itemView.findViewById(R.id.bookname); place = (TextView) itemView.findViewById(R.id.place); writer = (TextView) itemView.findViewById(R.id.num); num = (TextView) itemView.findViewById(R.id.writer); more = (TextView) itemView.findViewById(R.id.moer); &#125; &#125;&#125; 以上就是recycleview的简单实现啦，很简单。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓学习路线]]></title>
    <url>%2F2017%2F03%2F28%2F%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[学了这么久安卓，忽然发现自己会的太少了，于是在ｖ２ｅｘ上求助，偶然发现好心人推荐的一个博客非常不错，里面总结了很多关于安卓学习用到的东西，今天在这跟大家分享下。 1http://www.jianshu.com/p/af2de05aadff]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux环境下搭建hexo博客]]></title>
    <url>%2F2017%2F03%2F28%2FLinux%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[之前一直用windows系统 ，直到前几天换了国产的linux系统deepin，发现这个系统真的不错！很漂亮尤其我这种做安卓开发的，用了deepin之后发现 as的打开速度快乐特别多。好了言归正传，我在这里讲一下如何在linux系统下搭建hexo个人博客。 第一步： 安装git1$ sudo apt-get install git 第二步：安装node.js之前上网google资料的时候走了好多弯路，网上很多人都说最好不用 apt-get的方法可是最后发现这个方法是最省力最方便的。1sudo apt-get install nodejs 1sudo apt-get install npm 直接运行以上两个命令，安装node.js 如果不好使把sudo去掉，或者 1sudo su 这时候让你输入密码然后在root用户下运行命令 如果直接安装的方法不管用了，别急还有另外两种方法去官网下载好node.js文件后 1cd node-***(你的node.js文件)/bin 1./node -v 然后将node命令设置全局可用： 1 ln -s /home/tongyangmysofltware/node-v0.10.28-linux-x64/bin/node /usr/local/bin/node 1ln -s /home/tongyang/mysofltware/node-v0.10.28-linux-x64/bin/npm /usr/local/bin/npm 这个目录根据个人情况而定 第三步：hexo的安装node.js安装完成后我们就可以安装hexo了 1npm install hexo-cli -g 初始化hexo 1hexo init 安装依赖包 1npm install 生成静态页面 1hexo generate （可以简写成 hexo g） 开启本地服务 1hexo server (同理简写成 hexo s) 浏览器打开http://localhost:4000就可以看到自己博客啦，不过现在还没有和自己github关联 第四步：发布自己的博客到github上1检查本地是否存在id1打开git bash，输入命令ls -al ~/.ssh。 如果存在直接跳过 如果没有 1234$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;# Creates a new ssh key using the provided email # Generating public/private rsa key pair. # Enter file in which to save the key (/home/you/.ssh/id_rsa): 直接Enter就行。然后，会提示你输入密码，如下(建议输一个，安全一点，当然不输也行)： 12Enter passphrase (empty for no passphrase): [Type a passphrase] # Enter same passphrase again: [Type passphrase again] 完了之后，大概是这样。 123Your identification has been saved in /home/you/.ssh/id_rsa. # Your public key has been saved in /home/you/.ssh/id_rsa.pub. # The key fingerprint is: # 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@youremail.com 你的秘钥已经生成 知道.shh下面的id_rsa. 或者id_rsa.pub. 复制你的秘钥所有内容 登陆你的github帐户。然后 Account Settings -&gt; 左栏点击 SSH Keys -&gt; 点击 Add SSH key 然后你复制上面的公钥内容，粘贴进“Key”文本域内。 title域，你随便填一个都行。 完了，点击 Add key。 可以使用一下命令查看是否成功 1$ ssh -T git@github.com 如果，看到： 1Hi username! You&apos;ve successfully authenticated, but GitHub does not # provide shell access. 就表示你的设置已经成功了。 至于怎么在github上面生成自己博客页面我就不多说了，不会的百度吧，因为我想作为一个程序员，连基友交友平台都不知道怎么用，那就太尴尬了。 在hexo文件夹的的住配置文件里面拉到最下面修改成这样 1234deploy: type: git repo: git@github.com:tongyangl/tongyangl.github.io.git branch: master 记住这个 repo是你在github上面的地址！ 最后直接在hexo页面执行以下命令 1hexo d 大多数都会成功 如果还不成功提示未找到git也可以用一些麻烦的方法push自己的博客 新建一个文件夹blog 1git clone 你github的博客地址 然后 12hexo ghexo s 删除blog的文件夹的内容 在hexo文件夹的public文件下的所有内容都复制到blog 然后 123git add ×git commit -m 你的commit内容随便你写git push]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用序列化器生成xml文件]]></title>
    <url>%2F2016%2F11%2F15%2F%E5%88%A9%E7%94%A8%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E7%94%9F%E6%88%90xml%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384List&lt;Message&gt; smsList; // 虚拟10条短信 smsList = new ArrayList&lt;Message&gt;(); for (int i = 0; i &lt; 10; i++) &#123; Message sms = new Message(&quot;小志好棒&quot; + i, System.currentTimeMillis() + &quot;&quot;, &quot;138&quot; + i + i, &quot;1&quot;); smsList.add(sms); &#125; &#125; public void click(View v)&#123; //使用xml序列化器生成xml文件 //1.拿到序列化器对象 XmlSerializer xs = Xml.newSerializer(); //2.初始化 File file = new File(&quot;sdcard/sms2.xml&quot;); try &#123; FileOutputStream fos = new FileOutputStream(file); //enconding:指定用什么编码生成xml文件 xs.setOutput(fos, &quot;utf-8&quot;); //3.开始生成xml文件 //enconding:指定头结点中的enconding属性的值 xs.startDocument(&quot;utf-8&quot;, true); xs.startTag(null, &quot;message&quot;); for (Message sms : smsList) &#123; xs.startTag(null, &quot;sms&quot;); xs.startTag(null, &quot;body&quot;); xs.text(sms.getBody() + &quot;&lt;body&gt;&quot;); xs.endTag(null, &quot;body&quot;); xs.endTag(null, &quot;sms&quot;); &#125; xs.endTag(null, &quot;message&quot;); //告诉序列化器，文件生成完毕 xs.endDocument(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;================================================================================================================================================================================================package com.itheima.createxml.domain;public class Message &#123; private String body; private String date; private String address; private String type; public String getBody() &#123; return body; &#125; public void setBody(String body) &#123; this.body = body; &#125; public String getDate() &#123; return date; &#125; public void setDate(String date) &#123; this.date = date; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; public Message(String body, String date, String address, String type) &#123; super(); this.body = body; this.date = date; this.address = address; this.type = type; &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试类测试数据库并且进行增删改查]]></title>
    <url>%2F2016%2F10%2F28%2F%E6%B5%8B%E8%AF%95%E7%B1%BB%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E4%B8%94%E8%BF%9B%E8%A1%8C%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187public class TestCase extends AndroidTestCase &#123; //此时测试框架还没有初始化完毕，没有虚拟上下文对象// private MyOpenHelper oh = new MyOpenHelper(getContext(), &quot;people.db&quot;, null, 1); private MyOpenHelper oh; private SQLiteDatabase db; public void test()&#123; //getContext():获取一个虚拟的上下文 MyOpenHelper oh = new MyOpenHelper(getContext(), &quot;people.db&quot;, null, 1); //如果数据库不存在，先创建数据库，再获取可读可写的数据库对象，如果数据库存在，就直接打开 SQLiteDatabase db = oh.getWritableDatabase(); //如果存储空间满了，那么返回只读数据库对象// SQLiteDatabase db = oh.getReadableDatabase(); &#125; //测试框架初始化完毕之后，在测试方法执行之前，此方法调用 @Override protected void setUp() throws Exception &#123; super.setUp(); oh = new MyOpenHelper(getContext(), &quot;people.db&quot;, null, 1); db = oh.getWritableDatabase(); &#125; //测试方法执行完毕之后，此方法调用 @Override protected void tearDown() throws Exception &#123; // TODO Auto-generated method stub super.tearDown(); db.close(); &#125; public void insert()&#123;// db.execSQL(&quot;insert into person (name, salary, phone)values(?, ?, ?)&quot;, new Object[]&#123;&quot;小志的老婆[1]&quot;, &quot;13000&quot;, 138438&#125;);// db.execSQL(&quot;insert into person (name, salary, phone)values(?, ?, ?)&quot;, new Object[]&#123;&quot;小志的儿子&quot;, 14000, &quot;13888&quot;&#125;); db.execSQL(&quot;insert into person (name, salary, phone)values(?, ?, ?)&quot;, new Object[]&#123;&quot;小志&quot;, 14000, &quot;13888&quot;&#125;); &#125; public void delete()&#123; db.execSQL(&quot;delete from person where name = ?&quot;, new Object[]&#123;&quot;小志&quot;&#125;); &#125; public void update()&#123; db.execSQL(&quot;update person set phone = ? where name = ?&quot;, new Object[]&#123;186666, &quot;小志的儿子&quot;&#125;); &#125; public void select()&#123; Cursor cursor = db.rawQuery(&quot;select name, salary from person&quot;, null); while(cursor.moveToNext())&#123; //通过列索引获取列的值 String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;)); String salary = cursor.getString(1); System.out.println(name + &quot;;&quot; + salary); &#125; &#125; public void insertApi()&#123; //把要插入的数据全部封装至ContentValues对象 ContentValues values = new ContentValues(); values.put(&quot;name&quot;, &quot;游天龙&quot;); values.put(&quot;phone&quot;, &quot;15999&quot;); values.put(&quot;salary&quot;, 16000); db.insert(&quot;person&quot;, null, values); &#125; public void deleteApi()&#123; int i = db.delete(&quot;person&quot;, &quot;name = ? and _id = ?&quot;, new String[]&#123;&quot;小志的儿子&quot;, &quot;3&quot;&#125;); System.out.println(i); &#125; public void updateApi()&#123; ContentValues values = new ContentValues(); values.put(&quot;salary&quot;, 26000); int i = db.update(&quot;person&quot;, values, &quot;name = ?&quot;, new String[]&#123;&quot;游天龙&quot;&#125;); System.out.println(i); &#125; public void selectApi()&#123; Cursor cursor = db.query(&quot;person&quot;, null, null, null, null, null, null, null); while(cursor.moveToNext())&#123; String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;)); String phone = cursor.getString(cursor.getColumnIndex(&quot;phone&quot;)); String salary = cursor.getString(cursor.getColumnIndex(&quot;salary&quot;)); System.out.println(name + &quot;;&quot; + phone + &quot;;&quot; + salary); &#125; &#125; public void transaction()&#123; try&#123; //开启事务 db.beginTransaction(); ContentValues values = new ContentValues(); values.put(&quot;salary&quot;, 12000); db.update(&quot;person&quot;, values, &quot;name = ?&quot;, new String[]&#123;&quot;小志&quot;&#125;); values.clear(); values.put(&quot;salary&quot;, 16000); db.update(&quot;person&quot;, values, &quot;name = ?&quot;, new String[]&#123;&quot;小志的儿子&quot;&#125;); int i = 3/0; //设置 事务执行成功 db.setTransactionSuccessful(); &#125; finally&#123; //关闭事务，同时提交，如果已经设置事务执行成功，那么sql语句就生效了，反之，sql语句回滚 db.endTransaction(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主线程阻塞，使用handler方法消息队列 和子线程请求主线程进行ui变化]]></title>
    <url>%2F2016%2F06%2F11%2Fhandler%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class MainActivity extends AppCompatActivity &#123;static ImageView iv;static MainActivity ma;static Handler handler = new Handler() &#123;@Overridepublic void handleMessage(Message msg) &#123;switch (msg.what) &#123;case 1:iv.setImageBitmap((Bitmap) msg.obj);break;case 2: Toast.makeText(ma, &quot;请求失败&quot;, Toast.LENGTH_SHORT).show();break; &#125; &#125; &#125;;protected void onCreate(Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState); setContentView(R.layout.activity_main);iv = (ImageView) findViewById(R.id.iv);ma = this; &#125;public void click(View v) &#123;final String path = &quot;http://192.168.74.154:8080/a.jpg&quot;;final File file = new File(getFilesDir(), getPathName(path));if (file.exists()) &#123; Log.d(&quot;======&quot;, &quot;1111 &quot;); Bitmap bm = BitmapFactory.decodeFile(file.getAbsolutePath());iv.setImageBitmap(bm); &#125; else &#123; Thread t = new Thread() &#123;public void run() &#123;try &#123; URL url = new URL(path); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(&quot;GET&quot;); conn.setReadTimeout(5000); conn.setConnectTimeout(5000); conn.connect();if (conn.getResponseCode() == 200) &#123; InputStream is = conn.getInputStream();byte[] b = new byte[1024]; FileOutputStream fos = new FileOutputStream(file);int len = 0;while ((len = is.read(b)) != -1) &#123; fos.write(b, 0, len); &#125; fos.close(); Bitmap bm = BitmapFactory.decodeFile(file.getAbsolutePath()); Message msg = handler.obtainMessage(); msg.obj = bm; msg.what = 1;handler.sendMessage(msg); &#125; else &#123; Message msg = handler.obtainMessage(); msg.what = 1; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;; t.start(); &#125; &#125;public String getPathName(String path) &#123;int index = path.lastIndexOf(&quot;/&quot;);return path.substring(index + 1); &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[计算机网络复习]]></title>
      <url>/2017/08/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/</url>
      <content type="html"><![CDATA[<ul>
<li><p>分组交换和电路交换</p>
<ul>
<li><p>分组交换</p>
<ul>
<li><p>资源不会被保留</p>
</li>
<li><p>效率高</p>
</li>
<li><p>今天的因特网就是分组交换</p>
<p>​</p>
</li>
</ul>
</li>
<li><p>电路交换</p>
<ul>
<li><p>资源会被保留</p>
</li>
<li><p>效率低</p>
</li>
<li><p>可以为一个通话保证特定数量的端到端宽带</p>
</li>
<li><p>频分多路复用分时多路复用</p>
<p>​</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分组交换的时延</p>
<p>处理时延+排队时延+传播时延+传输时延</p>
<ul>
<li><p>传输时延和传播时延的区别</p>
<ul>
<li><p>传输时延:</p>
<p>R= 链路带宽 (bps)<br>L= 分组长度 (比特)<br>发送比特进入链路的时间= L/R</p>
</li>
<li><p>传播时延:</p>
<p>d = 物理链路的长度<br>s = 在媒体中传播的速度 (~2x108 m/sec)<br>传播时延 = d/s</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>传播时延指的是线路传播时延，只与传输介质有关。传输指的是一定数据从开始传输到传输结束的时间，与介质、比特率有关。传输时延=传播时延+数据量/比特率。</p>
<p>传输是指我们接收或者发出文件或者数据；传输可以是非实时性的。</p>
<p>传播是指我们把文件或者数据发出；传播只具有单向性，实时性。</p>
<ul>
<li><p>分组交换对比电路交换</p>
<p>电路交换</p>
<ul>
<li>在数据传输前，必须建立端到端的连接</li>
<li>一旦某个节点故障，必须重新建立连接</li>
<li>连接建立后，数据的传输没有额外的延时</li>
<li>数据中不必包含地址域，仅需较短的虚电路号</li>
<li>数据按序传输，但信道的使用率较低</li>
<li>适合长时间传输大批量的数据，如流数据</li>
</ul>
<p>分组交换</p>
<ul>
<li>在数据传输前，不必建立端到端的连接</li>
<li>只要下一个节点空闲，即可传输</li>
<li>信道的使用率较高</li>
<li>数据的传输采用存储转发，延时不可估计</li>
<li>数据中必须包含地址域</li>
<li>接收到的分组不一定按序，可能还需重组</li>
<li>适合传输文本型数据</li>
</ul>
</li>
<li><p>因特网的分层</p>
<ul>
<li><p>应用层: 支持网络应用<br>FTP、HTTP、DNS、SMTP、DHCP等</p>
<ul>
<li><p>FTP：文件传输协议，FTP是因特网上使用得最广泛的文件传送协议。FTP提供交互式的访问，允许客户指明文件类型与格式，并允许文件具有存取权限。FTP其于TCP。</p>
</li>
<li><p>HTTP：超文本传输协议，是面向事务的应用层协议，它是万维网上能够可靠地交换文件的重要基础。http使用面向连接的TCP作为运输层协议，保证了数据的可靠传输。</p>
</li>
<li><p>DNS：域名系统，DNS是因特网使用的命名系统，用来把便于人们使用的机器名字转换为IP地址。</p>
<p>现在顶级域名TLD分为三大类：国家顶级域名nTLD；通用顶级域名gTLD;基础结构域名</p>
<p>域名服务器分为四种类型：根域名服务器；顶级域名服务器；本地域名服务器；权限域名服务器。</p>
</li>
<li><p>SMTP：电子邮件协议，即简单邮件传送协议。SMTP规定了在两个相互通信的SMTP进程之间应如何交换信息。SMTP通信的三个阶段：建立连接、邮件传送、连接释放。</p>
</li>
<li><p>POP3：邮件读取协议，协议通常被用来接收电子邮件</p>
</li>
<li><p>SNMP：简单网络管理协议。由三部分组成：SNMP本身、管理信息结构SMI和管理信息MIB。SNMP定义了管理站和代理之间所交换的分组格式。SMI定义了命名对象类型的通用规则，以及把对象和对象的值进行编码。MIB在被管理的实体中创建了命名对象，并规定类型。</p>
</li>
<li><p>Telnet：远程终端协议，telnet是一个简单的远程终端协议，它也是因特网的正式标准。又称为终端仿真协议。</p>
</li>
</ul>
</li>
<li><p>运输层: 主机到主机数据传输<br>TCP, UDP</p>
<ul>
<li><p>TCP：</p>
<p>特点：点到点，可靠、有序，全双工，面向连接，流量控制，拥塞控制。</p>
<p>连接时需要三次握手。</p>
<p>断开连接时需要四次挥手</p>
<p>TCP支持的应用协议主要有：Telnet、FTP、SMTP等。</p>
<p>TCP提供IP下的数据可靠传输，它提供的服务包括数据流传送、可靠性、有效流控、全双工操作和多路复用。通过面向连接、端到端和可靠的数据包发送。</p>
<p><strong>TCP协议采用了哪些机制保证数据的可靠传输？</strong></p>
<ul>
<li>连接时的 三次握手以及断开时的四次握手</li>
<li>确认机制（超时、稍带确认）</li>
<li>拥塞控制、流量控制</li>
</ul>
<p><strong>TCP中拥塞控制的方法：</strong></p>
<ul>
<li>加性增，乘性减</li>
<li>慢启动</li>
<li>对超时事件做出反应</li>
</ul>
<p>加性增：没有检测到拥塞的情况下，收到一个确认后就把拥塞窗口值增大一点（线性）</p>
<p>乘性减：每发生一次丢包事件就将当前的拥塞窗口值减半</p>
<p><strong>这里要特别注意拥塞控制、流量控制的区别</strong></p>
<ul>
<li>拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器不至于过载。拥塞控制的前提是：网络能够承受现有的网络负荷。</li>
<li>流量控制：点对点通信量的控制。控制发送端的发送数据的速率。</li>
</ul>
<p><strong>这里要特别注意选择重传、回退N步的区别</strong></p>
<ul>
<li>选择重传：只重传出现差错的数据帧。但这时必须加大接收窗口，以便先收下发送序列号不连续但仍在接收窗口中的数据帧。等到所缺序号的数据帧收到后再一并交给主机。</li>
<li>回退N步：当接收方检测出失序的数据帧后，要求发送方重发最后一个正确接收的信息之后所有未确认的帧；或者当发送方发了N个帧以后，发现N帧的前一帧在计时器超时后仍未返回其确认信息，则该帧被判超时或者出错，此时发送方不得不重新发送出错帧以及其后的帧。</li>
</ul>
</li>
<li><p>UDP：</p>
<p>​     是无连接的运输层协议</p>
<p>UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等.</p>
<p>而UDP则不为IP提供可靠性、流控或差错恢复功能，是非面向连接，不可靠的传输。</p>
<p>  优点：</p>
<ul>
<li>应用层能够更好地控制要发送的数据和发送时间</li>
<li>无需建立连接</li>
<li>无连接状态</li>
<li>分组首部开销小</li>
</ul>
<p>应用：</p>
<ul>
<li>常用于流式多媒体应用<ul>
<li>丢包容忍</li>
<li>速率敏感</li>
</ul>
</li>
<li>其他<ul>
<li>DNS</li>
<li>SNMP</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>网络层: 从源到目的地数据报的选路<br>ARP、IP、ICMP、OSPF、BGP等</p>
<ul>
<li><p>IP：网络之间互连的协议的外语（internet Protocol）缩写，中文缩写为“网协”.</p>
<p>因特网的地址分配策略被称为无类别域间选路（CIRD）。在采用CIRD之前，IP地址被分为A,B,C,D,E五类，分别为：</p>
<p><img src="https://ox.xizero.com/uploads/2017/08/7f34ab4373e42f75f9ff935bda594907.jpg" alt=""></p>
</li>
</ul>
<p>不过在这之间，有几个私有地址，是不能够被使用的，包括：</p>
<pre><code>A类 　　10.0.0.0 --10.255.255.255
</code></pre><p>​    B类 　　172.16.0.0–172.31.255.255</p>
<p>​    C类 　　192.168.0.0–192.168.255.255</p>
</li>
</ul>
</li>
</ul>
<pre><code>- ARP:地址解析协议，即ARP（Address Resolution Protocol）,

  ARP协议的主要功能是将32位IP地址转换为48位物理地址。

  工作过程：首先每台主机都会在缓冲区建立一个ARP列表，以表示IP与MAC的对应关系。当有数据包发送时，会先检查ARP列表中是否存在该IP对应的MAC地址，如果有，则直接将包发送到这个MAC地址，如果没有，就向本地网段发起一个ARP请求的广播包，网络中所有主机收到这个ARP包后，会先检查自己的IP是否与包中的IP地址一致，如果不一致则忽略，如果一致，则将发送端的MAC地址和IP地址添加到自己的ARP列表中（已存在的则覆盖），然后向发送端发送一个响应包，当发送方收到该响应包后,将接收方的IP与MAC添加到自己的ARP列表中。然后开始数据的传输

- ICMP:ICMP是（Internet Control Message Protocol）Internet控制[报文](https://baike.baidu.com/item/%E6%8A%A5%E6%96%87)协议。它是[TCP/IP协议族](https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE%E6%97%8F)的一个子协议，用于在IP[主机](https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA)、[路由](https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1)器之间传递控制消息。控制消息是指[网络通](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A)不通、[主机](https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA)是否可达、[路由](https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1)是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。

- OSPF:OSPF(Open Shortest Path First[开放式最短路径优先](https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E5%BC%8F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%BC%98%E5%85%88)）是一个[内部网关协议](https://baike.baidu.com/item/%E5%86%85%E9%83%A8%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE)(Interior Gateway Protocol，简称IGP），用于在单一[自治系统](https://baike.baidu.com/item/%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F)（autonomous system,AS）内决策[路由](https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1)。是对[链路状态路由协议](https://baike.baidu.com/item/%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE)的一种实现，隶属内部网关协议（IGP）

- BGP:边界网关协议（BGP）是运行于 TCP 上的一种[自治系统](https://baike.baidu.com/item/%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9F)的[路由协议](https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE)。 BGP 是唯一一个用来处理像因特网大小的网络的协议，也是唯一能够妥善处理好不相关[路由域](https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E5%9F%9F)间的多路连接的协议

- RIP:路由信息协议

- NAT（Network Address Translation，网络地址转换）是1994年提出的。当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。

-  RARP（Reverse Address Resolution Protocol）：逆向地址解析协议。
</code></pre><ul>
<li><p>数据链路层: 在邻近网元之间传输数据<br>ALOHA、CSMA或CSMA/CD、TDMA、FDMA、CDMA</p>
</li>
<li><p>物理层: “在线上”的比特<br>任何一种调制解调体制</p>
<p>以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2</p>
<p>​</p>
</li>
</ul>
<h4 id="MAC地址和IP地址有什么本质区别？"><a href="#MAC地址和IP地址有什么本质区别？" class="headerlink" title="MAC地址和IP地址有什么本质区别？"></a><strong>MAC地址和IP地址有什么本质区别？</strong></h4><p>　　MAC地址是数据链路层地址，IP地址是网络层地址；<br>　　MAC地址没有结构性涵义，IP地址有结构性涵义，表示计算机与网络之间的连接关系。<br>　　IP地址就是给每个连接在因特网上的主机（或路由器）分配一个在全世界范围内是唯一的32位的标识符，从而把整个因特网看成是一个单一的，抽象的网络；在实际网络的链路上传输数据帧时，最终还是要用到物理地址；<br>　　MAC地址在一定程度属于硬件一致，基于物理层。能标识具体的链路通信对象，IP地址给予逻辑域的划分，不受硬件控制；</p>
<h4 id="作为中间系统。转发器、网桥、路由器和网关有何区别？"><a href="#作为中间系统。转发器、网桥、路由器和网关有何区别？" class="headerlink" title="作为中间系统。转发器、网桥、路由器和网关有何区别？"></a><strong>作为中间系统。转发器、网桥、路由器和网关有何区别？</strong></h4><p>转发器：是物理层中间设备。主要作用是在物理层中实现透明的二进制比特复制，以补偿信号衰减。</p>
<p>网桥：是数据链路层的中间设备。主要作用是根据MAC帧的目的地址对收到的帧进行转发。网桥具有过滤帧的功能。</p>
<p>路由器：网络层的中间设备。作用是在互连网中完成路由选择的功能。</p>
<p>网关：网络层以上的中间系统。作用是在高层进行协议的转换以连接两个不兼容的系统。</p>
<h4 id="C-S模式和P2P模式的区别"><a href="#C-S模式和P2P模式的区别" class="headerlink" title="C/S模式和P2P模式的区别"></a><strong>C/S模式和P2P模式的区别</strong></h4><p>①：C/S结构是一种客户端/服务器结构，客户端与服务器之间是主从关系，是一种一对多的模式。它的信息和数据需要保存在服务器上，若用户要浏览和下载信息，必须先访问服务器，才能浏览和下载信息，而且客户机之间没有交互的能力。相反，P2P模式不分提供信息服务器和索取信息的客户端，每一台电脑都是信息的发布者和索取者，对等点之间能交互，无需使用服务器。<br>②：C/S模式中信息的存储和管理比较集中、稳定，服务器只公布用户想公布的信息，并且会在服务器中稳定地保存一段时间，该服务器通常也不间断的运行在网络间。而P2P缺乏安全机制，P2P是能给用户带来方便，但也会带来大量垃圾信息，而且各个对等点可以随便进入或者退出网络，会造成网络的不稳定。<br>③：从安全的角度来说，因为系统会出现漏洞，而C/S模式采用集中管理模式，客户端只能被动地从服务器获取信息，所以一旦客户端出了差错，并不会影响整个系统。<br>④：C/S模式的管理软件更新的较快，要跟上技术，必须花费大量精力和金钱在软件的更新换代上，而且工作人员要维护服务器和数据库，也要耗费大量资金。相反的P2P不需要服务器，也就不必耗费大量资金，而且每个对等点都可以在网络上发布和分享信息，这使得闲散资源得以充分的利用。</p>
]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据结构————栈]]></title>
      <url>/2017/08/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%A0%88/</url>
      <content type="html"><![CDATA[<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>一种先入后出的数据结构</p>
<h4 id="相关计算题"><a href="#相关计算题" class="headerlink" title="相关计算题"></a>相关计算题</h4><p>只用另一个栈和其他变量完成栈的排序</p>
<p>思想：使用一个中间变量current，记第一个栈为stack，第二个辅助栈为lstake</p>
<p>stack pop一个元素给current，和lstake的栈顶元素比较，当current小于栈顶元素直接push到栈顶，</p>
<p>反之当大于栈顶元素时，一直pushlstake的元素到stake栈顶，直到lstake的栈顶元素大于current的值。</p>
<p>一直重复直到stake的栈为空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">import java.util.Stack;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by 佟杨 on 2017/8/7.</div><div class="line"> */</div><div class="line">public class test &#123;</div><div class="line"></div><div class="line">    public static void main(String args[]) &#123;</div><div class="line"></div><div class="line">        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</div><div class="line">        stack.push(1);</div><div class="line">        stack.push(5);</div><div class="line">        stack.push(3);</div><div class="line">        stack.push(2);</div><div class="line">        stack.push(9);</div><div class="line">        stack.push(6);</div><div class="line">        stack.push(7);</div><div class="line">        int current;</div><div class="line">        Stack&lt;Integer&gt; lstake = new Stack&lt;&gt;();</div><div class="line">        lstake.push(stack.pop());</div><div class="line">        while (!stack.empty()) &#123;</div><div class="line">            current = stack.pop();</div><div class="line">            while (!lstake.empty()&amp;&amp;current&gt;lstake.peek())&#123;</div><div class="line">                stack.push(lstake.pop());</div><div class="line">            &#125;</div><div class="line">                lstake.push(current);</div><div class="line">            </div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for (int a : lstake) &#123;</div><div class="line"></div><div class="line">            System.out.print(a + &quot;,&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 数据结构 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[八大排序java实现]]></title>
      <url>/2017/08/05/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8Fjava%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>总结整理下八大排序的算法，用java实现。毕竟都是一些面试，平时使用都要用到的算法</p>
<ul>
<li><p>冒泡排序</p>
<ol>
<li>冒泡排序：一趟一趟的比较，比较相邻元素的大小，每趟有一个元素沉入最后面的位置 </li>
<li>属于交换类排序 </li>
<li>稳定的排序算法  </li>
<li>平均时间复杂度O(n*n) </li>
<li>最坏时间复杂度O(n*n) </li>
<li>空间复杂度O(1) </li>
<li>n较小时适用 </li>
</ol>
<p>​</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public static void bubbleSort(int[] array) &#123;</div><div class="line">       System.out.println(&quot;BubbleSort()&quot;);</div><div class="line">       for (int i = 0; i &lt; array.length; i++) &#123;//第i趟比较</div><div class="line"></div><div class="line">           for (int j = i + 1; j &lt; array.length; j++) &#123;</div><div class="line"></div><div class="line">               if (array[j] &lt; array[i]) &#123;</div><div class="line"></div><div class="line">                   swap(array,j,i);</div><div class="line">               &#125;</div><div class="line"></div><div class="line">           &#125;</div><div class="line"></div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">private static void swap(int[] array, int a, int b) &#123;</div><div class="line">    int t = array[a];</div><div class="line">    array[a] = array[b];</div><div class="line">    array[b] = t;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>选择排序<ol>
<li>​     *直接选择排序：第i轮选择剩余最小的元素放入到第i的位置上 </li>
<li>​     * 属于选择类排序 </li>
<li>​     * 不稳定的排序算法 ：如58529第一轮选择交换5和2，破换了原来两个5的顺序 </li>
<li>​     <em> 平均时间复杂度O(n</em>n) </li>
<li>​     <em> 最坏时间复杂度O(n</em>n) </li>
<li>​     * 空间复杂度O(1) </li>
<li>​     * 当n较小时适用 </li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public static void xuanze(int[] array)</div><div class="line">&#123;</div><div class="line">    for (int i=0;i&lt;arr.length-1;i++)&#123;</div><div class="line">        int min=i;</div><div class="line"></div><div class="line">        for (int j=i+1;j&lt;arr.length;j++)&#123;</div><div class="line">              if (arr[j]&lt;arr[min])&#123;</div><div class="line">                  min=j;</div><div class="line">              &#125;</div><div class="line">        &#125;</div><div class="line">       swap(arr,min,i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>插入排序<ol>
<li>​     *直接插入排序：每一轮第i个元素跟前面的i-1个元素从后向前比较，一直比较到合适插入的位置 </li>
<li>​     * 属于插入类排序 </li>
<li>​     * 稳定的排序算法  </li>
<li>​     <em> 平均时间复杂度O(n</em>n) </li>
<li>​     <em> 最坏时间复杂度O(n</em>n) </li>
<li>​     * 空间复杂度O(1) </li>
<li>​     * 大部分有序时适用 </li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public  static  void insertSort(int []array)&#123;</div><div class="line">     int current,j;</div><div class="line"></div><div class="line">     for (int i=1;i&lt;array.length;i++)&#123;</div><div class="line">            current=array[i];</div><div class="line">         for ( j=i-1;j&gt;=0&amp;&amp;array[j]&gt;current;j--)&#123;</div><div class="line"></div><div class="line">             array[j+1]=array[j];</div><div class="line"></div><div class="line">         &#125;</div><div class="line">         array[j+1]=current;</div><div class="line"></div><div class="line">     &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>快速排序<ol>
<li>​    通过递归和分治的思想，先确定一个值一般为第一个，然后从右向前遍历一旦后面的小，则第一个和这个数字交换位置，然后从左向右遍历。直到两个指针指向同一个位置。</li>
<li>​     <em> 平均时间复杂度O(n</em>log2n) </li>
<li>​     <em> 最坏时间复杂度O(n</em>n) </li>
<li>​     * 空间复杂度O(1) </li>
<li>​     * n较大 时适用 </li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public static void sort(int[] data, int left, int right) &#123;</div><div class="line">    // 枢纽元，一般以第一个元素为基准进行划分</div><div class="line">    int leftCurrent = left;</div><div class="line">    int rightCurrent = right;</div><div class="line">    if (left &lt; right) &#123;</div><div class="line">        // 从数组两端交替地向中间扫描</div><div class="line">        int pivotKey = data[left];</div><div class="line">        System.out.println(&quot;---leftCurrent:&quot; + leftCurrent + &quot;--rightCurrent:&quot; + rightCurrent + &quot;--key:&quot; + pivotKey);</div><div class="line">        // leftCurrent从左往右扫描，rightCurrent从右往左扫描</div><div class="line">        while (leftCurrent &lt; rightCurrent) &#123;</div><div class="line">            // 找到数组最右边比key小的值的下标</div><div class="line">            while (leftCurrent &lt; rightCurrent &amp;&amp; pivotKey &lt; data[rightCurrent]) &#123;</div><div class="line">                rightCurrent--;</div><div class="line">            &#125;</div><div class="line">            if (leftCurrent &lt; rightCurrent) &#123;</div><div class="line">                // 把右边比key小的值往前挪</div><div class="line">                data[leftCurrent] = data[rightCurrent];</div><div class="line">                leftCurrent++;</div><div class="line">                System.out.println(&quot;a:&quot; + Arrays.toString(data));</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            // 找到左边比key大的值的下标</div><div class="line">            while (leftCurrent &lt; rightCurrent &amp;&amp; pivotKey &gt; data[leftCurrent]) &#123;</div><div class="line">                leftCurrent++;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (leftCurrent &lt; rightCurrent) &#123;</div><div class="line">                // 把左边比key大的值往右挪</div><div class="line">                data[rightCurrent] = data[leftCurrent];</div><div class="line">                rightCurrent--;</div><div class="line">                System.out.println(&quot;b:&quot; + Arrays.toString(data));</div><div class="line">            &#125;</div><div class="line">        &#125;// end while</div><div class="line">        // 枢纽元素移动到正确位置</div><div class="line">        data[leftCurrent] = pivotKey;</div><div class="line">        System.out.println(&quot;---&quot; + Arrays.toString(data) + &quot;\n\n&quot;);</div><div class="line">        // 前半个子表递归排序</div><div class="line">        sort(data, left, leftCurrent - 1);</div><div class="line">        // 后半个子表递归排序</div><div class="line">        sort(data, leftCurrent + 1, right);</div><div class="line">    &#125;// end if</div><div class="line">&#125;//</div></pre></td></tr></table></figure>
<p>可以这么理解 两个指针 j k分别从左向右和从右向左遍历，</p>
<p>从左向右的一旦发现比key大的就给右边</p>
<p>从右向左的一旦发现比key小的就放左边</p>
<p>这样一直遍历到指针指向同一个位置，这个位置就是jk相同并且是key应该存在的位置</p>
<ul>
<li>希尔排序<ol>
<li>​     *希尔排序：分组交换的思想，先分组，后交换排序 </li>
<li>​     * 属于交换类排序 </li>
<li>​     * 不稳定的排序算法 ：分组之后交换打破了稳定性 </li>
<li>​     <em> 平均时间复杂度O(n</em>log2n) </li>
<li>​     * 最坏时间复杂度O(n^s) 1&lt;s&lt;2 </li>
<li>​     * 空间复杂度O(1) </li>
<li>​     * n较大时适用 </li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public static void shellSort(int[] data) &#123;</div><div class="line">    int i,j,group;</div><div class="line">    int n=data.length;</div><div class="line">    for (group=n/2;group&gt;0;group=group/2)&#123;</div><div class="line"></div><div class="line">        for (i=0;i&lt;group;i++)&#123;</div><div class="line">            for (j=i+group;j&lt;n;j+=group)&#123;</div><div class="line"></div><div class="line">                if (data[j] &lt; data[j - group])</div><div class="line">                &#123;</div><div class="line">                    int temp = data[j];</div><div class="line">                    int k = j - group;</div><div class="line">                    while (k &gt;= 0 &amp;&amp; data[k] &gt; temp)</div><div class="line">                    &#123;</div><div class="line">                        data[k + group] = data[k];</div><div class="line">                        k -= group;</div><div class="line">                    &#125;</div><div class="line">                    data[k + group] = temp;</div><div class="line">                &#125;</div><div class="line"></div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>堆排序</p>
<p>​</p>
</li>
</ul>
<p>二叉堆是完全二叉树或者是近似完全二叉树。</p>
<p>二叉堆满足二个特性：</p>
<p>1．父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。</p>
<p>2．每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。</p>
<p>当父结点的键值总是大于或等于任何一个子节点的键值时为<strong>最大堆</strong>。当父结点的键值总是小于或等于任何一个子节点的键值时为<strong>最小堆</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by 佟杨 on 2017/8/6.</div><div class="line"> */</div><div class="line">public class Template &#123;</div><div class="line"></div><div class="line">    public void CreatHeap(int a[], int n) &#123;</div><div class="line"></div><div class="line"></div><div class="line">        int isfirst = (n -2) / 2;//第一个非叶子节点</div><div class="line"></div><div class="line">        for (; isfirst &gt;= 0; isfirst--) &#123;</div><div class="line"></div><div class="line">            AdjustHeapNode(a, isfirst, n);</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void HeapSort(int a[], int n) &#123;</div><div class="line"></div><div class="line">        CreatHeap(a, n);</div><div class="line"></div><div class="line">        int temp;</div><div class="line">        for (int i = 0; i &lt; n - 1; i++) &#123;</div><div class="line">            temp = a[n - 1 - i];</div><div class="line">            a[n - 1 - i] = a[0];</div><div class="line">            a[0] = temp;</div><div class="line"></div><div class="line">            AdjustHeapNode(a, 0, n - 1 - i);</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void AdjustHeapNode(int a[], int i, int n) &#123;</div><div class="line">        if (n == 1 || i &gt; (n - 2) / 2)  //i为叶子节点  (n-2)/2 最后一个非叶子节点的位置</div><div class="line">            return;</div><div class="line"></div><div class="line">        int iLeft = 2 * i + 1;</div><div class="line">        int iRight = 2 * i + 2;</div><div class="line"></div><div class="line"></div><div class="line">        if (iRight &lt;= n - 1)     //说明i有左右两个子节点         三个节点找最大值</div><div class="line">        &#123;</div><div class="line">            if (a[i] &gt;= a[iLeft] &amp;&amp; a[i] &gt;= a[iRight])      // i 最大 不用调整</div><div class="line">                return;</div><div class="line"></div><div class="line">            if (a[i] &lt; a[iLeft] &amp;&amp; a[iRight] &lt;= a[iLeft])  // iLeft 最大</div><div class="line">            &#123;</div><div class="line">                int temp = a[iLeft];</div><div class="line">                a[iLeft] = a[i];</div><div class="line">                a[i] = temp;</div><div class="line">                AdjustHeapNode(a, iLeft, n);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (a[i] &lt; a[iRight] &amp;&amp; a[iLeft] &lt;= a[iRight]) // iRight 最大</div><div class="line">            &#123;</div><div class="line">                int temp = a[iRight];</div><div class="line">                a[iRight] = a[i];</div><div class="line">                a[i] = temp;</div><div class="line"></div><div class="line">                AdjustHeapNode(a, iRight, n);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; else &#123; // 说明i只有左节点   二个节点找最大值</div><div class="line">            //iLeft为最后一个节点</div><div class="line">            if (a[i] &gt;= a[iLeft])</div><div class="line">                return;</div><div class="line">            else &#123;</div><div class="line">                int temp = a[iLeft];</div><div class="line">                a[iLeft] = a[i];</div><div class="line">                a[i] = temp;</div><div class="line">                AdjustHeapNode(a, iLeft, n);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fragment懒加载]]></title>
      <url>/2017/08/02/Fragment%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      <content type="html"><![CDATA[<p>说真的！！网上的博客好多都是在别人那直接copy过来的！昨天看算法就是，百度第一页的所有博客几乎都一样而且不是一个人写的，最重要的是他妈的是错的！！！逻辑混乱，代码错误，挫的都一样。真的佩服。今天看懒加载又是这样。。不得不自己琢磨了</p>
<h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>大家都知道懒加载为了什么有事时候Viewpager 可能加载十多个Fragment ，一下子全加载了对用户体验很不好。而且viewpage的setOffscreenPageLimit方法看源码就知道了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private static final int DEFAULT_OFFSCREEN_PAGES = 1;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void setOffscreenPageLimit(int limit) &#123;</div><div class="line">    if (limit &lt; DEFAULT_OFFSCREEN_PAGES) &#123;</div><div class="line">        Log.w(TAG, &quot;Requested offscreen page limit &quot; + limit + &quot; too small; defaulting to &quot;</div><div class="line">                + DEFAULT_OFFSCREEN_PAGES);</div><div class="line">        limit = DEFAULT_OFFSCREEN_PAGES;</div><div class="line">    &#125;</div><div class="line">    if (limit != mOffscreenPageLimit) &#123;</div><div class="line">        mOffscreenPageLimit = limit;</div><div class="line">        populate();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你无论怎么设置它都至少加载下一页的体验很差！尤其每个fragment都有大量的网络请求和绘制的时候</p>
<p>所以懒加载诞生了。最重要的就是setUserVisibleHint这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public void setUserVisibleHint(boolean isVisibleToUser) &#123;</div><div class="line">    super.setUserVisibleHint(isVisibleToUser);</div><div class="line">   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当fragment可见的时候isVisibleToUser为true，反之亦然。但是这里要注意了，它是在oncreateview之前调用的，所以直接在这里请求绘制控件的话会空指针的！</p>
<p>所以我们封装一个BaseFragment</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">package rxjavatest.tycoding.com.iv2ex.ui.fragment;</div><div class="line"></div><div class="line">import android.os.Bundle;</div><div class="line">import android.support.annotation.Nullable;</div><div class="line">import android.support.v4.app.Fragment;</div><div class="line">import android.view.View;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by 佟杨 on 2017/8/1.</div><div class="line"> */</div><div class="line"></div><div class="line">public abstract class BaseFragment extends Fragment &#123;</div><div class="line"></div><div class="line">    protected boolean isVisable;</div><div class="line">    protected boolean isprepared = false;</div><div class="line">    protected boolean isdateInit=false;</div><div class="line">    @Override</div><div class="line">    public void setUserVisibleHint(boolean isVisibleToUser) &#123;</div><div class="line">        super.setUserVisibleHint(isVisibleToUser);</div><div class="line">        isVisable=isVisibleToUser;</div><div class="line">        prepareFetchData(false);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">        super.onActivityCreated(savedInstanceState);</div><div class="line">        isprepared=true;</div><div class="line">        prepareFetchData(false);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">   protected  void prepareFetchData(boolean force)&#123;</div><div class="line"></div><div class="line">       if (isVisable &amp;&amp; isprepared &amp;&amp; (!isdateInit || force)) &#123;</div><div class="line">           loadData();</div><div class="line">           isdateInit = true;</div><div class="line">       &#125;</div><div class="line"></div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line">    protected abstract void loadData( );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分别讲一下上面意思</p>
<p>首先三个boolean值分别是frag是否可见，view是否初始化，fragment是否加载过数据</p>
<p> protected abstract void loadData( );</p>
<p>这个抽象方法就是在子类中需要实现的，在这里进行数据加载。</p>
<p>prepareFetchData(boolean force)的参数用来我们子类执行是否每次都加载的操作</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自己写一个Handler]]></title>
      <url>/2017/07/27/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AAHandler/</url>
      <content type="html"><![CDATA[<p>前一阵整理了一下Handler的机制。。大概自己是弄明白的，但是为了巩固下自己，决定自己写一个handler，，当然我们是通过java程序来模拟。</p>
<p>首先回想下我们大概需要哪几个东西，没错，四个。</p>
<ul>
<li><p>Message</p>
</li>
<li><p>Looper</p>
</li>
<li><p>Handler</p>
</li>
<li><p>MessageQueue</p>
<p>​</p>
</li>
</ul>
<p>接下来我们就需要按照自己的印象和想法来实现。只要大概功能就行。</p>
<p>最简单的Message</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by 佟杨 on 2017/7/27.</div><div class="line"> */</div><div class="line">public class Message &#123;</div><div class="line">    Handler target;</div><div class="line">  public Object obj;</div><div class="line"></div><div class="line">    public Object getObj() &#123;</div><div class="line">        return obj;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">import java.util.concurrent.locks.Condition;</div><div class="line">import java.util.concurrent.locks.Lock;</div><div class="line">import java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by 佟杨 on 2017/7/27.</div><div class="line"> */</div><div class="line">public class MessageQueue &#123;</div><div class="line">    Message[] messages;</div><div class="line">    Lock lock = new ReentrantLock();</div><div class="line">    Condition ConditionFull;</div><div class="line">    Condition ConditionEmpty;</div><div class="line">    int putIndex;</div><div class="line">    int takeIndex;</div><div class="line">    int count;</div><div class="line"></div><div class="line">    public MessageQueue() &#123;</div><div class="line">        ConditionFull = lock.newCondition();</div><div class="line">        ConditionEmpty = lock.newCondition();</div><div class="line"></div><div class="line">        messages = new Message[50];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    final void enqueueMessage(Message mes) &#123;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line"></div><div class="line">            lock.lock();</div><div class="line">            while (count == messages.length) &#123;</div><div class="line"></div><div class="line">                try &#123;</div><div class="line">                    ConditionFull.await();</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">            messages[putIndex] = mes;</div><div class="line">            putIndex = (++putIndex == messages.length ? 0 : putIndex);</div><div class="line">            count++;</div><div class="line">            ConditionEmpty.signalAll();</div><div class="line"></div><div class="line">        &#125; finally &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line">    final Message next()&#123;</div><div class="line">        //取出消息</div><div class="line">        Message message = null;</div><div class="line">        try&#123;</div><div class="line">            lock.lock();</div><div class="line">            //取到最后一个</div><div class="line">            if (count == 0) &#123;</div><div class="line">                try &#123;</div><div class="line">                    ConditionEmpty.await();</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            message = messages[takeIndex];</div><div class="line">            messages[takeIndex] = null;</div><div class="line">            takeIndex = (++takeIndex == messages.length ? 0 : takeIndex);</div><div class="line">            count--;</div><div class="line">            //通知子线程</div><div class="line">            ConditionFull.signalAll();</div><div class="line">        &#125;finally&#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">        return message;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by 佟杨 on 2017/7/27.</div><div class="line"> */</div><div class="line">public class Looper &#123;</div><div class="line"></div><div class="line">    static  final ThreadLocal&lt;Looper&gt;sThreadLocal=new ThreadLocal&lt;&gt;();</div><div class="line">    MessageQueue messageQueue;</div><div class="line"></div><div class="line">    public Looper( ) &#123;</div><div class="line">        messageQueue=new MessageQueue();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Looper myLooper() &#123;</div><div class="line">        return sThreadLocal.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void prepare() &#123;</div><div class="line">        if (sThreadLocal.get() != null) &#123;</div><div class="line">            throw new RuntimeException(</div><div class="line">                    &quot;Only one Looper may be created per thread&quot;);</div><div class="line">        &#125;</div><div class="line">        sThreadLocal.set(new Looper());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void loop() &#123;</div><div class="line"></div><div class="line">        Looper me = myLooper();</div><div class="line">        if (me == null) &#123;</div><div class="line">            throw new RuntimeException(</div><div class="line">                    &quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        MessageQueue queue = me.messageQueue;</div><div class="line"></div><div class="line">        for (;;) &#123;</div><div class="line">            Message msg = queue.next();</div><div class="line">            if (msg == null || msg.target == null)</div><div class="line">                continue;</div><div class="line">            //转发给handler</div><div class="line">            msg.target.dispatchMessage(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by 佟杨 on 2017/7/27.</div><div class="line"> */</div><div class="line">public class Handler &#123;</div><div class="line">  MessageQueue messageQueue;</div><div class="line"></div><div class="line">  Looper looper;</div><div class="line"></div><div class="line"></div><div class="line">    public Handler() &#123;</div><div class="line">        looper = Looper.myLooper();</div><div class="line">        if (looper == null) &#123;</div><div class="line">            throw new RuntimeException(</div><div class="line">                    &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</div><div class="line">        &#125;</div><div class="line">        messageQueue = looper.messageQueue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public final void sendMessage(Message msg)&#123;</div><div class="line">        MessageQueue queue = messageQueue;</div><div class="line">        if (queue != null) &#123;</div><div class="line">            msg.target = this;</div><div class="line">            queue.enqueueMessage(msg);</div><div class="line">        &#125;else &#123;</div><div class="line">            RuntimeException e = new RuntimeException(</div><div class="line">                    this + &quot; sendMessage() called with no mQueue&quot;);</div><div class="line">            throw e;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public void handleMessage(Message msg) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Handle system messages here.</div><div class="line">     */</div><div class="line">    public void dispatchMessage(Message msg) &#123;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">import java.util.UUID;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by 佟杨 on 2017/7/19.</div><div class="line"> */</div><div class="line">public class test &#123;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    public static void main(String args[]) &#123;</div><div class="line">        Looper.prepare();</div><div class="line">        Handler handler=new Handler()&#123;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void handleMessage(Message msg) &#123;</div><div class="line"></div><div class="line">                System.out.println(Thread.currentThread().getName() + &quot;--receiver--&quot; + msg.toString());</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">            int finalI = i;</div><div class="line">            new Thread(new Runnable() &#123;</div><div class="line">                public void run() &#123;</div><div class="line"></div><div class="line">                    while (true) &#123;</div><div class="line"></div><div class="line">                        Message msg = new Message();</div><div class="line"></div><div class="line">                        synchronized (UUID.class) &#123;</div><div class="line">                            msg.obj = Thread.currentThread().getName()+&quot;--send---+&quot;+String.valueOf(finalI);</div><div class="line">                        &#125;</div><div class="line">                        System.out.println(msg);</div><div class="line">                        handler.sendMessage(msg);</div><div class="line">                        try &#123;</div><div class="line">                            Thread.sleep(1000);</div><div class="line">                        &#125; catch (InterruptedException e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">        //开始消息循环</div><div class="line">        Looper.loop();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行程序</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[handler的实现原理]]></title>
      <url>/2017/07/23/handler%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>说真的关于handler的原理的文章，网上多的是，之前由于自己懒惰，都是自己看网上分析的博客，然后稍微看一些源码，给自己弄的一知半解的，所以今天终于内心沉了下来，准备自己看看源码按照自己思路整理一下handler的实现。</p>
<p>handler是什么我就不多说了。。如果这个都不知道那就别往下看了。闲话短说，直接开始，我们一般使用handler都是直接使用内部类的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Handler handler=new Handler()&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void handleMessage(Message msg) &#123;</div><div class="line">        super.handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样，然后handleMessage更新ui信息。</p>
<p>说到handler不得不说其他几个类了。</p>
<ul>
<li><p>Message 意为消息，发送到Handler进行处理的对象，携带描述信息和任意数据。</p>
</li>
<li><p>MessageQueue 意为消息队列，Message的集合。</p>
</li>
<li><p>Looper 有着一个很难听的中文名字，消息泵，用来从MessageQueue中抽取Message，发送给Handler进行处理。</p>
</li>
<li><p>Handler 处理Looper抽取出来的Message。</p>
<p>​</p>
</li>
</ul>
<p>我们可以这样理解这四个东西。</p>
<p>首先线程调用Looper.prepare()方法，获取当前线程绑定的Looper对象，如果当前线程存在了Looper对象，则会抛出异常（Only one Looper may be created per thread） 之所以在主线程我们自己没有调用Looper.prepare()方法是因为在ActivityThread初始化的时候会自己初始化一个Looper对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private static void prepare(boolean quitAllowed) &#123;</div><div class="line">    if (sThreadLocal.get() != null) &#123;</div><div class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(new Looper(quitAllowed));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadLocal不用多说，线程私有的所以没有Looper对象 的话会自己在本线程添加一个Looper对象。我们看下这个方法 Looper(quitAllowed)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private Looper(boolean quitAllowed) &#123;</div><div class="line">    mQueue = new MessageQueue(quitAllowed);</div><div class="line">    mThread = Thread.currentThread();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化一个消息队列，并且获取当前的线程。</p>
<p>然后调用Looper.loop()方法，看一下源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public static void loop() &#123;</div><div class="line">    final Looper me = myLooper();</div><div class="line">    if (me == null) &#123;</div><div class="line">        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</div><div class="line">    &#125;</div><div class="line">    final MessageQueue queue = me.mQueue;/、拿到消息队列</div><div class="line"></div><div class="line">    // Make sure the identity of this thread is that of the local process,</div><div class="line">    // and keep track of what that identity token actually is.</div><div class="line">    Binder.clearCallingIdentity();</div><div class="line">    final long ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    for (;;) &#123;</div><div class="line">        Message msg = queue.next(); // might block</div><div class="line">        if (msg == null) &#123;</div><div class="line">            // No message indicates that the message queue is quitting.</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // This must be in a local variable, in case a UI event sets the logger</div><div class="line">        final Printer logging = me.mLogging;</div><div class="line">        if (logging != null) &#123;</div><div class="line">            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</div><div class="line">                    msg.callback + &quot;: &quot; + msg.what);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        final long traceTag = me.mTraceTag;</div><div class="line">        if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</div><div class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</div><div class="line">        &#125;</div><div class="line">        try &#123;</div><div class="line">            msg.target.dispatchMessage(msg);</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (traceTag != 0) &#123;</div><div class="line">                Trace.traceEnd(traceTag);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (logging != null) &#123;</div><div class="line">            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Make sure that during the course of dispatching the</div><div class="line">        // identity of the thread wasn&apos;t corrupted.</div><div class="line">        final long newIdent = Binder.clearCallingIdentity();</div><div class="line">        if (ident != newIdent) &#123;</div><div class="line">            Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</div><div class="line">                    + Long.toHexString(ident) + &quot; to 0x&quot;</div><div class="line">                    + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</div><div class="line">                    + msg.target.getClass().getName() + &quot; &quot;</div><div class="line">                    + msg.callback + &quot; what=&quot; + msg.what);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        msg.recycleUnchecked();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到我们如果不调用Looper.prepare方法的话则会抛出异常，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static @Nullable Looper myLooper() &#123;</div><div class="line">    return sThreadLocal.get();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过myLooper()方法获取线程中的looper对象。</p>
<p> final MessageQueue queue = me.mQueue;拿到消息队列</p>
<p>然后看源码很容易就可以知道进入一个死循环，从消息队列中源源不断的拿到信息，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msg.target.dispatchMessage(msg);</div></pre></td></tr></table></figure>
<p>这个代码很重要，尤其这个方法dispatchMessage（）可是点击这个方法发现找不到，我就很奇怪，难道这个方法不在looper类里面？于是看了一下handler的源码发现确实是这样。</p>
<p>我们先把这个放着块，等会再看。</p>
<p>看看handler的构造方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Handler() &#123;</div><div class="line">    this(null, false);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Handler(Looper looper) &#123;</div><div class="line">    this(looper, null, false);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Handler(Callback callback) &#123;</div><div class="line">    this(callback, false);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Handler(Looper looper, Callback callback) &#123;</div><div class="line">    this(looper, callback, false);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public Handler(boolean async) &#123;</div><div class="line">    this(null, async);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这么多的构造方法。。但是他们都使用了this，指向了最终的也是每次初始化都会调用到的构造方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public Handler(Callback callback, boolean async) &#123;</div><div class="line">    if (FIND_POTENTIAL_LEAKS) &#123;</div><div class="line">        final Class&lt;? extends Handler&gt; klass = getClass();</div><div class="line">        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</div><div class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</div><div class="line">            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</div><div class="line">                klass.getCanonicalName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mLooper = Looper.myLooper();</div><div class="line">    if (mLooper == null) &#123;</div><div class="line">        throw new RuntimeException(</div><div class="line">            &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</div><div class="line">    &#125;</div><div class="line">    mQueue = mLooper.mQueue;</div><div class="line">    mCallback = callback;</div><div class="line">    mAsynchronous = async;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从源码我们可以看到。。在这里handler里面的looper对象得到了绑定，拿到之前looper的对象，如果这个looper对象为空的话则会抛出异常，让你调用Looper.prepare()方法。</p>
<p>然后就是消息队列的关联。然后我们看源码可以发现，，这里面就不贴了太多了。。自己看也行，发现好多方法比如postAtTime（）最终都是调用的方法sendMessageAtTime（）；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</div><div class="line">    MessageQueue queue = mQueue;</div><div class="line">    if (queue == null) &#123;</div><div class="line">        RuntimeException e = new RuntimeException(</div><div class="line">                this + &quot; sendMessageAtTime() called with no mQueue&quot;);</div><div class="line">        Log.w(&quot;Looper&quot;, e.getMessage(), e);</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    return enqueueMessage(queue, msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>返回的是这个方法 enqueueMessage(queue, msg, uptimeMillis);</p>
<p>再看看这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</div><div class="line">    msg.target = this;</div><div class="line">    if (mAsynchronous) &#123;</div><div class="line">        msg.setAsynchronous(true);</div><div class="line">    &#125;</div><div class="line">    return queue.enqueueMessage(msg, uptimeMillis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msg.target = this;就是这个方法，是不是有点眼熟，</div></pre></td></tr></table></figure>
<p>msg.target.dispatchMessage(msg);</p>
<p>没错在这里把msg.target 赋值成了handler本身，这样就关联起来了。所以之前的那个方法在handler里面可以找到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void dispatchMessage(Message msg) &#123;</div><div class="line">    if (msg.callback != null) &#123;</div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; else &#123;</div><div class="line">        if (mCallback != null) &#123;</div><div class="line">            if (mCallback.handleMessage(msg)) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>怎么样很熟悉吧 handleMessage(msg);这个方法就是我们最终回调自己写的方法。我们可以看到他是一个空方法。。因为要自己完成接下来的事情。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public void handleMessage(Message msg) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中有个问题应该有人注意到了为什么那个消息队列的死循环存在主线程中还不会造成ANR？因为我们的任何点击事件，各种处理都是有这个循环来做的，也就是说我们之所以造成了ANR是因为自己的操作不当导致了Looper.loop()方法阻塞。。而不是    Looper.loop()阻塞了主线程。。</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Collction接口集合]]></title>
      <url>/2017/07/22/Collction%E6%8E%A5%E5%8F%A3%E9%9B%86%E5%90%88/</url>
      <content type="html"><![CDATA[<p><img src="https://ox.xizero.com/uploads/2017/07/3985563_e7febf364d8d8235.png" alt=""></p>
<p>如图所示可以清楚的看到实现Collection接口的集合类。一目了然。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>我们先从最常见的List子接口来看。</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>这是我们刚开始学java最最经常用到的结合类了，他支持List接口的全部功能，而且看他的名字就知道他的底层是基于数组实现的一个List类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;(initalCapacity：6);</div></pre></td></tr></table></figure>
<p>如上所示我们初始化了一个长度为6的List。</p>
<p>通过观察源码可以发现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public ArrayList(int initialCapacity) &#123;</div><div class="line">    if (initialCapacity &gt; 0) &#123;</div><div class="line">        this.elementData = new Object[initialCapacity];</div><div class="line">    &#125; else if (initialCapacity == 0) &#123;</div><div class="line">        this.elementData = EMPTY_ELEMENTDATA;</div><div class="line">    &#125; else &#123;</div><div class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</div><div class="line">                                           initialCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们在构造方法中传入数值的时候他会初始化我们自定义长度的一个数组。如果为负数则抛出异常。</p>
<p>如果不指定参数的话则调用默认的构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public ArrayList() &#123;</div><div class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</div></pre></td></tr></table></figure>
<p>看代码就看出来了。初始化一个长度为0的数组。</p>
<p>private static final int DEFAULT_CAPACITY = 10;</p>
<p>看出来了默认大小为10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public boolean add(E e) &#123;</div><div class="line"></div><div class="line">       ensureCapacityInternal(size + 1);  // 数组的大小增加1</div><div class="line"></div><div class="line">       elementData[size++] = e;</div><div class="line"></div><div class="line">       return true;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>ensureCapacityInternal方法就是确保数组拥有足够的大小来装填货物。</p>
<p>由此就可以知道了<strong>ArrayList是一个动态扩展的数组</strong></p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>它和ArrayList差不多。只不过他是线程安全的，之所以是线程安全的是因为他的操作数据的方法都加上了关键字synchronized，所以他的性能很差。。一般不会使用。</p>
<p>Vector和ArrayList的区别：</p>
<ul>
<li><p>ArrayList是线程不安全的，Vector是线程安全的。</p>
</li>
<li><p>Vector的性能比ArrayList差。</p>
</li>
<li><p>ArrayList每次动态扩大只增加本身的50%，而Vector会增加一倍</p>
<p>​</p>
</li>
</ul>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>他是Vector的子类，所以也是线程安全的，但是性能较差，通常用他模拟实现栈这个数据结构，即先入后出。</p>
<p>他有几个常见方法</p>
<ul>
<li><p>empty() 判断是否为空</p>
</li>
<li><p>peek() 查看栈顶部的对象，但是不移除他</p>
</li>
<li><p>pop()移除栈顶的对象，并且返回他</p>
</li>
<li><p>push()把对象压到栈顶</p>
</li>
<li><p>search(object o) 返回对象在栈的位置。注意他的基数是1,即从1开始</p>
<p>​</p>
</li>
</ul>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>它实现了List接口之外还实现了Deque接口，看名字可以看出来他的底部实现和ArrayList完全不一样，他是使用链表实现的，因此在随机访问集合元素的时候性能很差，但是在插入删除元素的时候性能很好，和ArrayList各有千秋，互有利弊。由于实现了Deque接口所以他也有双端队列的特性所以新增加了几种方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void addFirst(E e):将指定元素插入此列表的开头。</div><div class="line">void addLast(E e): 将指定元素添加到此列表的结尾。</div><div class="line">E getFirst(E e): 返回此列表的第一个元素。</div><div class="line">E getLast(E e): 返回此列表的最后一个元素。</div><div class="line">boolean offerFirst(E e): 在此列表的开头插入指定的元素。</div><div class="line">boolean offerLast(E e): 在此列表末尾插入指定的元素。</div><div class="line">E peekFirst(E e): 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。</div><div class="line">E peekLast(E e): 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。</div><div class="line">E pollFirst(E e): 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。</div><div class="line">E pollLast(E e): 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。</div><div class="line">E removeFirst(E e): 移除并返回此列表的第一个元素。</div><div class="line">boolean removeFirstOccurrence(Objcet o): 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。</div><div class="line">E removeLast(E e): 移除并返回此列表的最后一个元素。</div><div class="line">boolean removeLastOccurrence(Objcet o): 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。</div></pre></td></tr></table></figure>
<p>注意他也是非线程安全的。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet是Set接口的典型实现，实现了Set接口中的所有方法，并没有添加额外的方法，大多数时候使用Set集合时就是使用这个实现类。HashSet按Hash算法来存储集合中的元素。因此具有很好的存取和查找性能。</p>
<p>1.不能保证元素的排列顺序，顺序可能与添加顺序不同，顺序也有可能发生变化。<br>2.HashSet不是同步的，如果多个线程同时访问一个HashSet，则必须通过代码来保证其同步。<br>3.集合元素值可以是null。</p>
<p>他判断两个元素是否相等有个特点就是两个对象的equals方法相等，并且他的对象的hashCode方法也是相等才可以</p>
<p>所以有四种情况</p>
<p>1.如果有两个元素通过equal()方法比较返回false，但它们的hashCode()方法返回不相等，HashSet将会把它们存储在不同的位置。</p>
<p>2.如果有两个元素通过equal()方法比较返回true，但它们的hashCode()方法返回不相等，HashSet将会把它们存储在不同的位置。</p>
<p>3.如果两个对象通过equals()方法比较不相等，hashCode()方法比较相等，HashSet将会把它们存储在相同的位置，在这个位置以链表式结构来保存多个对象。这是因为当向HashSet集合中存入一个元素时，HashSet会调用对象的hashCode()方法来得到对象的hashCode值，然后根据该hashCode值来决定该对象存储在HashSet中存储位置。</p>
<p>4.如果有两个元素通过equal()方法比较返回true，但它们的hashCode()方法返回true，HashSet将不予添加。</p>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>LinkedHashSet是HashSet对的子类，但是他使用链表维护元素的次序，使得元素是以插入的顺序来保存的。</p>
<p>但是由于插入顺序的保证，所以性能没有HashSet高。但是它依旧不能有重复元素。</p>
<p>其实HashSet的实质是一个HashMap。HashSet的所有集合元素，构成了HashMap的key，其value为一个静态Object对象。因此HashSet的所有性质，HashMap的key所构成的集合都具备。</p>
<p>比如keyset方法返回一个set集合。</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>TreeSet是SortedSet接口的实现类，正如SortedSet名字所暗示的，TreeSet可以确保集合元素处于排序状态。此外，TreeSet还提供了几个额外的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">comparator():返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回null。</div><div class="line">first():返回此 set 中当前第一个（最低）元素。</div><div class="line">last(): 返回此 set 中当前最后一个（最高）元素。</div><div class="line">lower(E e):返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。</div><div class="line">higher(E e):返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。</div><div class="line">subSet(E fromElement, E toElement):返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）。</div><div class="line">headSet(E toElement):返回此 set 的部分视图，其元素小于toElement。</div><div class="line">tailSet(E fromElement):返回此 set 的部分视图，其元素大于等于 fromElement。</div></pre></td></tr></table></figure>
<p>TreeSet支持两种排序方法：自然排序和定制排序。在默认情况下，TreeSet采用自然排序。</p>
<ul>
<li><p>自然排序</p>
<p>Java提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法,该方法返回一个整数值，实现该接口的类必须实现该方法，实现了该接口的类的对象就可以比较大小了。当一个对象调用该方法与另一个对象比较时，例如obj1.compareTo(obj2),如果该方法返回0，则表明两个对象相等；如果该方法返回一个整数，则表明obj1大于obj2;如果该方法返回一个负整数，则表明oj1小于obj2。</p>
<p>TreeSet会调用集合中元素所属类的compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序排列，即把通过compareTo(Object obj)方法比较后比较大的的往后排。这种方式就是自然排序。</p>
<p>Java的一些常用类已经实现了Comparable接口，并提供了比较大小的标准。例如，String按字符串的UNICODE值进行比较，Integer等所有数值类型对应的包装类按它们的数值大小进行比较。<br>除了这些已经实现Comparable接口类之外，如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable接口，否则就会出现异常。<br><strong>注意：</strong>TreeSet中只能添加同一种类型的对象，否则无法比较，会出现异常。</p>
</li>
<li><p>定制排序</p>
<p>TreeSet的自然排序是根据集合元素中compareTo(Object obj)比较的大小，以升序排列。</p>
<p>该接口包含一个int compare(T o1,T o2)方法，该方法用于比较o1,o2的大小：如果该方法返回正整数，则表明o1大于o2；如果该方法返回0，则表明o1等于o2;如果该方法返回负整数，则表明o1小于o2。</p>
<p><strong>注意</strong> 如果排序之后改变了TreeSet的值则他不会自动再次排序</p>
<h5 id="TreeSet中判断集合元素相等"><a href="#TreeSet中判断集合元素相等" class="headerlink" title="TreeSet中判断集合元素相等"></a>TreeSet中判断集合元素相等</h5><p>对于TreeSet集合而言，判断两个对象是否相等的唯一标准是：两个对象通过compareTo(Object obj)方法比较是否返回0——如果通过compareTo(Object obj)方法比较返回0，TreeSet则会认为它们相等，不予添加入集合内；否则就认为它们不相等，添加到集合内。</p>
</li>
</ul>
<h3 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h3><p>EnumSet是一个专为枚举类设计的集合类，EnumSet中的所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显示或隐式地指定。EnumSet的集合元素也是有序的，EnumSet以枚举值在EnumSet类内的定义顺序来决定集合元素的顺序。</p>
<p>这个集合真的不咋常用，，他是线程不安全的。</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android四大组件-Broadcas]]></title>
      <url>/2017/07/20/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Broadcas/</url>
      <content type="html"><![CDATA[<p>广播作为四大组件之一，平时我们也不少用到，广播广播，顾名思自然有发送者和接受者，广播作为Android组件之间的通讯方式，有如下五中使用场景</p>
<ul>
<li><p>同一app内部的同一组件内的消息通信（单个或多个线程之间）；</p>
</li>
<li><p>同一app内部的不同组件之间的消息通信（单个进程）；</p>
</li>
<li><p>同一app具有多个进程的不同组件之间的消息通信；</p>
</li>
<li><p>不同app之间的组件之间消息通信；</p>
</li>
<li><p>Android系统在特定情况下与App之间的消息通信。</p>
<p>​</p>
</li>
</ul>
<h3 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h3><p>我们自定义的BroadcastReceiver需要继承BroadcastReceiver这个抽象基类，并且实现抽象方法onReceive(context, intent)。这个方法也是运行在UI线程的，所以也不要在这个方法中作过多了耗时操作。。不然就ANR了。。</p>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class MyBroadcastReceiver   extends BroadcastReceiver&#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onReceive(Context context, Intent intent) &#123;</div><div class="line">        Log.d(&quot;MyBroadcastReceiver:&quot;,intent.getStringExtra(&quot;name&quot;));</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>广播的注册类型分为两种，一种是静态注册一种是动态注册</p>
<h3 id="动态注册"><a href="#动态注册" class="headerlink" title="动态注册"></a>动态注册</h3><p>动态注册时，无须在AndroidManifest中注册<receiver>组件。直接在代码中通过调用Context的registerReceiver函数，可以在程序中动态注册BroadcastReceiver。registerReceiver的定义形式如下：</receiver></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends Activity  &#123;</div><div class="line">   private MyBroadcastReceiver receiver;</div><div class="line">    @Override</div><div class="line"></div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        IntentFilter intentFilter=new IntentFilter();</div><div class="line"></div><div class="line">        intentFilter.addAction(&quot;MyBroadcastReceiver&quot;);</div><div class="line">         receiver=new MyBroadcastReceiver();</div><div class="line"></div><div class="line">        registerReceiver(receiver,intentFilter);</div><div class="line">        Intent intent=new Intent();</div><div class="line">        intent.setAction(&quot;MyBroadcastReceiver&quot;);</div><div class="line">        intent.putExtra(&quot;name&quot;,&quot;name&quot;);</div><div class="line">        sendBroadcast(intent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDestroy() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">         unregisterReceiver(receiver);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class MyBroadcastReceiver   extends BroadcastReceiver&#123;</div><div class="line"></div><div class="line">      @Override</div><div class="line">      public void onReceive(Context context, Intent intent) &#123;</div><div class="line">          Log.d(&quot;MyBroadcastReceiver:&quot;,intent.getStringExtra(&quot;name&quot;));</div><div class="line"></div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当此Activity实例化时，会动态将MyBroadcastReceiver注册到系统中。当此Activity销毁时，动态注册的MyBroadcastReceiver将不再接收到相应的广播。</p>
<p>切记一定要进行解绑定unregisterReceiver(mBroadcastReceiver)。</p>
<h3 id="静态注册"><a href="#静态注册" class="headerlink" title="静态注册"></a>静态注册</h3><p>直接在配置文件AndroidManifest.xml进行注册。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;receiver android:enabled=[&quot;true&quot; | &quot;false&quot;]</div><div class="line">android:exported=[&quot;true&quot; | &quot;false&quot;]</div><div class="line">android:icon=&quot;drawable resource&quot;</div><div class="line">android:label=&quot;string resource&quot;</div><div class="line">android:name=&quot;string&quot;</div><div class="line">android:permission=&quot;string&quot;</div><div class="line">android:process=&quot;string&quot; &gt;</div><div class="line">. . .</div><div class="line">&lt;/receiver&gt;</div></pre></td></tr></table></figure>
<p>其中，需要注意的属性<br>android:exported  ——此broadcastReceiver能否接收其他App的发出的广播，这个属性默认值有点意思，其默认值是由receiver中有无intent-filter决定的，如果有intent-filter，默认值为true，否则为false。（同样的，activity/service中的此属性默认值一样遵循此规则）同时，需要注意的是，这个值的设定是以application或者application user id为界的，而非进程为界（一个应用中可能含有多个进程）；<br>android:name  —— 此broadcastReceiver类名；<br>android:permission  ——如果设置，具有相应权限的广播发送方发送的广播才能被此broadcastReceiver所接收；<br>android:process  ——broadcastReceiver运行所处的进程。默认为app的进程。可以指定独立的进程（Android四大基本组件都可以通过此属性指定自己的独立进程）</p>
<h3 id="广播的类型"><a href="#广播的类型" class="headerlink" title="广播的类型"></a>广播的类型</h3><ul>
<li><p>Normal Broadcast：普通广播</p>
<p>此处将普通广播界定为：开发者自己定义的intent，以context.sendBroadcast_”AsUser”(intent, …)形式。具体可以使用的方法有：<br>sendBroadcast(intent)/sendBroadcast(intent, receiverPermission)/sendBroadcastAsUser(intent, userHandler)/sendBroadcastAsUser(intent, userHandler,receiverPermission)。<br>普通广播会被注册了的相应的感兴趣（intent-filter匹配）接收，且顺序是无序的。如果发送广播时有相应的权限要求，BroadCastReceiver如果想要接收此广播，也需要有相应的权限。</p>
</li>
<li><p>System Broadcast: 系统广播</p>
<p>Android系统中内置了多个系统广播，只要涉及到手机的基本操作，基本上都会发出相应的系统广播。如：开启启动，网络状态改变，拍照，屏幕关闭与开启，点亮不足等等。每个系统广播都具有特定的intent-filter，其中主要包括具体的action，系统广播发出后，将被相应的BroadcastReceiver接收。系统广播在系统内部当特定事件发生时，有系统自动发出。</p>
</li>
<li><p><strong>Ordered broadcast：有序广播</strong></p>
<p>有序广播的有序广播中的“有序”是针对广播接收者而言的，指的是发送出去的广播被BroadcastReceiver按照先后循序接收。有序广播的定义过程与普通广播无异，只是其的主要发送方式变为：sendOrderedBroadcast(intent, receiverPermission, …)。</p>
<p>对于有序广播，其主要特点总结如下：</p>
<p>1&gt;多个具当前已经注册且有效的BroadcastReceiver接收有序广播时，是按照先后顺序接收的，先后顺序判定标准遵循为：将当前系统中所有有效的动态注册和静态注册的BroadcastReceiver按照priority属性值从大到小排序，对于具有相同的priority的动态广播和静态广播，动态广播会排在前面。</p>
<p>2&gt;先接收的BroadcastReceiver可以对此有序广播进行截断，使后面的BroadcastReceiver不再接收到此广播，也可以对广播进行修改，使后面的BroadcastReceiver接收到广播后解析得到错误的参数值。当然，一般情况下，不建议对有序广播进行此类操作，尤其是针对系统中的有序广播。</p>
</li>
<li><p><strong>Sticky Broadcast：粘性广播(在 android 5.0/api 21中deprecated,不再推荐使用，相应的还有粘性有序广播，同样已经deprecated)。</strong></p>
<p>既然已经deprecated，此处不再多做总结。</p>
</li>
<li><p><strong>Local Broadcast：App应用内广播（此处的App应用以App应用进程为界</strong></p>
<p>由前文阐述可知，Android中的广播可以跨进程甚至跨App直接通信，且注册是exported对于有intent-filter的情况下默认值是true，由此将可能出现安全隐患如下：</p>
<p>1.其他App可能会针对性的发出与当前App intent-filter相匹配的广播，由此导致当前App不断接收到广播并处理；</p>
<p>2.其他App可以注册与当前App一致的intent-filter用于接收广播，获取广播具体信息。</p>
<p>无论哪种情形，这些安全隐患都确实是存在的。由此，最常见的增加安全性的方案是：</p>
<p>1.对于同一App内部发送和接收广播，将exported属性人为设置成false，使得非本App内部发出的此广播不被接收；</p>
<p>2.在广播发送和接收时，都增加上相应的permission，用于权限验证；</p>
<p>3.发送广播时，指定特定广播接收器所在的包名，具体是通过intent.setPackage(packageName)指定在，这样此广播将只会发送到此包中的App内与之相匹配的有效广播接收器中。</p>
<p>App应用内广播可以理解成一种局部广播的形式，广播的发送者和接收者都同属于一个App。实际的业务需求中，App应用内广播确实可能需要用到。同时，之所以使用应用内广播时，而不是使用全局广播的形式，更多的考虑到的是Android广播机制中的安全性问题。</p>
<p>相比于全局广播，App应用内广播优势体现在：</p>
<p>1.安全性更高；</p>
<p>2.更加高效。</p>
<p>​</p>
<p>1).对于静态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是ReceiverRestrictedContext；</p>
<p>2).对于全局广播的动态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是Activity Context；</p>
<p>3).对于通过LocalBroadcastManager动态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是Application Context。</p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android四大组件-Activity]]></title>
      <url>/2017/07/20/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Activity/</url>
      <content type="html"><![CDATA[<p>Activity作为Android四大组件之一想必重要性不用多说。</p>
<p>Activity可以理解为Android程序我们看到的界面都是承载在Activity上。</p>
<h3 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h3><p><img src="" alt="http://img.blog.csdn.net/20160717151833576?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></p>
<p>  正常Activity的启动经历以下过程</p>
<ul>
<li><p>onCreat</p>
<p>Activity的创建，做一切初始化的操作，这个时候Activity还不可见。</p>
</li>
<li><p>onStart</p>
<p>Activity已经展现在前台页面，但是还是不可以交互。</p>
</li>
<li><p>onResume</p>
<p>Activity可见，并且可以交互。可以做一些onPause或者onStop释放资源的的回收操作</p>
</li>
<li><p>Activity进入运行状态</p>
</li>
<li><p>onPause</p>
<p>Activity进入后台之前可见的时候做一些回收工作，只有当前Activity的onpause方法执行完事之后下个Activity的onResume方法才会执行</p>
</li>
<li><p>onStop</p>
<p>Activity不可见。回收操作，不能太过于耗时。</p>
</li>
<li><p>onDestory</p>
<p>Activity销毁，可以做一些大量的回收操作</p>
<p>​</p>
</li>
</ul>
<p>如果ACtivity在进入onStop方法后未被销毁，而又被展现到前台页面则会调用onRestart()方法</p>
<p>onCreate的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">    super.onCreate(savedInstanceState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中savedInstanceState是一个Bundle类型的参数，会在onPause()或onStop()之前执行，在她和map差不多，都是键值对形式，我们可以在Activity快被销毁的时候储存一些东西</p>
<p>调用方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">protected void onSaveInstanceState(Bundle outState) &#123;</div><div class="line">    super.onSaveInstanceState(outState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里进行存储。</p>
<p>onRestoreInstanceState</p>
<p>这个方法会在Activity真正被销毁的时候才会执行。比如按下bcak键。</p>
<h3 id="Activity的四种LaunchMode"><a href="#Activity的四种LaunchMode" class="headerlink" title="Activity的四种LaunchMode"></a>Activity的四种LaunchMode</h3><ul>
<li>standard 模式</li>
</ul>
<p>这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。使用场景：大多数Activity。</p>
<ul>
<li>singleTop 模式</li>
</ul>
<p>如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。使用场景如新闻类或者阅读类App的内容页面。</p>
<ul>
<li>singleTask 模式</li>
</ul>
<p>如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。使用场景如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。</p>
<ul>
<li>singleInstance 模式</li>
</ul>
<p>在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。使用场景如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -&gt; B (singleInstance) -&gt; C，完全退出后，在此启动，首先打开的是B。</p>
<p>如何判断一个Activity加载完毕。使用onResume方法？  错。。这个不知道为啥就是错误的，</p>
<p>因为之前做过一个播放器，里面的mediaController是一个自定义的Popuwindow，需要加载玩Activity就显示，但是我放在onResume里面总是报错，显示窗口泄露，找不到Activity于是高了半天才发现这个方法。这个方法表示Activity加载完毕，可以做一些加载完毕就做得事情，如popuwindow的展示，测量加载完毕的View长度，如果在其他方法里面测量的话会导致长度错误或者为0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onConfigurationChanged(Configuration newConfig) &#123;</div><div class="line">    super.onConfigurationChanged(newConfig);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法是屏幕的旋转。当屏幕旋转的时候可以在这个方法进行操作。</p>
]]></content>
      
        <categories>
            
            <category> Android </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JAVA FIle的排序]]></title>
      <url>/2017/07/19/JAVA-FIle%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF/</url>
      <content type="html"><![CDATA[<p>之前搞了一个Android 的播放器，里面涉及到了好多关于java file文件的东西。</p>
<p>其中就有一个关于file的排序问题。</p>
<p>自己天真的以为用TreeSet就可以了。。但是发现是可以了，但是他是分大小写的，我们平常都是不分大小写的，所以自己鼓捣了一会发现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Collections.sort();</div><div class="line">这个方法</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private List&lt;File&gt; sortFileList(List&lt;File&gt; list) &#123;</div><div class="line"></div><div class="line">        Collections.sort(list, new Comparator&lt;File&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public int compare(File o1, File o2) &#123;</div><div class="line">                if (o1.isDirectory() &amp;&amp; o2.isFile())</div><div class="line">                    return -1;</div><div class="line">                if (o1.isFile() &amp;&amp; o2.isDirectory())</div><div class="line">                    return 1;</div><div class="line">                return o1.getName().compareToIgnoreCase(o2.getName());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        return list;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>实现 Comparator接口。就可以实现排序了</p>
<p>同样对于filelist这个方法也有一个FileFilter的接口传入，比如一些隐藏文件我们可以直接让他不显示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">file.listFiles(new FileFilter() &#123;</div><div class="line">    @Override</div><div class="line">    public boolean accept(File pathname) &#123;</div><div class="line">     if(pathname.getName().startsWith(&quot;.&quot;))&#123;</div><div class="line">       </div><div class="line">               return false;</div><div class="line"></div><div class="line">     &#125;else&#123;</div><div class="line">               return true;</div><div class="line"></div><div class="line">     &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这样就可以了。</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[测试]]></title>
      <url>/2017/07/15/%E6%B5%8B%E8%AF%95/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android性能优化]]></title>
      <url>/2017/05/11/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h3><p>尽量少用嵌套，能用linearLayout和frameLayout解决最好不要用RelativeLayout。</p>
<p>因为view的绘制会花更多的时间。</p>
<p>使用 <include> <merge>和ViewStub </merge></include></p>
<ul>
<li><p><include> 不用多说，大家应该很熟悉，可以指定一个布局文件到当前布局中，比如toolbar的设置，很多的app 中activity的toolbar都是相同的，没必要每个都写，这个标签是可以有id 的，并且可以设置宽高。其他的不行</include></p>
</li>
<li><p><merge> 它一般和<include>标签一起使用用来减少布局的层数</include></merge></p>
</li>
<li><p>ViewStub</p>
<p>他继承于view，并且非常轻量级，宽高都是0，所以它本身不参与绘制过程。它的意义在于在需要的时候加载所需的布局文件。比如一些隐藏的布局，在需要的时候显示！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;ViewStub   </div><div class="line">    android:inflateId=&quot;@id/inflateid&quot;</div><div class="line">    android:id=&quot;@+id/viewstub_demo_image&quot;  </div><div class="line">    android:layout_width=&quot;wrap_content&quot;  </div><div class="line">    android:layout_height=&quot;wrap_content&quot;  </div><div class="line">    android:layout_marginLeft=&quot;5dip&quot;  </div><div class="line">    android:layout_marginRight=&quot;5dip&quot;  </div><div class="line">    android:layout=&quot;@layout/viewstub_demo_image_layout&quot;/&gt;</div></pre></td></tr></table></figure>
<p>inflateid是加载布局的根元素的id，viewstub_demo_image是viewStub的id，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((viewstub)findviewbyId(R.id.viewstub_demo_image)).setVisibility(View.Visible);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">View myview=((ViewStub)findViewById(R.id.viewstub_demo_image)).infalte();</div></pre></td></tr></table></figure>
<p>这时候布局会被替换掉，但是目前Viewstub不支持<merge>标签</merge></p>
<p>​</p>
</li>
</ul>
<h3 id="绘制优化"><a href="#绘制优化" class="headerlink" title="绘制优化"></a>绘制优化</h3><p> 尽量不要在onDraw方法中进行大量的运算，循环，创建性的布局对象（会频繁调用onDraw方法）</p>
<h3 id="内存泄漏优化"><a href="#内存泄漏优化" class="headerlink" title="内存泄漏优化"></a>内存泄漏优化</h3><p>不要让静态变量持有禁用activity，会导致activity无法被销毁。或者progressDialog</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private static ProgressDialog dialog;</div><div class="line"></div><div class="line">   dialog=new ProgressDialog(this);</div></pre></td></tr></table></figure>
<p>这个this也对activity有引用，所以无法被销毁。</p>
<p>单利对象— 因为单例模式的对象适合applicantion的生命周期是一样的，所以当有时候我们不去解除绑定的话，activity会一直持有这个单例对象，会导致无法被销毁</p>
<p>属性动画在activity被销毁时要调用 animator.cancle()方法</p>
<p>不要在主线程中去做过多复杂的操作，这些都尽量去异步的放在子线程中去执行。 不然很容易anr，如果产生anr 系统会在/data/anr 目录下创建一个traces.txt文件。通过分析这个文件我们就能分析出ANR产生的原因。</p>
<h3 id="Listview"><a href="#Listview" class="headerlink" title="Listview"></a>Listview</h3><p>不要在getView方法中进行耗时操作。或者开启大量的异步任务。可以尝试开启硬件加速。和使用viewHolder减少findviewById方法。或者监听话筒状态比如，滑动的时候不要加载图片。分页加载等</p>
<h3 id="线程的优化"><a href="#线程的优化" class="headerlink" title="线程的优化"></a>线程的优化</h3><p>尽量使用线程池，避免程序中存在大量的THread。线程池可以重用内部的线程，避免了创建和销毁的开销。而且还可以控制线程的最大并发数。避免线程强占系统资源导致阻塞。</p>
<h3 id="杂七杂八"><a href="#杂七杂八" class="headerlink" title="杂七杂八"></a>杂七杂八</h3><p>不要创建过多的对象，不重要的对象可以使用 软引用和弱引用</p>
<p>不要使用枚举</p>
<p>常量使用 static final修饰</p>
<p>使用Android 特有的数据结构。 SparesArray 和Pair等</p>
<p>缓存采用三级缓存，内存，磁盘，网络</p>
<p>使用静态内部类，不然由于内部类对外存在持有，导致外部类不会被销毁</p>
]]></content>
      
        
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[图片缓存与bitmap的加载]]></title>
      <url>/2017/05/07/%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98%E4%B8%8Ebitmap%E7%9A%84%E5%8A%A0%E8%BD%BD/</url>
      <content type="html"></content>
      
        
        <tags>
            
            <tag> 图片 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[drawable]]></title>
      <url>/2017/05/04/drawable/</url>
      <content type="html"><![CDATA[<h3 id="drawable"><a href="#drawable" class="headerlink" title="drawable"></a>drawable</h3><p>他是一个图像的概念，不完全是指图片，一般是通过xml文件定义，她是一个抽象类，有着非常多的子类，子类都是直接继承它。</p>
<ul>
<li><p>bitmapdrawable</p>
<p>代表一张图片.</p>
<p>xml 属性有几个比较常用</p>
<ul>
<li><p>src —代表资源id</p>
</li>
<li><p>antialias —抗锯齿（开）</p>
</li>
<li><p>dither—抖动效果（开）开启会更好的适配</p>
</li>
<li><p>filter —在拉伸等情况下可以更好的显示（开启）</p>
</li>
<li><p>gravity—当图片小于容器的时候选择的属性 有很多</p>
</li>
<li><p>mipMap— 一种文理映射，不常用</p>
</li>
<li><p>titleMode—平铺模式</p>
<p>​</p>
</li>
</ul>
</li>
<li><p>ShapeDrawable</p>
<p>非常常见的drawable</p>
<ul>
<li><p>shape :有四个属性</p>
<ul>
<li><p>rectangle：矩形</p>
</li>
<li><p>oval：椭圆</p>
</li>
<li><p>line ：横线</p>
</li>
<li><p>ring ：圆环</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>corners :表示shape四个角的角度。只适用于矩形</p>
<ul>
<li><p>radius：四个角的角度，优先度低，会被其它属性覆盖</p>
</li>
<li><p>topLeftRadius：左上角</p>
</li>
<li><p>topRightRadius:右上角</p>
</li>
<li><p>bottomLeftRadius：左下角</p>
</li>
<li><p>bottomRightRadius：右下角</p>
<p>​</p>
</li>
</ul>
</li>
<li><p>gradient 和solid 互斥，表示渐变，而solid表示纯色填充</p>
<ul>
<li><p>angle :渐变的角度，默认为0,值必须是45的倍数，0表示从左到右，90表示从上到下</p>
</li>
<li><p>centerX：渐变的中心横坐标</p>
</li>
<li><p>centerY：渐变中心的纵坐标</p>
</li>
<li><p>startColor：渐变变的起始颜色</p>
</li>
<li><p>centerColor：渐变的中间色</p>
</li>
<li><p>endColor：渐变的结束颜色</p>
</li>
<li><p>gradientRadius：渐变半径</p>
</li>
<li><p>useLevel：一半为false，当drawable作为statelistDrawable的时候为true</p>
</li>
<li><p>type：渐变类别，linear（线性）radoal（径向渐变）sweep（扫描渐变）</p>
<p>​</p>
</li>
</ul>
</li>
<li><p>solid:填充的颜色，全色填充</p>
</li>
<li><p>stroke:shape的描边</p>
<ul>
<li><p>width:描边的宽度</p>
</li>
<li><p>color：描边的颜色</p>
</li>
<li><p>dashWidth：虚线的线段宽度</p>
</li>
<li><p>dashGap：虚线的线段之间的间隔</p>
<p>​</p>
</li>
</ul>
</li>
<li><p>padding 表示空白，表示包含它的view的空白</p>
</li>
<li><p>size shape的大小</p>
<p>​</p>
</li>
</ul>
<ul>
<li><p>LayerDrawable 层次化的drawable集合，标签为<layer-list> ,通过item实现叠加效果</layer-list></p>
</li>
<li><p>StateListDrawable <selector>标签，表示Drawable集合，每个drawable对应着view的一种状态</selector></p>
<p>比如button的点击等等</p>
<p>view的常见状态</p>
<ul>
<li><p>state_pressed，表示按下的状态，比如button被按下，但是没有松开</p>
</li>
<li><p>state_focused ,表示view获取了焦点</p>
</li>
<li><p>state_selected,表示选择了view</p>
</li>
<li><p>state_checked,表示用户选中的view 一般在checkbox</p>
</li>
<li><p>state_enabled,表示view处于可用状态</p>
<p>​</p>
</li>
</ul>
</li>
<li><p>TransitionDrawable <transition>  用于实现两个Drawable之间的淡入淡出效果</transition></p>
</li>
<li><p>insetDrawable <insert> 可以将其他Drawable内嵌到自己当中并且可以在四周留出间距</insert></p>
<p>当自己的drawable需要和实际的view有大小区别的时候</p>
</li>
<li><p>scale 根据自己等级 level将指定的Drawable缩放到一定的比例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;   </div><div class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;   </div><div class="line">&lt;scale     </div><div class="line">    android:interpolator= &quot;@android:anim/decelerate_interpolator&quot;         </div><div class="line">    android:fromXScale=&quot;0.0&quot;     </div><div class="line">    android:toXScale=&quot;1.5&quot;     </div><div class="line">    android:fromYScale=&quot;0.0&quot;     </div><div class="line">    android:toYScale=&quot;1.5&quot;     </div><div class="line">    android:pivotX=&quot;50%&quot;     </div><div class="line">    android:pivotY=&quot;50%&quot;     </div><div class="line">    android:startOffset=&quot;0&quot;     </div><div class="line">    android:duration=&quot;10000&quot;    </div><div class="line">    android:repeatCount=&quot;1&quot;     </div><div class="line">    android:repeatMode=&quot;reverse&quot;  /&gt;   </div><div class="line">&lt;/set&gt;   </div><div class="line">  </div><div class="line">&lt;!--    </div><div class="line">fromXDelta,fromYDelta       起始时X，Y座标,屏幕右下角的座标是X:320,Y:480   </div><div class="line">toXDelta， toYDelta      动画结束时X,Y的座标 --&gt; &lt;!--    </div><div class="line">interpolator                    指定动画插入器  </div><div class="line">常见的有加速减速插入器         accelerate_decelerate_interpolator  </div><div class="line">加速插入器               accelerate_interpolator，  </div><div class="line">减速插入器               decelerate_interpolator。   </div><div class="line">fromXScale,fromYScale，         动画开始前X,Y的缩放，0.0为不显示，  1.0为正常大小  </div><div class="line">toXScale，toYScale，          动画最终缩放的倍数， 1.0为正常大小，大于1.0放大  </div><div class="line">pivotX，  pivotY         动画起始位置，相对于屏幕的百分比,两个都为50%表示动画从屏幕中间开始   </div><div class="line">startOffset，                动画多次执行的间隔时间，如果只执行一次，执行前会暂停这段时间，  </div><div class="line">                    单位毫秒 duration，一次动画效果消耗的时间，单位毫秒，  </div><div class="line">                    值越小动画速度越快 repeatCount，动画重复的计数，动画将会执行该值+1次   </div><div class="line">                    repeatMode，动画重复的模式，reverse为反向，当第偶次执行时，动画方向会相反。  </div><div class="line">                    restart为重新执行，方向不变 --&gt;</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>CliPDrawable <clip> 可以通过自己等级来剪裁另一个Drawable</clip></p>
<p>clipOrientation表示剪裁的方向</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">testClipDrawable.setLevel(3000)</div></pre></td></tr></table></figure>
<p>level 为0-10000 ，例如3000表示剪裁了30%；</p>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> drawable </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[view的工作原理]]></title>
      <url>/2017/05/02/view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>ViewRoot是对应ViewRootImpl类，他是连接windowmangager和DecorView的纽带。</p>
<p>view的三大绘制流程都是从viewroot开始的，在ActivityThread中，activity对象被创建完成后，会把decorview添加到window中。同时创建vIewrootImpl对象。</p>
<p>view的绘制从viewroot的performTraversals方法开始分别对应 measure，layout，和draw，分别对应</p>
<ul>
<li><p>测量宽高</p>
</li>
<li><p>确定view在父容器中的位置</p>
</li>
<li><p>绘制</p>
<p>​</p>
</li>
</ul>
<p>performTraversals会依次调用perfromMeasure，performLayout,performDraw 方法，这三个方法会完成顶级view的 三个绘制过程，其中的performMeasure会调用measure ，然后再调用onmeasure</p>
<p>然后再onmeasure方法中会继续对子view进行measure过程，这样就遍历了整个view树。</p>
<p>其他两个方法也是类似</p>
<p>DecorView作为顶级的view其实包含一个linearlayout，分为两个部分，一个titlebar和content，所以我们的oncreate方法中是setcontentview而不是setview</p>
<h1 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h1><p>measureSpec会根据view的layoutparams和父容器施加的规则转换而来</p>
<p>MeasureSpec是一个32位的int值，前两位代表测量模式SpecMode，后面代代表SpecSize测量大小</p>
<p>SpecMode分为三种</p>
<ul>
<li><p>UNSPECIFIED 父容器对view的宽高没有任何的限制，要多打给多大，一般出现在系统内部</p>
</li>
<li><p>EXACTLY 精确大小，表示view的大小就是spceSize， 如match_parent，或者精确的一个数值</p>
</li>
<li><p>AT_MOST 父容器给顶了一个大小，view的大小不能超过它，比如wrap_contet</p>
<p>​</p>
</li>
</ul>
<p>最顶级的view decorview的大小是由他自己的layoutparams和窗口的尺寸决定，而其他的view都是父容器的规则和自身的layoutparams决定。</p>
<p>MeasureSpec一旦确定后 onMeasure就可以确定view的最终宽高</p>
<p>padding代表父容器已经占用的大小，所以实际可用大小为父容器大小减去padding。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int size=Math.max(0,specSize-padding);</div></pre></td></tr></table></figure>
<h1 id="view的工作流程"><a href="#view的工作流程" class="headerlink" title="view的工作流程"></a>view的工作流程</h1><p>———–Measure————layout———–draw</p>
<h3 id="measure"><a href="#measure" class="headerlink" title="measure"></a>measure</h3><p>如果是viewgroup则除了测量自己的大小，还要去遍历调用字view 的measure的方法如果是view则只调用measure</p>
<p>view的measure方法是一个final方法，不能被重写而在measrue方法中会调用onMseasure方法。</p>
<h5 id="viewgroup的measure过程"><a href="#viewgroup的measure过程" class="headerlink" title="viewgroup的measure过程"></a>viewgroup的measure过程</h5><p>viewgroup是抽象类没有实现onMeasure，但是有一个measureChildren方法。</p>
<p>之所以它没有实现测量方法，是因为他需要子类去实现这个方法如linearlayout等，因为每个的布局特性导致他们的测量方法不同。</p>
<p>记住 view的onMeasure过程不是和acitvity同步的，所以在oncreate和onstart或者onresume中无法获取到真正的宽高</p>
<p>所以要使用如下方法调用是比较正确的</p>
<ul>
<li>通过onWindowFocusChanged方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void onWindowFocusChanged(boolean hasFocus)&#123;</div><div class="line">  surper.onWindowFocusChanged(hasFocus);</div><div class="line">  if(hasFocus)&#123;</div><div class="line">    int height=view.getmeasureheight（）；</div><div class="line">     int width=view.getmeasureWidth（）；</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>通过view.post方法</p>
<p>post一个runable投入到消息队列，然后等待Looper调用runable的时候view已经初始化好了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">view.post(new runable()&#123;</div><div class="line">  @Override</div><div class="line">  public void run()&#123;</div><div class="line">  </div><div class="line">  // 获取宽高</div><div class="line">   int height=view.getmeasureheight（）；</div><div class="line">     int width=view.getmeasureWidth（）；</div><div class="line">  </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>通过ViewTreeObserver的回调方法</p>
</li>
<li><p>通过view.measure(int WidthMeasureSpec,int HeightMeasureSpec)</p>
<p> match_parent  直接放弃，无法获取</p>
<p>具体的数值 </p>
</li>
</ul>
<p>​        warp_content</p>
<h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><p>ViewGroup调用layout方法确定自己的位置，当自己的位置确定后他会调用onlayout方法遍历子元素的laout方法，然后子元素在去调用layout方法 </p>
<p>layout方法确定本身的位置，onlayout确定子元素的位置</p>
<p>layout方法会通过 setfrme 确定view的四个顶点位置mLeft，mRight,mTop,mbottom.四个点确定了位置也就确定了然后调用onlayout方法 ，它和onmeasure方法一样，viewgroup没有具体的实现，</p>
<h3 id="draw"><a href="#draw" class="headerlink" title="draw"></a>draw</h3><p>draw的过程遵循四步骤</p>
<ul>
<li><p>绘制背景</p>
</li>
<li><p>绘制自己（onDraw）</p>
</li>
<li><p>绘制children（dispatchDraw）</p>
</li>
<li><p>绘制装饰（onDrawScrollBars）</p>
</li>
</ul>
<p>View的特殊方法 ——–setWillNotDraw</p>
<p>表示一个view如果不需要绘制则可以设置为ture，这样系统会进行优化。viewgroup会默认的开启这个方法，如果我们的自定义view需要onDraw方法来绘制东西，则我们需要关闭这个方法</p>
]]></content>
      
        
        <tags>
            
            <tag> view </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[希尔排序]]></title>
      <url>/2017/04/28/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">static void xier()&#123;</div><div class="line">    int i,j,h,v;</div><div class="line">    for (h=1;h==test.length/9;h=h*3+1);</div><div class="line">    for (;h&gt;0;h=h/3)&#123;</div><div class="line">       for (i=h+1;i==test.length;i+=1)&#123;</div><div class="line"></div><div class="line">           v=test[i];</div><div class="line">           j=i;</div><div class="line">           while (j&gt;h&amp;&amp;test[j-h]&gt;v)</div><div class="line">           &#123;</div><div class="line">               test[j]=test[j-h];</div><div class="line">                j-=h;</div><div class="line"></div><div class="line">           &#125;</div><div class="line">           test[j]=v;</div><div class="line">       &#125;</div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过设置一个间距在可以在较远的距离进行位置交换，并且不断缩小这个间距知道距离变为1，这个时候的数组已经变得基本有序，最后的一次排序也就成为了插入排序，但是因为数组有序度高所以耗时短、</p>
]]></content>
      
        
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[排序（冒泡排序，插入排序）]]></title>
      <url>/2017/04/28/%E6%8E%92%E5%BA%8F%EF%BC%88%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>最常见也是最简单的冒泡排序时间复杂度0（n^2）;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">for (int i = 0; i &lt; test.length-1; i++) &#123;</div><div class="line">    for (int j = i+1; j &lt; test.length; j++) &#123;</div><div class="line">        if (test[j] &lt; test[i]) &#123;</div><div class="line">            int temp = test[j];</div><div class="line">            test[j] = test[i];</div><div class="line">            test[i] = temp;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>插入排序；</p>
<p>数据量较小时速度很快。</p>
<p>进行局部排序，一部分一部分来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private   static  void charu()</div><div class="line"> &#123;</div><div class="line">     int v ,j;</div><div class="line"></div><div class="line">     for (int i=1;i&lt;test.length;i++)&#123;</div><div class="line"></div><div class="line">         v=test[i];</div><div class="line">         j=i;</div><div class="line">         while (test[j-1]&gt;v&amp;&amp;j&gt;=1)&#123;</div><div class="line">             test[j]=test[j-1];</div><div class="line">             j--;</div><div class="line">         &#125;</div><div class="line">         test[j]=v;</div><div class="line"></div><div class="line">     &#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[排序（选择排序）]]></title>
      <url>/2017/04/27/%E6%8E%92%E5%BA%8F%EF%BC%88%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>假定第一个就是最小的然后遍历所有后面的数值，一旦比他小就把最小的下标改为它，直到遍历了所有的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">package com.company;</div><div class="line"></div><div class="line">public class Main &#123;</div><div class="line">    static int test[] = &#123;</div><div class="line">            3, 15, 48, 7, 89, 45646, 145, 156, 484, 4, 56, 456, 18478,</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; test.length - 1; i++) &#123;</div><div class="line">            int min = i;</div><div class="line">            for (int j = i+1; j &lt; test.length; j++) &#123;</div><div class="line">                if (test[j] &lt; test[min]) &#123;</div><div class="line">                    min = j;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            int temp = test[min];</div><div class="line">            test[min] = test[i];</div><div class="line">            test[i] = temp;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; test.length; i++) &#123;</div><div class="line">            System.out.print(test[i]+&quot;,&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java8-行为参数传递代码]]></title>
      <url>/2017/04/22/java8-%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%BB%A3%E7%A0%81/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[handler和messsage]]></title>
      <url>/2017/04/19/handler%E5%92%8Cmesssage/</url>
      <content type="html"><![CDATA[<h3 id="handler和message的原理"><a href="#handler和message的原理" class="headerlink" title="handler和message的原理"></a>handler和message的原理</h3><p>这里总结一下handler和message的原理和需要注意的一些问题！</p>
<ul>
<li><p>首先安卓的主线程是不安全的，我们的耗时操作需要在子线程运行</p>
<p>​</p>
</li>
</ul>
<p>于是产生了handler和message</p>
<p>这里需要记一下 handler的创建是不能再子线程的，除非在子线程创建之前调用了</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Looper.prepare();</div></pre></td></tr></table></figure>
<p>其实到这里就应该明白了，我们的主线程，app启动的时候在activitythread里就已经初始化了一个</p>
<p> Looper.prepareMainLooper(); </p>
<p>因为activity要执行attach ，而attach则会初始化这些东西。似的looper处于无限循环等待的状态中</p>
<p>一个线程只能创建一个looper，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static final void prepare() &#123;  </div><div class="line">    if (sThreadLocal.get() != null) &#123;  </div><div class="line">        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);  </div><div class="line">    &#125;  </div><div class="line">    sThreadLocal.set(new Looper());  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从源码可以看出 如果线程不为空的话会抛出这个异常。</p>
<p>然而我们的message是如何通过handler把自己消息传送到handlerMessage的方法中的呢？</p>
<p>这就涉及到了sendMessageAtTime（）的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis)  </div><div class="line">&#123;  </div><div class="line">    boolean sent = false;  </div><div class="line">    MessageQueue queue = mQueue;  </div><div class="line">    if (queue != null) &#123;  </div><div class="line">        msg.target = this;  </div><div class="line">        sent = queue.enqueueMessage(msg, uptimeMillis);  </div><div class="line">    &#125;  </div><div class="line">    else &#123;  </div><div class="line">        RuntimeException e = new RuntimeException(  </div><div class="line">            this + &quot; sendMessageAtTime() called with no mQueue&quot;);  </div><div class="line">        Log.w(&quot;Looper&quot;, e.getMessage(), e);  </div><div class="line">    &#125;  </div><div class="line">    return sent;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个message对象和时间，时间表示发送消息的时间，若不是sendMessageDelayed 则时间为0，立即发送，然后将msg发送到MessageQueue的enqueueMessage方法中，他是一个消息队列，这个方法实在looper的构造函数中创建的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">final boolean enqueueMessage(Message msg, long when) &#123;  </div><div class="line">    if (msg.when != 0) &#123;  </div><div class="line">        throw new AndroidRuntimeException(msg + &quot; This message is already in use.&quot;);  </div><div class="line">    &#125;  </div><div class="line">    if (msg.target == null &amp;&amp; !mQuitAllowed) &#123;  </div><div class="line">        throw new RuntimeException(&quot;Main thread not allowed to quit&quot;);  </div><div class="line">    &#125;  </div><div class="line">    synchronized (this) &#123;  </div><div class="line">        if (mQuiting) &#123;  </div><div class="line">            RuntimeException e = new RuntimeException(msg.target + &quot; sending message to a Handler on a dead thread&quot;);  </div><div class="line">            Log.w(&quot;MessageQueue&quot;, e.getMessage(), e);  </div><div class="line">            return false;  </div><div class="line">        &#125; else if (msg.target == null) &#123;  </div><div class="line">            mQuiting = true;  </div><div class="line">        &#125;  </div><div class="line">        msg.when = when;  </div><div class="line">        Message p = mMessages;  </div><div class="line">        if (p == null || when == 0 || when &lt; p.when) &#123;  </div><div class="line">            msg.next = p;  </div><div class="line">            mMessages = msg;  </div><div class="line">            this.notify();  </div><div class="line">        &#125; else &#123;  </div><div class="line">            Message prev = null;  </div><div class="line">            while (p != null &amp;&amp; p.when &lt;= when) &#123;  </div><div class="line">                prev = p;  </div><div class="line">                p = p.next;  </div><div class="line">            &#125;  </div><div class="line">            msg.next = prev.next;  </div><div class="line">            prev.next = msg;  </div><div class="line">            this.notify();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    return true;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在  msg.when = when;   开始如果当前处理的消息为空或者时间为0.或者时间小于当前待处理消息的时间，则把当前的消息插入队列，如果时间为零的话，则把这个mMessage赋值为新的msg，然后这个msg的next指向刚才的message，这样就把消息插在头部了</p>
<h3 id="消息的出队"><a href="#消息的出队" class="headerlink" title="消息的出队"></a>消息的出队</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public static final void loop() &#123;  </div><div class="line">    Looper me = myLooper();  </div><div class="line">    MessageQueue queue = me.mQueue;  </div><div class="line">    while (true) &#123;  </div><div class="line">        Message msg = queue.next(); // might block  </div><div class="line">        if (msg != null) &#123;  </div><div class="line">            if (msg.target == null) &#123;  </div><div class="line">                return;  </div><div class="line">            &#125;  </div><div class="line">            if (me.mLogging!= null) me.mLogging.println(  </div><div class="line">                    &quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot;  </div><div class="line">                    + msg.callback + &quot;: &quot; + msg.what  </div><div class="line">                    );  </div><div class="line">            msg.target.dispatchMessage(msg);  </div><div class="line">            if (me.mLogging!= null) me.mLogging.println(  </div><div class="line">                    &quot;&lt;&lt;&lt;&lt;&lt; Finished to    &quot; + msg.target + &quot; &quot;  </div><div class="line">                    + msg.callback);  </div><div class="line">            msg.recycle();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个死循环，它的简单逻辑就是如果当前MessageQueue中存在mMessages(即待处理消息)，就将这个消息出队，然后让下一条消息成为mMessages，否则就进入一个阻塞状态，一直等到有新的消息入队， msg.target.dispatchMessage(msg);   注意这个方法的dispatchMessage，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public void dispatchMessage(Message msg) &#123;  </div><div class="line">    if (msg.callback != null) &#123;  </div><div class="line">        handleCallback(msg);  </div><div class="line">    &#125; else &#123;  </div><div class="line">        if (mCallback != null) &#123;  </div><div class="line">            if (mCallback.handleMessage(msg)) &#123;  </div><div class="line">                return;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        handleMessage(msg);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个就是mCallback的调用然后handlerMessage。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">另外除了发送消息之外，我们还有以下几种方法可以在子线程中进行UI操作：</div><div class="line"></div><div class="line">1. Handler的post()方法</div><div class="line">2. View的post()方法</div><div class="line">3. Activity的runOnUiThread()方法</div></pre></td></tr></table></figure>
<p>handler的post方法其实就是把runnable传入callback中然后再主线程中 调用run方法</p>
<p>view的post是直接调用handler的post方法</p>
<p>Activity的runOnUiThread()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public final void runOnUiThread(Runnable action) &#123;  </div><div class="line">    if (Thread.currentThread() != mUiThread) &#123;  </div><div class="line">        mHandler.post(action);  </div><div class="line">    &#125; else &#123;  </div><div class="line">        action.run();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果当前的线程不是主线程的话则会自动调用handler的post方法</p>
<p>实际可以这么理解</p>
<ul>
<li><p>Message 意为消息，发送到Handler进行处理的对象，携带描述信息和任意数据。</p>
</li>
<li><p>MessageQueue 意为消息队列，Message的集合。</p>
</li>
<li><p>Looper 有着一个很难听的中文名字，消息泵，用来从MessageQueue中抽取Message，发送给Handler进行处理。</p>
</li>
<li><p>Handler 处理Looper抽取出来的Message。</p>
<p>（抄来的，很好理解）</p>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[bitmap上写字]]></title>
      <url>/2017/04/17/bitmap%E4%B8%8A%E5%86%99%E5%AD%97/</url>
      <content type="html"><![CDATA[<h3 id="网易云的锁屏歌词是如何实现的？？"><a href="#网易云的锁屏歌词是如何实现的？？" class="headerlink" title="网易云的锁屏歌词是如何实现的？？"></a>网易云的锁屏歌词是如何实现的？？</h3><p>学长突然问了我这个问题，是啊，怎麼实现的呢？貌似google并没有给我们这个接口，可是这些巨头却实现了，考虑了半天，也百度 google了一会，最后才知道 这些歌词是通过bitmap的实时渲染文字更新呢，可是这又有个问题，如果使用bitmap的话，那么多图片肯定会内存爆炸的！ 所以这里用到了个软引用（我觉得弱引用也可以）</p>
<p>所以话不过说，开写！</p>
<p>界面非常简单就一个按钮和图片</p>
<p>可是我们要实现歌词的实时变换，怎麼实现呢。。我这就简化了下，用了个定时气 timer；</p>
<p>没个3秒钟就会自己自动渲染。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">imageView = (ImageView) findViewById(R.id.img);</div><div class="line">button = (Button) findViewById(R.id.button);</div><div class="line">button.setOnClickListener(this);</div><div class="line">list = new ArrayList&lt;&gt;();</div><div class="line">list.add(&quot;陪你把沿路感想活出了答案&quot;);</div><div class="line">list.add(&quot;陪你把独自孤单变成了勇敢&quot;);</div><div class="line">list.add(&quot;一次次失去又重来 我没离开&quot;);</div><div class="line">list.add(&quot;陪伴是 最长情的告白&quot;);</div><div class="line">list.add(&quot;陪你把想念的酸 拥抱成温暖&quot;);</div><div class="line">list.add(&quot;未来多漫长 再漫长 还有期待&quot;);</div><div class="line">list.add(&quot;陪伴你 一直到 故事给说完&quot;);</div></pre></td></tr></table></figure>
<p>list 就是歌词了，这里简化了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   public void onClick(View v) &#123;</div><div class="line">       final Timer timer = new Timer();</div><div class="line"></div><div class="line">       final Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.ic_b33);</div><div class="line">       timer.schedule(new TimerTask() &#123;</div><div class="line">           int i = 0;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           public void run() &#123;</div><div class="line"></div><div class="line">               i++;</div><div class="line">               if (i == list.size()) &#123;</div><div class="line">                   //timer.cancel();</div><div class="line">                   i=0;</div><div class="line"></div><div class="line">               &#125;</div><div class="line">                   Message message = new Message();</div><div class="line">                   message.obj = getNewBitMap(list.get(i), bitmap,i);</div><div class="line">                   handler.sendMessage(message);</div><div class="line"></div><div class="line"></div><div class="line">           &#125;</div><div class="line">       &#125;, 200, 3000);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>这是点击事件</p>
<p>这是 渲染图片的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public Bitmap getNewBitMap(String text, Bitmap bitmap,int i) &#123;</div><div class="line">        if (mImageCache.containsKey(i))&#123;</div><div class="line">            if (mImageCache.get(i).get()!=null)&#123;</div><div class="line">                Log.d(&quot;===&quot;,&quot;return&quot;);</div><div class="line"></div><div class="line">                return mImageCache.get(i).get();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        WindowManager windowManager=getWindowManager();</div><div class="line">        Bitmap newBitmap = Bitmap.createBitmap(windowManager.getDefaultDisplay().getWidth(),windowManager.getDefaultDisplay().getHeight(), Bitmap.Config.ARGB_4444);</div><div class="line"></div><div class="line">        Canvas canvas = new Canvas(newBitmap);</div><div class="line">        canvas.drawBitmap(bitmap, 0, 0, null);</div><div class="line">        TextPaint textPaint = new TextPaint();</div><div class="line">        textPaint.setAntiAlias(true);</div><div class="line">        textPaint.setTextSize(160F);</div><div class="line">        StaticLayout sl = new StaticLayout(text, textPaint, newBitmap.getWidth(), Layout.Alignment.ALIGN_CENTER, 1.0f, 0.0f, false);</div><div class="line">        canvas.translate(6, 40);</div><div class="line">        sl.draw(canvas);</div><div class="line">        mImageCache.put(i,new SoftReference&lt;Bitmap&gt;(newBitmap));</div><div class="line">        return newBitmap;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>还有通过hander 更新画面 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Handler handler = new Handler() &#123;</div><div class="line"></div><div class="line">     @Override</div><div class="line">     public void handleMessage(Message msg) &#123;</div><div class="line">         Bitmap bitmap = (Bitmap) msg.obj;</div><div class="line">         imageView.setImageBitmap(bitmap);</div><div class="line">         super.handleMessage(msg);</div><div class="line">     &#125;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<p>这里的图片方法就比较好理解了，首先new一个新的bitmap对象，它代表新的要加载的bitmap，它是用来加载原来的bitmap和文字的，然后文字卸载上面，填到map中，如果他因为内存原因被回收了，则重新渲染这个图片。。非常好理解！</p>
<p><a href="http://i4.buimg.com/567571/a15846a46351cfc0.jpg" target="_blank" rel="external">http://i4.buimg.com/567571/a15846a46351cfc0.jpg</a></p>
<p><a href="http://i4.buimg.com/567571/e0299fd22afae178.jpg" target="_blank" rel="external">http://i4.buimg.com/567571/e0299fd22afae178.jpg</a></p>
<p><img src="" alt="http://i4.buimg.com/567571/01a2a9f612e3a88f.jpg"></p>
]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[svg]]></title>
      <url>/2017/04/12/svg/</url>
      <content type="html"><![CDATA[<h3 id="SVG-意为可缩放矢量图形（Scalable-Vector-Graphics），是使用-XML-来描述二维图形和绘图程序的语言；"><a href="#SVG-意为可缩放矢量图形（Scalable-Vector-Graphics），是使用-XML-来描述二维图形和绘图程序的语言；" class="headerlink" title="SVG 意为可缩放矢量图形（Scalable Vector Graphics），是使用 XML 来描述二维图形和绘图程序的语言；"></a>SVG 意为可缩放矢量图形（Scalable Vector Graphics），是使用 XML 来描述二维图形和绘图程序的语言；</h3><p>使用 SVG 的优势在于：</p>
<p>1.SVG 可被非常多的工具读取和修改（比如记事本）,由于使用xml格式定义，所以可以直接被当作文本文件打开，看里面的数据；</p>
<p>2.SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强，SVG 图就相当于保存了关键的数据点，比如要显示一个圆，需要知道圆心和半径，那么SVG 就只保存圆心坐标和半径数据，而平常我们用的位图都是以像素点的形式根据图片大小保存对应个数的像素点，因而SVG尺寸更小；</p>
<p>3.SVG 是可伸缩的，平常使用的位图拉伸会发虚，压缩会变形，而SVG格式图片保存数据进行运算展示，不管多大多少，可以不失真显示；</p>
<p>4.SVG 图像可在任何的分辨率下被高质量地打印;</p>
<p>5.SVG 可在图像质量不下降的情况下被放大;</p>
<p>6.SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图）;</p>
<p>7.SVG 可以与 <a href="http://lib.csdn.net/base/javase" target="_blank" rel="external">Java</a> 技术一起运行;</p>
<p>8.SVG 是开放的标准;</p>
<p>9.SVG 文件是纯粹的 XML;</p>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">M = moveto   相当于 android Path 里的moveTo(),用于移动起始点  </div><div class="line">L = lineto   相当于 android Path 里的lineTo()，用于画线  </div><div class="line">H = horizontal lineto     用于画水平线  </div><div class="line">V = vertical lineto       用于画竖直线  </div><div class="line">C = curveto               相当于cubicTo(),三次贝塞尔曲线  </div><div class="line">S = smooth curveto        同样三次贝塞尔曲线，更平滑  </div><div class="line">Q = quadratic Belzier curve             quadTo()，二次贝塞尔曲线  </div><div class="line">T = smooth quadratic Belzier curveto    同样二次贝塞尔曲线，更平滑  </div><div class="line">A = elliptical Arc   相当于arcTo()，用于画弧  </div><div class="line">Z = closepath     相当于closeTo(),关闭path</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> svg </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[算法基础]]></title>
      <url>/2017/04/10/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[searchview]]></title>
      <url>/2017/04/10/searchview/</url>
      <content type="html"><![CDATA[<h3 id="toolbar"><a href="#toolbar" class="headerlink" title="toolbar"></a>toolbar</h3><p> toolbar自带的搜索框其实非常实用</p>
<p>首先就是穿件menu的菜单！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   public boolean onCreateOptionsMenu(Menu menu) &#123;</div><div class="line"></div><div class="line">       getMenuInflater().inflate(R.menu.search, menu);</div><div class="line">       SearchManager searchManager =</div><div class="line">               (SearchManager) getSystemService(Context.SEARCH_SERVICE);</div><div class="line">       searchView =</div><div class="line">               (SearchView) menu.findItem(R.id.ab_search).getActionView();</div><div class="line">       searchView.setSearchableInfo(</div><div class="line">               searchManager.getSearchableInfo(getComponentName()));</div><div class="line">       searchView.setOnQueryTextListener(this);</div><div class="line">       return true;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="search-xml-menu"><a href="#search-xml-menu" class="headerlink" title="search.xml (menu)"></a>search.xml (menu)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</div><div class="line">    android:layout_width=&quot;match_parent&quot;</div><div class="line">    android:layout_height=&quot;match_parent&quot;&gt;</div><div class="line"></div><div class="line">    &lt;item</div><div class="line">        android:id=&quot;@+id/ab_search&quot;</div><div class="line">        android:orderInCategory=&quot;60&quot;</div><div class="line">        android:title=&quot;action_search&quot;</div><div class="line">        app:actionViewClass=&quot;android.support.v7.widget.SearchView&quot;</div><div class="line">        app:showAsAction=&quot;ifRoom&quot;/&gt;</div><div class="line"></div><div class="line">&lt;/menu&gt;</div></pre></td></tr></table></figure>
<h3 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;searchable xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</div><div class="line">    android:label=&quot;@string/app_name&quot;</div><div class="line">    android:imeOptions=&quot;actionSearch&quot;</div><div class="line">    android:hint=&quot;搜索&quot; /&gt;</div></pre></td></tr></table></figure>
<p>上面这三行代码就是为了创建菜单而实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">searchView.setOnQueryTextListener(this);</div><div class="line">实现setOnQueryTextListener接口判断数据的变化</div></pre></td></tr></table></figure>
<h3 id="和listview或者recycleview实现实时数据的搜索！"><a href="#和listview或者recycleview实现实时数据的搜索！" class="headerlink" title="和listview或者recycleview实现实时数据的搜索！"></a>和listview或者recycleview实现实时数据的搜索！</h3><p>这个刚开始觉得挺难的，试着写了一下，其实还可以！</p>
<p>这需要adapter实现 filter的接口</p>
<p>重写 publishResults 和performFiltering方法！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   public Filter getFilter() &#123;</div><div class="line"></div><div class="line">       return new Filter() &#123;</div><div class="line">           @Override</div><div class="line">           protected FilterResults performFiltering(CharSequence constraint) &#123;</div><div class="line">               FilterResults results = new FilterResults();</div><div class="line">               List&lt;Map&lt;String, String&gt;&gt; datalist = new ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">               for (int i = 0; i &lt; mlist.size(); i++) &#123;</div><div class="line">                   if (mlist.get(i).get(&quot;title&quot;).contains(constraint)) &#123;</div><div class="line">                       datalist.add(mlist.get(i));</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">               results.values = datalist;</div><div class="line">               return results;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           @Override</div><div class="line">           protected void publishResults(CharSequence constraint, FilterResults results) &#123;</div><div class="line"></div><div class="line">               list=((List&lt;Map&lt;String, String&gt;&gt;) results.values);</div><div class="line">               notifyDataSetChanged();</div><div class="line"></div><div class="line">           &#125;</div><div class="line">       &#125;;</div></pre></td></tr></table></figure>
<p>这里需要注意一下！因为你的数据实在实时刷新的，所以一旦回删数据的时候会导致数据恢复不了，所以初始化数据的时候一定要注意初始化一个 mdatalist 用来存放所有的数据，list用来实时更新加载数据！</p>
]]></content>
      
        
        <tags>
            
            <tag> toolbar的搜索框 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Android头像缓存]]></title>
      <url>/2017/04/08/Android%E5%A4%B4%E5%83%8F%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<h3 id="其实没那么难！"><a href="#其实没那么难！" class="headerlink" title="其实没那么难！"></a>其实没那么难！</h3><p>之前一直抵触写这些东西，而且很多都是直接百度的，根本没有去想怎么回事。这不，今天下午有遇到这些问题了，无奈找了个网上的例子，看似很简单，可是使用中却发现根本不是那回事！</p>
<p>当我们遇到listview 或者recycleview加载图片或者头像的时候 如果直接在getview的方法里面写一个异步的方法来加载图片的话写起来是简单，但是这样会导致item每次被重绘的时候都会去执行这个异步任务！导致app变卡，以及耗费流量等等有损用户体验的事情！</p>
<p>于是今天下午自己逼着自己写了一个！才发现其实根本没有那么难。。。</p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>其实就是每次加载的时候去你的本地文件夹判断是否有这个图片，如果有就直接加载，如果没有就去网络获取加载，在保存到本地！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">String path=context.getExternalFilesDir(Environment.DIRECTORY_PICTURES).getPath();</div><div class="line">       imageView.setBackgroundResource(R.drawable.ic_img_load);</div><div class="line">       final File file = new File(path + &quot;/iv2ex&quot;);</div><div class="line">       String u = url.replace(&quot;/&quot;, &quot;!&quot;);</div><div class="line">       u = u.replace(&quot;.&quot;, &quot;!&quot;);</div><div class="line">       if (!file.exists()) &#123;</div><div class="line">           file.mkdirs();</div><div class="line">       &#125;</div><div class="line">       final File f = new File(file, u );</div></pre></td></tr></table></figure>
<p>这是文件夹的判断，如果没有父类文件夹直接创建！，然后记得吧图片的地址给转义下里面的“ /”不然会导致找不到文件。然后如果文件存在直接加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if (f.exists()) &#123;</div><div class="line">            try &#123;</div><div class="line">                FileInputStream fos = new FileInputStream(f);</div><div class="line">                Bitmap bitmap = BitmapFactory.decodeStream(fos);</div><div class="line">                Drawable drawable = new BitmapDrawable(bitmap);</div><div class="line">                imageView.setImageDrawable(drawable);</div><div class="line">            &#125; catch (FileNotFoundException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">                imageView.setBackgroundResource(R.drawable.ic_person_outline_black_24dp);</div><div class="line">            &#125;</div></pre></td></tr></table></figure>
<p>如果文件不存在！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">URL picUrl = null;</div><div class="line">                  try &#123;</div><div class="line">                      picUrl = new URL(url);</div><div class="line"></div><div class="line">                      Bitmap bitmap = BitmapFactory.decodeStream(picUrl.openStream());</div><div class="line">                      OutputStream os = new FileOutputStream(f);</div><div class="line">                      bitmap.compress(Bitmap.CompressFormat.JPEG, 100, os);</div><div class="line">                      os.flush();</div><div class="line">                      os.close();</div><div class="line">                      subscriber.onNext(bitmap);</div><div class="line">                      subscriber.onCompleted();</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Drawable drable = new BitmapDrawable(bitmap);</div><div class="line">                          imageView.setImageDrawable(drable);</div></pre></td></tr></table></figure>
<p>我的异步任务是用rxjava写的。。很方便链式的。。 到这里就结束了，其实真的很简单，之前总是把事情想的非常复杂。。</p>
]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[系统分享]]></title>
      <url>/2017/04/04/%E7%B3%BB%E7%BB%9F%E5%88%86%E4%BA%AB/</url>
      <content type="html"><![CDATA[<h3 id="系统分享"><a href="#系统分享" class="headerlink" title="系统分享"></a>系统分享</h3><p>Android手机调用系统分享是个很常见的事情，所以今天来总结下分享的功能。</p>
<p>当分享单个文本的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Intent shareIntent = new Intent();</div><div class="line">      shareIntent.setAction(Intent.ACTION_SEND);</div><div class="line">      shareIntent.putExtra(Intent.EXTRA_TEXT, &quot;你要分享的文本&quot;);</div><div class="line">      shareIntent.setType(&quot;text/plain&quot;);</div><div class="line"> </div><div class="line">      //设置分享列表的标题，并且每次都显示分享列表</div><div class="line">      startActivity(Intent.createChooser(shareIntent, &quot;分享到&quot;));//分享的标题</div></pre></td></tr></table></figure>
<p>分享单个照片的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">String imagePath =&quot;-------------&quot;</div><div class="line">//由文件得到uri</div><div class="line">Uri imageUri = Uri.fromFile(new File(imagePath));</div><div class="line">Log.d(&quot;share&quot;, &quot;uri:&quot; + imageUri);  //输出：</div><div class="line"></div><div class="line">Intent shareIntent = new Intent();</div><div class="line">shareIntent.setAction(Intent.ACTION_SEND);</div><div class="line">shareIntent.putExtra(Intent.EXTRA_STREAM, imageUri);</div><div class="line">shareIntent.setType(&quot;image/*&quot;);</div><div class="line">startActivity(Intent.createChooser(shareIntent, &quot;分享到&quot;));</div></pre></td></tr></table></figure>
<p>分享多个照片的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;uri&gt; uriList = new ArrayList&lt;&gt;();</div><div class="line">String path = Environment.getExternalStorageDirectory() + File.separator;</div><div class="line">uriList.add(Uri.fromFile(new File(path+&quot;1.jpg&quot;)));</div><div class="line">uriList.add(Uri.fromFile(new File(path+&quot;2.jpg&quot;)));</div><div class="line">uriList.add(Uri.fromFile(new File(path+&quot;3.jpg&quot;)));</div><div class="line"></div><div class="line">Intent shareIntent = new Intent();</div><div class="line">shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE);</div><div class="line">shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, uriList);</div><div class="line">shareIntent.setType(&quot;image/*&quot;);</div><div class="line">startActivity(Intent.createChooser(shareIntent, &quot;分享到&quot;));</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安卓图库那些事]]></title>
      <url>/2017/04/04/%E5%AE%89%E5%8D%93%E5%9B%BE%E5%BA%93%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      <content type="html"><![CDATA[<h3 id="相机的调用"><a href="#相机的调用" class="headerlink" title="相机的调用"></a>相机的调用</h3><p>调用Intent的参数<code>MediaStore.ACTION_IMAGE_CAPTURE</code>实现 然后在<code>startActivityForResult</code>方法实现返回的数据。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Intent intent = </div><div class="line">new Intent(MediaStore.ACTION_IMAGE_CAPTURE);</div><div class="line">//存放相机返回的图片</div><div class="line">File file = new File(filePath);</div><div class="line">if(file.exists())&#123;file.delete()&#125;</div><div class="line">Uri uri = Uri.fromFile(file);</div><div class="line">intent.putExtra(MediaStore.EXTRA_OUTPUT,uri);</div><div class="line">startActivityForResult(intent1,TAKE_PHOTO);</div></pre></td></tr></table></figure>
<h3 id="调用图库"><a href="#调用图库" class="headerlink" title="调用图库"></a>调用图库</h3><p>Intent的Action参数<code>Intent.ACTION_GET_CONTENT</code> 实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent(Intent.ACTION_GET_CONTENT);</div><div class="line">//选择图片格式</div><div class="line">intent.setType(&quot;image/*&quot;);</div><div class="line">intent.putExtra(&quot;return-data&quot;,true);</div><div class="line">startActivityForResult(intent,1);</div></pre></td></tr></table></figure>
<p>这里在startActivityForResult 返回的是一个图片的uri；</p>
<h3 id="调用系统的照片剪裁功能"><a href="#调用系统的照片剪裁功能" class="headerlink" title="调用系统的照片剪裁功能"></a>调用系统的照片剪裁功能</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;);</div><div class="line">             intent.setDataAndType(uri, &quot;image/*&quot;);</div><div class="line">             intent.putExtra(&quot;crop&quot;, &quot;true&quot;);</div><div class="line">             intent.putExtra(&quot;aspectX&quot;, background.getWidth());//图片的关高比</div><div class="line">             intent.putExtra(&quot;aspectY&quot;, background.getHeight());</div><div class="line">             intent.putExtra(&quot;outputX&quot;, 500);</div><div class="line">             intent.putExtra(&quot;outputY&quot;, 500);//图片的宽高</div><div class="line">             intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG);输出的图片格式</div><div class="line">             intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(file));输出的图片位置</div><div class="line">             intent.putExtra(&quot;return-data&quot;, false);是否有返回值？</div><div class="line">             startActivityForResult(intent, 3);</div></pre></td></tr></table></figure>
<p>这里要注意系统剪裁完的图片会返回一个缩略图，具体为啥会这样因为内存原因，如果内存太大了的话在内存间传递会导致oom，我也是搞了好久才发现，所以不要返回值，直接记住他的uri，然后再回调方法里面去找到图片在进行其他处理。</p>
<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>如果存放照片的值出现filenotfound的异常的时候注意看看文件夹的父文件夹是否存在，最好用file.mkdirs()方法。</p>
]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[发布了人生第一款应用]]></title>
      <url>/2017/03/30/%E5%8F%91%E5%B8%83%E4%BA%86%E4%BA%BA%E7%94%9F%E7%AC%AC%E4%B8%80%E6%AC%BE%E5%BA%94%E7%94%A8/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[downloadmangager的使用]]></title>
      <url>/2017/03/29/downloadmangager%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h4 id="downloadmangager"><a href="#downloadmangager" class="headerlink" title="downloadmangager"></a>downloadmangager</h4><p>这是一个Android 2.3自带的一个下载api，它非常的方便，自动帮你写好了下载，暂停，和下载失败等等需要我们自己写的东西。</p>
<h4 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h4><ul>
<li><p>调用downloadmanger的requset方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DownloadManager.Request request = new DownloadManager.Request (Uri.parse(&quot;http://7xstld.com1.z0.glb.clouddn.com/kechengbiao.apk&quot;));</div><div class="line">// 字符串网址</div></pre></td></tr></table></figure>
</li>
<li><p>request方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setAllowedNetworkTypes\\设置允许下载的网络类型</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setNotificationVisibility \\设置下载在下拉菜单是否可见 (DownloadManager.Request.VISIBILITY_VISIBLE)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setTitle  设置标题</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setDescription 设置描述</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setAllowedOverRoaming   设置是否可以被移除</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setDestinationInExternalFilesDir 设置下载地址 因人而异</div><div class="line"></div><div class="line">(SettingActivity.this, Environment.DIRECTORY_DOWNLOADS, &quot;kbdown&quot;)；</div></pre></td></tr></table></figure>
</li>
<li><p>​</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DownloadManager downloadManager = (DownloadManager) getSystemService(DOWNLOAD_SERVICE);</div></pre></td></tr></table></figure>
</li>
<li><p>enqueue</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">long id = downloadManager.enqueue(request);</div><div class="line">// 返回一个id ，可以用这个id来查询下载信息</div></pre></td></tr></table></figure>
<p>下载成功后会发出一个<strong>DownloadManager.ACTION_DOWNLOAD_COMPLETE</strong>这个广播并传递downloadId作为参数。通过接受广播我们可以打开对下载完成的内容进行操作</p>
</li>
<li><p>取消删除下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">downloadManager.remove(REFERENCE_1, REFERENCE_2, REFERENCE_3);</div></pre></td></tr></table></figure>
</li>
<li><p>查询状态</p>
<p>你可以通过查询Download Manager来获得下载任务的状态，进度，以及各种细节，通过query方法返回一个包含了下载任务细节的Cursor。</p>
<p>query方法传递一个DownloadManager.Query对象作为参数，通过DownloadManager.Query对象的setFilterById方法可以筛选我们希望查询的下</p>
<p>载任务的ID。也可以使用setFilterByStatus方法筛选我们希望查询的某一种状态的下载任务，传递的参数是DownloadManager.STATUS_*常量，可以指定</p>
<p>正在进行、暂停、失败、完成四种状态。</p>
<p>Download Manager包含了一系列COLUMN_*静态String常量，可以用来查询Cursor中的结果列索引。我们可以查询到下载任务的各种细节，包括状态，</p>
<p>文件大小，已经下载的字节数，标题，描述，URI，本地文件名和URI，媒体类型以及Media Provider download URI</p>
<p> 对于暂停和失败的下载，我们可以通过查询COLUMN_REASON列查询出原因的整数码。对于STATUS<em>PAUSED状态的下载，可以通过DownloadManager.PAUSED</em><em>静态常量来翻译出原因的整数码，进而判断出下载是由于等待网络连接还是等待WiFi连接还是准备重新下载三种原因而暂停。对于STATUS<em>FAILED状态的下载，我们可以通过DownloadManager.ERROR</em></em>来判断失败的原因，可能是错误码（失败原因）包括没有存储设备，存储空间不足，重复的文件名，或者HTTP errors。</p>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RecyclerView的使用]]></title>
      <url>/2017/03/28/RecyclerView%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h4 id="之前写Android程序遇到列表显示都是使用listview，可能因为自己要写的东西比较简单吧，所以一直没去用recycleview。但是今天遇到了个让人恼火的事情，就是listview和CollapsingToolbarLayout不兼容，无法实现toolbar的折叠效果，即使外面裹上了一层NestedScrollView-还要自己去重写listview的方法，非常麻烦，而且貌似在Android5-0有bug？就是他的下面会溢出屏幕一个toolbar的高度，数据显示不全，于是今天去搞了下recyclevie"><a href="#之前写Android程序遇到列表显示都是使用listview，可能因为自己要写的东西比较简单吧，所以一直没去用recycleview。但是今天遇到了个让人恼火的事情，就是listview和CollapsingToolbarLayout不兼容，无法实现toolbar的折叠效果，即使外面裹上了一层NestedScrollView-还要自己去重写listview的方法，非常麻烦，而且貌似在Android5-0有bug？就是他的下面会溢出屏幕一个toolbar的高度，数据显示不全，于是今天去搞了下recyclevie" class="headerlink" title="之前写Android程序遇到列表显示都是使用listview，可能因为自己要写的东西比较简单吧，所以一直没去用recycleview。但是今天遇到了个让人恼火的事情，就是listview和CollapsingToolbarLayout不兼容，无法实现toolbar的折叠效果，即使外面裹上了一层NestedScrollView 还要自己去重写listview的方法，非常麻烦，而且貌似在Android5.0有bug？就是他的下面会溢出屏幕一个toolbar的高度，数据显示不全，于是今天去搞了下recyclevie"></a>之前写Android程序遇到列表显示都是使用listview，可能因为自己要写的东西比较简单吧，所以一直没去用recycleview。但是今天遇到了个让人恼火的事情，就是listview和CollapsingToolbarLayout不兼容，无法实现toolbar的折叠效果，即使外面裹上了一层NestedScrollView 还要自己去重写listview的方法，非常麻烦，而且貌似在Android5.0有bug？就是他的下面会溢出屏幕一个toolbar的高度，数据显示不全，于是今天去搞了下recyclevie</h4><h4 id="recycleview和listview的思想差不多。"><a href="#recycleview和listview的思想差不多。" class="headerlink" title="recycleview和listview的思想差不多。"></a>recycleview和listview的思想差不多。</h4><p>虽然他的实现方法和listview差不多，但是还是有很大不同的，而且recycleview比listview比起来优势更多，更适合自定义，而且性能也很好，因为recycleview是直接继承groupview的，减少了图像的一层层的绘制，而listview则继承listview的抽象类。</p>
<p>具体recycle 的实现方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">recyclerView= (RecyclerView) findViewById(R.id.Recycle);</div><div class="line">final LinearLayoutManager manager=new LinearLayoutManager(this);</div><div class="line">recyclerView.setLayoutManager(manager);</div><div class="line">recyclerView.setHasFixedSize(true);</div><div class="line">recyclerView.addItemDecoration(new SpacesItemDecoration(3));//给recycleview添加分割线，因为recycle没有自带类似listview的driver;</div></pre></td></tr></table></figure>
<h4 id="SpacesItemDecoration方法（下划线）"><a href="#SpacesItemDecoration方法（下划线）" class="headerlink" title="SpacesItemDecoration方法（下划线）"></a>SpacesItemDecoration方法（下划线）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class SpacesItemDecoration extends RecyclerView.ItemDecoration &#123;</div><div class="line">        private int space;</div><div class="line"></div><div class="line">        public SpacesItemDecoration(int space) &#123;</div><div class="line">            this.space = space;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void getItemOffsets(Rect outRect, View view,</div><div class="line">                                   RecyclerView parent, RecyclerView.State state) &#123;</div><div class="line">            outRect.left = space;</div><div class="line">            outRect.right = space;</div><div class="line">            outRect.bottom = space;</div><div class="line"></div><div class="line">            // Add top margin only for the first item to avoid double space between items</div><div class="line">            if (parent.getChildPosition(view) == 0)</div><div class="line">                outRect.top = space;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="recycleview的adapter"><a href="#recycleview的adapter" class="headerlink" title="recycleview的adapter"></a>recycleview的adapter</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">public class GradeRecyclerAdapter extends RecyclerView.Adapter&lt;GradeRecyclerAdapter.ViewHolder&gt; &#123;</div><div class="line">    private List&lt;Map&lt;String, String&gt;&gt; list;</div><div class="line">    private Activity activity;</div><div class="line">   //构造方法</div><div class="line">    public GradeRecyclerAdapter(List&lt;Map&lt;String, String&gt;&gt; list, Activity activity) &#123;</div><div class="line">        this.list = list;</div><div class="line">        this.activity = activity;</div><div class="line">    &#125;</div><div class="line">//viewholder</div><div class="line">    @Override</div><div class="line">    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</div><div class="line">        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_list_library, parent,false);</div><div class="line">        ViewHolder viewHolder = new ViewHolder(view);</div><div class="line"></div><div class="line">        return viewHolder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onBindViewHolder(ViewHolder holder,  int position) &#123;</div><div class="line">        holder.bookname.setText(list.get(position).get(&quot;name&quot;));</div><div class="line">        holder.place.setText(list.get(position).get(&quot;palce&quot;));</div><div class="line">        holder.writer.setText(list.get(position).get(&quot;writer&quot;));</div><div class="line">        holder.num.setText(list.get(position).get(&quot;num&quot;));</div><div class="line">        final  int a=position;</div><div class="line">        holder.more.setOnClickListener(new View.OnClickListener() &#123;</div><div class="line">            @Override</div><div class="line">            public void onClick(View v) &#123;</div><div class="line"></div><div class="line">                Intent intent = new Intent(activity, BookDetalActivity.class);</div><div class="line">                intent.putExtra(&quot;url&quot;, list.get(a).get(&quot;url&quot;));</div><div class="line">                activity.startActivity(intent);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int getItemCount() &#123;</div><div class="line">        return list.size();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static class ViewHolder extends RecyclerView.ViewHolder &#123;</div><div class="line">        TextView bookname;</div><div class="line">        TextView place;</div><div class="line">        TextView writer;</div><div class="line">        TextView num;</div><div class="line">        TextView more;</div><div class="line"></div><div class="line">        public ViewHolder(View itemView) &#123;</div><div class="line">            super(itemView);</div><div class="line">            bookname = (TextView) itemView.findViewById(R.id.bookname);</div><div class="line">            place = (TextView) itemView.findViewById(R.id.place);</div><div class="line">            writer = (TextView) itemView.findViewById(R.id.num);</div><div class="line">            num = (TextView) itemView.findViewById(R.id.writer);</div><div class="line">            more = (TextView) itemView.findViewById(R.id.moer);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上就是recycleview的简单实现啦，很简单。</p>
]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安卓学习路线]]></title>
      <url>/2017/03/28/%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      <content type="html"><![CDATA[<p>学了这么久安卓，忽然发现自己会的太少了，于是在ｖ２ｅｘ上求助，偶然发现好心人推荐的一个博客非常不错，里面总结了很多关于安卓学习用到的东西，今天在这跟大家分享下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://www.jianshu.com/p/af2de05aadff</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux环境下搭建hexo博客]]></title>
      <url>/2017/03/28/Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>之前一直用windows系统 ，直到前几天换了国产的linux系统deepin，发现这个系统真的不错！很漂亮尤其我这种做安卓开发的，用了deepin之后发现 as的打开速度快乐特别多。好了言归正传，我在这里讲一下如何在linux系统下搭建hexo个人博客。</p>
<h3 id="第一步：-安装git"><a href="#第一步：-安装git" class="headerlink" title="第一步： 安装git"></a>第一步： 安装git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install git</div></pre></td></tr></table></figure>
<h3 id="第二步：安装node-js"><a href="#第二步：安装node-js" class="headerlink" title="第二步：安装node.js"></a>第二步：安装node.js</h3><h4 id="之前上网google资料的时候走了好多弯路，网上很多人都说最好不用-apt-get的方法"><a href="#之前上网google资料的时候走了好多弯路，网上很多人都说最好不用-apt-get的方法" class="headerlink" title="之前上网google资料的时候走了好多弯路，网上很多人都说最好不用 apt-get的方法"></a>之前上网google资料的时候走了好多弯路，网上很多人都说最好不用 apt-get的方法</h4><h4 id="可是最后发现这个方法是最省力最方便的。"><a href="#可是最后发现这个方法是最省力最方便的。" class="headerlink" title="可是最后发现这个方法是最省力最方便的。"></a>可是最后发现这个方法是最省力最方便的。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install nodejs</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install npm</div></pre></td></tr></table></figure>
<p>直接运行以上两个命令，安装node.js 如果不好使把sudo去掉，或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo su 这时候让你输入密码然后在root用户下运行命令</div></pre></td></tr></table></figure>
<h4 id="如果直接安装的方法不管用了，别急还有另外两种方法"><a href="#如果直接安装的方法不管用了，别急还有另外两种方法" class="headerlink" title="如果直接安装的方法不管用了，别急还有另外两种方法"></a>如果直接安装的方法不管用了，别急还有另外两种方法</h4><p>去官网下载好node.js文件后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd node-***(你的node.js文件)/bin</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./node -v</div></pre></td></tr></table></figure>
<p>然后将node命令设置全局可用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　ln -s /home/tongyangmysofltware/node-v0.10.28-linux-x64/bin/node /usr/local/bin/node</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -s /home/tongyang/mysofltware/node-v0.10.28-linux-x64/bin/npm /usr/local/bin/npm</div></pre></td></tr></table></figure>
<p>这个目录根据个人情况而定</p>
<h3 id="第三步：hexo的安装"><a href="#第三步：hexo的安装" class="headerlink" title="第三步：hexo的安装"></a>第三步：hexo的安装</h3><p>node.js安装完成后我们就可以安装hexo了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-cli -g</div></pre></td></tr></table></figure>
<p>初始化hexo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo init</div></pre></td></tr></table></figure>
<p>安装依赖包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install</div></pre></td></tr></table></figure>
<p>生成静态页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo generate （可以简写成 hexo g）</div></pre></td></tr></table></figure>
<p>开启本地服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo server (同理简写成 hexo s)</div></pre></td></tr></table></figure>
<p>浏览器打开<a href="http://localhost:4000%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E8%87%AA%E5%B7%B1%E5%8D%9A%E5%AE%A2%E5%95%A6%EF%BC%8C%E4%B8%8D%E8%BF%87%E7%8E%B0%E5%9C%A8%E8%BF%98%E6%B2%A1%E6%9C%89%E5%92%8C%E8%87%AA%E5%B7%B1github%E5%85%B3%E8%81%94/" target="_blank" rel="external">http://localhost:4000就可以看到自己博客啦，不过现在还没有和自己github关联</a></p>
<h3 id="第四步：发布自己的博客到github上"><a href="#第四步：发布自己的博客到github上" class="headerlink" title="第四步：发布自己的博客到github上"></a>第四步：发布自己的博客到github上</h3><h4 id="1检查本地是否存在id"><a href="#1检查本地是否存在id" class="headerlink" title="1检查本地是否存在id"></a>1检查本地是否存在id</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">打开git bash，输入命令ls -al ~/.ssh。</div></pre></td></tr></table></figure>
<p>如果存在直接跳过</p>
<p>如果没有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;</div><div class="line"># Creates a new ssh key using the provided email # Generating public/private rsa key pair. </div><div class="line"></div><div class="line"># Enter file in which to save the key (/home/you/.ssh/id_rsa):</div></pre></td></tr></table></figure>
<p>直接Enter就行。然后，会提示你输入密码，如下(建议输一个，安全一点，当然不输也行)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Enter passphrase (empty for no passphrase): [Type a passphrase] </div><div class="line"># Enter same passphrase again: [Type passphrase again]</div></pre></td></tr></table></figure>
<p>完了之后，大概是这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Your identification has been saved in /home/you/.ssh/id_rsa. </div><div class="line"># Your public key has been saved in /home/you/.ssh/id_rsa.pub. </div><div class="line"># The key fingerprint is: # 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@youremail.com</div></pre></td></tr></table></figure>
<p>你的秘钥已经生成</p>
<p>知道.shh下面的id_rsa. 或者id_rsa.pub. 复制你的秘钥所有内容</p>
<p>登陆你的github帐户。然后 Account Settings -&gt; 左栏点击 SSH Keys -&gt; 点击 Add SSH key</p>
<p>然后你复制上面的公钥内容，粘贴进“Key”文本域内。 title域，你随便填一个都行。</p>
<p>完了，点击 Add key。</p>
<p>可以使用一下命令查看是否成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh -T git@github.com</div></pre></td></tr></table></figure>
<p>如果，看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hi username! You&apos;ve successfully authenticated, but GitHub does not # provide shell access.</div></pre></td></tr></table></figure>
<p>就表示你的设置已经成功了。</p>
<p>至于怎么在github上面生成自己博客页面我就不多说了，不会的百度吧，因为我想作为一个程序员，连基友交友平台都不知道怎么用，那就太尴尬了。</p>
<p>在hexo文件夹的的住配置文件里面拉到最下面修改成这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git  </div><div class="line">  repo: git@github.com:tongyangl/tongyangl.github.io.git  </div><div class="line">  branch: master</div></pre></td></tr></table></figure>
<p>记住这个 repo是你在github上面的地址！</p>
<p>最后直接在hexo页面执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo d</div></pre></td></tr></table></figure>
<p>大多数都会成功</p>
<p>如果还不成功提示未找到git也可以用一些麻烦的方法push自己的博客</p>
<p>新建一个文件夹blog</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone 你github的博客地址</div></pre></td></tr></table></figure>
<p>然后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo g</div><div class="line">hexo s</div></pre></td></tr></table></figure>
<p>删除blog的文件夹的内容</p>
<p>在hexo文件夹的public文件下的所有内容都复制到blog</p>
<p>然后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git add ×</div><div class="line">git commit -m 你的commit内容随便你写</div><div class="line">git push</div></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用序列化器生成xml文件]]></title>
      <url>/2016/11/15/%E5%88%A9%E7%94%A8%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E7%94%9F%E6%88%90xml%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">List&lt;Message&gt; smsList;</div><div class="line">        // 虚拟10条短信</div><div class="line">        smsList = new ArrayList&lt;Message&gt;();</div><div class="line">        for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">            Message sms = new Message(&quot;小志好棒&quot; + i, System.currentTimeMillis()</div><div class="line">                    + &quot;&quot;, &quot;138&quot; + i + i, &quot;1&quot;);</div><div class="line">            smsList.add(sms);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public void click(View v)&#123;</div><div class="line">        //使用xml序列化器生成xml文件</div><div class="line">        //1.拿到序列化器对象</div><div class="line">        XmlSerializer xs = Xml.newSerializer();</div><div class="line">        //2.初始化</div><div class="line">        File file = new File(&quot;sdcard/sms2.xml&quot;);</div><div class="line">        try &#123;</div><div class="line">            FileOutputStream fos = new FileOutputStream(file);</div><div class="line">            //enconding:指定用什么编码生成xml文件</div><div class="line">            xs.setOutput(fos, &quot;utf-8&quot;);</div><div class="line">             //3.开始生成xml文件</div><div class="line">            //enconding:指定头结点中的enconding属性的值</div><div class="line">            xs.startDocument(&quot;utf-8&quot;, true);</div><div class="line">            xs.startTag(null, &quot;message&quot;);</div><div class="line">            for (Message sms : smsList) &#123;</div><div class="line">                xs.startTag(null, &quot;sms&quot;);</div><div class="line"></div><div class="line">                xs.startTag(null, &quot;body&quot;);</div><div class="line">                xs.text(sms.getBody() + &quot;&lt;body&gt;&quot;);</div><div class="line">                xs.endTag(null, &quot;body&quot;);</div><div class="line">                xs.endTag(null, &quot;sms&quot;);</div><div class="line">            &#125;</div><div class="line">            xs.endTag(null, &quot;message&quot;);</div><div class="line">            //告诉序列化器，文件生成完毕</div><div class="line">            xs.endDocument();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            // TODO Auto-generated catch block</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; </div><div class="line">    &#125;</div><div class="line">================================================================</div><div class="line">================================================================</div><div class="line">================================================================</div><div class="line">package com.itheima.createxml.domain;</div><div class="line"></div><div class="line">public class Message &#123;</div><div class="line"></div><div class="line">    private String body;</div><div class="line">    private String date;</div><div class="line">    private String address;</div><div class="line">    private String type;</div><div class="line">    public String getBody() &#123;</div><div class="line">        return body;</div><div class="line">    &#125;</div><div class="line">    public void setBody(String body) &#123;</div><div class="line">        this.body = body;</div><div class="line">    &#125;</div><div class="line">    public String getDate() &#123;</div><div class="line">        return date;</div><div class="line">    &#125;</div><div class="line">    public void setDate(String date) &#123;</div><div class="line">        this.date = date;</div><div class="line">    &#125;</div><div class="line">    public String getAddress() &#123;</div><div class="line">        return address;</div><div class="line">    &#125;</div><div class="line">    public void setAddress(String address) &#123;</div><div class="line">        this.address = address;</div><div class="line">    &#125;</div><div class="line">    public String getType() &#123;</div><div class="line">        return type;</div><div class="line">    &#125;</div><div class="line">    public void setType(String type) &#123;</div><div class="line">        this.type = type;</div><div class="line">    &#125;</div><div class="line">    public Message(String body, String date, String address, String type) &#123;</div><div class="line">        super();</div><div class="line">        this.body = body;</div><div class="line">        this.date = date;</div><div class="line">        this.address = address;</div><div class="line">        this.type = type;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[测试类测试数据库并且进行增删改查]]></title>
      <url>/2016/10/28/%E6%B5%8B%E8%AF%95%E7%B1%BB%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E4%B8%94%E8%BF%9B%E8%A1%8C%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div></pre></td><td class="code"><pre><div class="line">public class TestCase extends AndroidTestCase &#123;</div><div class="line"></div><div class="line">    //此时测试框架还没有初始化完毕，没有虚拟上下文对象</div><div class="line"></div><div class="line">//    private MyOpenHelper oh = new MyOpenHelper(getContext(), &quot;people.db&quot;, null, 1);</div><div class="line"></div><div class="line">    private MyOpenHelper oh;</div><div class="line"></div><div class="line">    private SQLiteDatabase db;</div><div class="line"></div><div class="line">    public void test()&#123;</div><div class="line"></div><div class="line">        //getContext():获取一个虚拟的上下文</div><div class="line"></div><div class="line">        MyOpenHelper oh = new MyOpenHelper(getContext(), &quot;people.db&quot;, null, 1);</div><div class="line"></div><div class="line">        //如果数据库不存在，先创建数据库，再获取可读可写的数据库对象，如果数据库存在，就直接打开</div><div class="line"></div><div class="line">        SQLiteDatabase db = oh.getWritableDatabase();</div><div class="line"></div><div class="line">        //如果存储空间满了，那么返回只读数据库对象</div><div class="line"></div><div class="line">//        SQLiteDatabase db = oh.getReadableDatabase();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //测试框架初始化完毕之后，在测试方法执行之前，此方法调用</div><div class="line"></div><div class="line">    @Override</div><div class="line"></div><div class="line">    protected void setUp() throws Exception &#123;</div><div class="line"></div><div class="line">        super.setUp();</div><div class="line"></div><div class="line">        oh = new MyOpenHelper(getContext(), &quot;people.db&quot;, null, 1);</div><div class="line"></div><div class="line">        db = oh.getWritableDatabase();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //测试方法执行完毕之后，此方法调用</div><div class="line"></div><div class="line">    @Override</div><div class="line"></div><div class="line">    protected void tearDown() throws Exception &#123;</div><div class="line"></div><div class="line">        // TODO Auto-generated method stub</div><div class="line"></div><div class="line">        super.tearDown();</div><div class="line"></div><div class="line">        db.close();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void insert()&#123;</div><div class="line"></div><div class="line">//        db.execSQL(&quot;insert into person (name, salary, phone)values(?, ?, ?)&quot;, new Object[]&#123;&quot;小志的老婆[1]&quot;, &quot;13000&quot;, 138438&#125;);</div><div class="line"></div><div class="line">//        db.execSQL(&quot;insert into person (name, salary, phone)values(?, ?, ?)&quot;, new Object[]&#123;&quot;小志的儿子&quot;, 14000, &quot;13888&quot;&#125;);</div><div class="line"></div><div class="line">        db.execSQL(&quot;insert into person (name, salary, phone)values(?, ?, ?)&quot;, new Object[]&#123;&quot;小志&quot;, 14000, &quot;13888&quot;&#125;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void delete()&#123;</div><div class="line"></div><div class="line">        db.execSQL(&quot;delete from person where name = ?&quot;, new Object[]&#123;&quot;小志&quot;&#125;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void update()&#123;</div><div class="line"></div><div class="line">        db.execSQL(&quot;update person set phone = ? where name = ?&quot;, new Object[]&#123;186666, &quot;小志的儿子&quot;&#125;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void select()&#123;</div><div class="line"></div><div class="line">        Cursor cursor = db.rawQuery(&quot;select name, salary from person&quot;, null);</div><div class="line"></div><div class="line">        while(cursor.moveToNext())&#123;</div><div class="line"></div><div class="line">            //通过列索引获取列的值</div><div class="line"></div><div class="line">            String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;));</div><div class="line"></div><div class="line">            String salary = cursor.getString(1);</div><div class="line"></div><div class="line">            System.out.println(name + &quot;;&quot; + salary);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void insertApi()&#123;</div><div class="line"></div><div class="line">        //把要插入的数据全部封装至ContentValues对象</div><div class="line"></div><div class="line">        ContentValues values = new ContentValues();</div><div class="line"></div><div class="line">        values.put(&quot;name&quot;, &quot;游天龙&quot;);</div><div class="line"></div><div class="line">        values.put(&quot;phone&quot;, &quot;15999&quot;);</div><div class="line"></div><div class="line">        values.put(&quot;salary&quot;, 16000);</div><div class="line"></div><div class="line">        db.insert(&quot;person&quot;, null, values);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void deleteApi()&#123;</div><div class="line"></div><div class="line">        int i = db.delete(&quot;person&quot;, &quot;name = ? and _id = ?&quot;, new String[]&#123;&quot;小志的儿子&quot;, &quot;3&quot;&#125;);</div><div class="line"></div><div class="line">        System.out.println(i);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void updateApi()&#123;</div><div class="line"></div><div class="line">        ContentValues values = new ContentValues();</div><div class="line"></div><div class="line">        values.put(&quot;salary&quot;, 26000);</div><div class="line"></div><div class="line">        int i = db.update(&quot;person&quot;, values, &quot;name = ?&quot;, new String[]&#123;&quot;游天龙&quot;&#125;);</div><div class="line"></div><div class="line">        System.out.println(i);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void selectApi()&#123;</div><div class="line"></div><div class="line">        Cursor cursor = db.query(&quot;person&quot;, null, null, null, null, null, null, null);</div><div class="line"></div><div class="line">        while(cursor.moveToNext())&#123;</div><div class="line"></div><div class="line">            String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;));</div><div class="line"></div><div class="line">            String phone = cursor.getString(cursor.getColumnIndex(&quot;phone&quot;));</div><div class="line"></div><div class="line">            String salary = cursor.getString(cursor.getColumnIndex(&quot;salary&quot;));</div><div class="line"></div><div class="line">            System.out.println(name + &quot;;&quot; + phone + &quot;;&quot; + salary);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void transaction()&#123;</div><div class="line"></div><div class="line">        try&#123;</div><div class="line"></div><div class="line">            //开启事务</div><div class="line"></div><div class="line">            db.beginTransaction();</div><div class="line"></div><div class="line">            ContentValues values = new ContentValues();</div><div class="line"></div><div class="line">            values.put(&quot;salary&quot;, 12000);</div><div class="line"></div><div class="line">            db.update(&quot;person&quot;, values, &quot;name = ?&quot;, new String[]&#123;&quot;小志&quot;&#125;);</div><div class="line"></div><div class="line">            values.clear();</div><div class="line"></div><div class="line">            values.put(&quot;salary&quot;, 16000);</div><div class="line"></div><div class="line">            db.update(&quot;person&quot;, values, &quot;name = ?&quot;, new String[]&#123;&quot;小志的儿子&quot;&#125;);</div><div class="line"></div><div class="line">            int i = 3/0;</div><div class="line"></div><div class="line">            //设置  事务执行成功</div><div class="line"></div><div class="line">            db.setTransactionSuccessful();</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        finally&#123;</div><div class="line"></div><div class="line">            //关闭事务，同时提交，如果已经设置事务执行成功，那么sql语句就生效了，反之，sql语句回滚</div><div class="line"></div><div class="line">            db.endTransaction();</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[主线程阻塞，使用handler方法消息队列 和子线程请求主线程进行ui变化]]></title>
      <url>/2016/06/11/handler/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line">static ImageView iv;</div><div class="line">static MainActivity ma;</div><div class="line">static Handler handler = new Handler() &#123;</div><div class="line">@Override</div><div class="line">public void handleMessage(Message msg) &#123;</div><div class="line">switch (msg.what) &#123;</div><div class="line">case 1:</div><div class="line"></div><div class="line">iv.setImageBitmap((Bitmap) msg.obj);</div><div class="line">break;</div><div class="line">case 2:</div><div class="line">                    Toast.makeText(ma, &quot;请求失败&quot;, Toast.LENGTH_SHORT).show();</div><div class="line">break;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">iv = (ImageView) findViewById(R.id.iv);</div><div class="line">ma = this;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">public void click(View v) &#123;</div><div class="line">final String path = &quot;http://192.168.74.154:8080/a.jpg&quot;;</div><div class="line">final File file = new File(getFilesDir(), getPathName(path));</div><div class="line">if (file.exists()) &#123;</div><div class="line">            Log.d(&quot;======&quot;, &quot;1111 &quot;);</div><div class="line">            Bitmap bm = BitmapFactory.decodeFile(file.getAbsolutePath());</div><div class="line">iv.setImageBitmap(bm);</div><div class="line">        &#125; else &#123;</div><div class="line">            Thread t = new Thread() &#123;</div><div class="line">public void run() &#123;</div><div class="line">try &#123;</div><div class="line">                        URL url = new URL(path);</div><div class="line"></div><div class="line">                        HttpURLConnection conn = (HttpURLConnection) url.openConnection();</div><div class="line">                        conn.setRequestMethod(&quot;GET&quot;);</div><div class="line">                        conn.setReadTimeout(5000);</div><div class="line">                        conn.setConnectTimeout(5000);</div><div class="line">                        conn.connect();</div><div class="line">if (conn.getResponseCode() == 200) &#123;</div><div class="line">                            InputStream is = conn.getInputStream();</div><div class="line">byte[] b = new byte[1024];</div><div class="line">                            FileOutputStream fos = new FileOutputStream(file);</div><div class="line">int len = 0;</div><div class="line">while ((len = is.read(b)) != -1) &#123;</div><div class="line">                                fos.write(b, 0, len);</div><div class="line">                            &#125;</div><div class="line">                            fos.close();</div><div class="line">                            Bitmap bm = BitmapFactory.decodeFile(file.getAbsolutePath());</div><div class="line">                            Message msg = handler.obtainMessage();</div><div class="line">                            msg.obj = bm;</div><div class="line">                            msg.what = 1;</div><div class="line">handler.sendMessage(msg);</div><div class="line">                        &#125; else &#123;</div><div class="line">                            Message msg = handler.obtainMessage();</div><div class="line">                            msg.what = 1;</div><div class="line">                        &#125;</div><div class="line">                    &#125; catch (Exception e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            t.start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">public String getPathName(String path) &#123;</div><div class="line">int index = path.lastIndexOf(&quot;/&quot;);</div><div class="line">return path.substring(index + 1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Android </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>

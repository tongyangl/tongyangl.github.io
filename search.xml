<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AsyncTask的再一次探究]]></title>
    <url>%2F2017%2F08%2F15%2FAsyncTask%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[AsyncTask他是一个抽象类大家都知道了，然后使用就是继承他实现那四个方法，然后传入我们要传入的三个泛型参数， Params：表示我们在调用execute方法时传递的参数类型； progress：表示后台任务的执行进度类型； Result：表示后台任务的返回结果类型 不多逼逼了，用法大家都知道了。 注意事项 AsyncTask类第一次加载必须在主线程中加载（这个不需要我们关系，ActivityThread已经帮我们做了）； AsyncTask对象的创建代码必须在主线程中调用； execute方法必须在主线程中调用； onPreExecute、onPostExecute、doInBackground、onProgressUpdate 四个方法不能在程序中直接调用； 一个AsyncTask实例只能调用一次execute方法； AsyncTask执行execute方法时在Android1.6之前串行；Android1.6之后并行；Android3.0后串行。 ​ 注意事项还是要注意的，无论面试还是开发都是需要了解的，避免出现问题。 AsyncTask的源码分析大家分析源码都差不多吧~反正我都是从他的调用开始分析的 异步任务的开始execute方法1234@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125; 嘛，@MainThread 这个注解了解的都知道表示方法必须在主线程调用否则就会提示错误（这句话是百度来的） 我自己实际操作了一下并没有提示错误… 我就不截图了…可以试试，可能在最新的版本里和之前的不太一样吧，本着探索精神干脆运行一下看看是否会出现崩溃..结果还是没有，程序正常启动… 本着探索精神 贴出的代码 123456789101112131415161718192021222324252627282930313233343536public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); new Thread(new Runnable() &#123; @Override public void run() &#123; Log.d(&quot;mmmm&quot;, Thread.currentThread().getName()+&quot; run&quot;); MyAsycktask myAsycktask=new MyAsycktask(); myAsycktask.execute(&quot;tong&quot;); &#125; &#125;).start(); &#125; class MyAsycktask extends AsyncTask&lt;String, Void, String&gt; &#123; @Override protected void onPostExecute(String s) &#123; super.onPostExecute(s); Log.d(&quot;mmmm&quot;, Thread.currentThread().getName()+&quot; onPostExecute&quot;); &#125; @Override protected String doInBackground(String... params) &#123; Log.d(&quot;mmmm&quot;, Thread.currentThread().getName()+&quot; doInBackground&quot;); return params[0]; &#125; &#125; 分别打印出来在我们new的线程中的线程名字，doInBackground的线程名字，以及onPostExecute的线程名字 一目了然，还是回调到了主线程中 所以！之前在网上看别人总结AsyncTask必须在主线程中调用是错误的…可能之前较早的版本需要吧..找了好久没有找到正确的… 好了言归正传，我们看了一下 1executeOnExecutor(sDefaultExecutor, params); 传入的一个是我们的参数，一个是什么呢？ 1private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR; 哦~原来是Executor的实例 SERIAL_EXECUTOR是什么呢 1public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); SerialExecutor是一个实现Executor接口的内部静态私有类 12345678910111213141516171819202122232425private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125;&#125; 可以看到里面有我们线程的队列，以及当前执行的线程 然后下面的代码有点难理解了！！！ 怎么在这个队列中添加的新线程中调用外部的线程呢？其实就是一次包装而已 首先调用的外部的r.run()方法就是我们在编程中写的代码，在这个地方执行而已没有别的 然后会继续执行scheduleNext方法，这个是必须执行的 可以看到这个方法会把线程出队列，然后线程池执行我们的runable。 可能有点不太好理解继续往下看源码，这只是分析了sDefaultExecutor究竟是什么 我们继续看executeOnExecutor方法 123456789101112131415161718192021222324@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this;&#125; 首先是判断…看代码很好理解吧~当这个任务执行过或者正在执行则会抛出对应的异常~ 然后设置我们的任务是运行状态，调用onPreExecute();方法，是不是很熟悉了~ 可以看到我们的任务是串行的~ 然后看看他的构造方法 123456789101112131415161718192021222324252627282930313233343536public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result); &#125; return result; &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; try &#123; postResultIfNotInvoked(get()); &#125; catch (InterruptedException e) &#123; android.util.Log.w(LOG_TAG, e); &#125; catch (ExecutionException e) &#123; throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); &#125; catch (CancellationException e) &#123; postResultIfNotInvoked(null); &#125; &#125; &#125;;&#125; 穿件一个WorkerRunnable，传入我们之前传入的参数泛型 创建一个mFuture实例在这里传入了我们的worker实例 这里看源码可以知道FutureTask是一个实现runnable接口的类。 1public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123; 1public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; 而WorkerRunnable是一个实现callable接口的类 所以和我们之前的代码对应住了。 1result = doInBackground(mParams); 很熟悉吧，我们自己写的代码返回的result 最终调用postResult(result);方法 1234567private Result postResult(Result result) &#123; @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; 这就是我们线程切换的秘密 激动人心的时候来到了！很熟悉吧！内部也是通过handler来实现线程的切换的 gehandler方法 12345678private static Handler getHandler() &#123; synchronized (AsyncTask.class) &#123; if (sHandler == null) &#123; sHandler = new InternalHandler(); &#125; return sHandler; &#125;&#125; 是intenthandler实例 继续看 1234567891011121314151617181920private static class InternalHandler extends Handler &#123; public InternalHandler() &#123; super(Looper.getMainLooper()); &#125; @SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 之所以都能和主线程通信是因为 123public InternalHandler() &#123; super(Looper.getMainLooper()); &#125; 这个方法，直接获取的主线程的Looper; MESSAGE_POST_RESULT对应的是finish方法 12345678rivate void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; 一目了然不必多说了 并行执行但是我们发现这样的话他是串行执行的！！！这样的话会导致多个任务进行的话很麻烦，有没有办法解决呢？ 当然有的~之所以是串行执行还不是因为我们在之前的方法传入的默认的执行器是串行的？从队列一个一个取出来 所以只要调用这个方法 1myAsycktask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR); 这样就可以啦~记住啊不要再调用myAsycktask.execute();方法了 因为我们的execute就是调用的executeOnExecutor方法，所以再调用的话就会出错了 看下THREAD_POOL_EXECUTOR的源码吧 123456789public static final Executor THREAD_POOL_EXECUTOR;static &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); threadPoolExecutor.allowCoreThreadTimeOut(true); THREAD_POOL_EXECUTOR = threadPoolExecutor;&#125; 线程池~我们最开始的默认串行执行器就是最后用他来执行的！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2017%2F08%2F13%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[MVCMVC是模型(Model)－视图(View)－控制器(Controller)的缩写，是设计模式中最常用的软件架构。 视图（View）：用户界面。控制器（Controller）：业务逻辑模型（Model）：数据保存 所有方式都是单向通信： View 接受用户交互请求 View 将请求转交给Controller处理 Controller 操作Model进行数据更新保存 数据更新保存之后，Model会通知View更新 View 更新变化数据使用户得到反馈 MVPMVP是Model-View-Presenter，即将MVC中的控制器Controller换成了Presenter负责逻辑的处理。 MVC和MVP的区别是：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过 Controller。 各部分之间都是双向通信： View 接收用户交互请求 View 将请求转交给 Presenter Presenter 操作Model进行数据更新 Model 通知Presenter数据发生变化 Presenter 更新View数据 ​ MVVMMVVM是Model-View-ViewModel，和MVP的区别在于Presenter换成了ViewModel负责逻辑处理。 MVVM的优点是低耦合、可重用性、独立开发。 双向绑定（data-binding）： View 接收用户交互请求 View 将请求转交给ViewModel ViewModel 操作Model数据更新 Model 更新完数据，通知ViewModel数据发生变化 ViewModel 更新View数据]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rxjava线程切换]]></title>
    <url>%2F2017%2F08%2F12%2FRxjava2.x%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[线程切换的秘密rxjava最让人心动的就是他的链式的线程切换…十分简单，但是我们有没有想过他是为什么这么简单实现的线程切换呢？中间究竟有着什么不可告人的秘密呢！让我们一探究竟！ 下面贴出一段代码 123456789101112131415161718192021222324252627282930313233343536Observable.create(new ObservableOnSubscribe&lt;Object&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Object&gt; e) throws Exception &#123; e.onNext(new Object()); e.onComplete(); &#125;&#125;).subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&lt;Object&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Object value) &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125;&#125;); 是不是很简单也是非常常见的，他只比我们上一篇的多了一个线程切换的过程 12subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) 所以嘛，在哪做的鬼就在那开起来，我们来看看subscribeOn方法的源码 12345@SchedulerSupport(SchedulerSupport.CUSTOM)public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; 嗯…和之前的有点像啊！返回的还是Observable对象，但是对他做了处理了 1RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler)) 这里的this就是我们的Observable对象，scheduler就是传入的线程 继续往下看…现在该看ObservableSubscribeOn了 点进去发现他继承于AbstractObservableWithUpstream 1public final class ObservableSubscribeOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; 而AbstractObservableWithUpstream又是继承于Observable 1234567891011121314151617181920212223242526/** * Base class for operators with a source consumable. * * @param &lt;T&gt; the input source type * @param &lt;U&gt; the output type */abstract class AbstractObservableWithUpstream&lt;T, U&gt; extends Observable&lt;U&gt; implements HasUpstreamObservableSource&lt;T&gt; &#123; /** The source consumable Observable. */ protected final ObservableSource&lt;T&gt; source; /** * Constructs the ObservableSource with the given consumable. * @param source the consumable Observable */ AbstractObservableWithUpstream(ObservableSource&lt;T&gt; source) &#123; this.source = source; &#125; @Override public final ObservableSource&lt;T&gt; source() &#123; return source; &#125;&#125; 记得吗我们出入的是observable对象，怎么在这里变成ObservableSource了我们发现ObservableSource其实是一个接口 12345678910 */public interface ObservableSource&lt;T&gt; &#123; /** * Subscribes the given Observer to this ObservableSource instance. * @param observer the Observer, not null * @throws NullPointerException if &#123;@code observer&#125; is null */ void subscribe(Observer&lt;? super T&gt; observer);&#125; 而observable实现了这个接口 1public abstract class Observable&lt;T&gt; implements ObservableSource&lt;T&gt; &#123; 所以我们可以认为这俩是等同的 再来看看ObservableSubscribeOn 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public final class ObservableSubscribeOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123; final Scheduler scheduler; public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) &#123; super(source); this.scheduler = scheduler; &#125; @Override public void subscribeActual(final Observer&lt;? super T&gt; s) &#123; final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s); s.onSubscribe(parent); parent.setDisposable(scheduler.scheduleDirect(new Runnable() &#123; @Override public void run() &#123; source.subscribe(parent); &#125; &#125;)); &#125; static final class SubscribeOnObserver&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements Observer&lt;T&gt;, Disposable &#123; private static final long serialVersionUID = 8094547886072529208L; final Observer&lt;? super T&gt; actual; final AtomicReference&lt;Disposable&gt; s; SubscribeOnObserver(Observer&lt;? super T&gt; actual) &#123; this.actual = actual; this.s = new AtomicReference&lt;Disposable&gt;(); &#125; @Override public void onSubscribe(Disposable s) &#123; DisposableHelper.setOnce(this.s, s); &#125; @Override public void onNext(T t) &#123; actual.onNext(t); &#125; @Override public void onError(Throwable t) &#123; actual.onError(t); &#125; @Override public void onComplete() &#123; actual.onComplete(); &#125; @Override public void dispose() &#123; DisposableHelper.dispose(s); DisposableHelper.dispose(this); &#125; @Override public boolean isDisposed() &#123; return DisposableHelper.isDisposed(get()); &#125; void setDisposable(Disposable d) &#123; DisposableHelper.setOnce(this, d); &#125; &#125;&#125; subscribeActual这个方法是不是很熟悉，没错我们上一篇已经说到了这个方法了。他在和observer订阅的时候调用。 首先这个方法中的SubscribeOnObserver是他的内部类，看代码可以看到它实现了observer接口，对传进去的下游的observer做了包装。 然后调用自己 1s.onSubscribe(parent); 这个方法 以为我们parent是对observer进行了包装的实现了Disposable接口所以我们在下游调用这个方法的时候就是我们的parent。 最后就是这段代码了 1234567parent.setDisposable(scheduler.scheduleDirect(new Runnable() &#123; @Override public void run() &#123; source.subscribe(parent); &#125; &#125;)); &#125; 挺好理解的我们下游的observer经包装后变成了SubscribeOnObserver—-&gt;变成parent对象 上游的observable经过包装后变成了ObservableSource，其实就是上游的Observable对象 他们订阅发生在一个新的线程中，然后开始了事件的分发，但是注意啊，我们在这里进行的分发是发送给了包装好的observer，而不是调用的observer但是看源码可以看到包装好的SubscribeOnObserver 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static final class SubscribeOnObserver&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements Observer&lt;T&gt;, Disposable &#123; private static final long serialVersionUID = 8094547886072529208L; final Observer&lt;? super T&gt; actual; final AtomicReference&lt;Disposable&gt; s; SubscribeOnObserver(Observer&lt;? super T&gt; actual) &#123; this.actual = actual; this.s = new AtomicReference&lt;Disposable&gt;(); &#125; @Override public void onSubscribe(Disposable s) &#123; DisposableHelper.setOnce(this.s, s); &#125; @Override public void onNext(T t) &#123; actual.onNext(t); &#125; @Override public void onError(Throwable t) &#123; actual.onError(t); &#125; @Override public void onComplete() &#123; actual.onComplete(); &#125; @Override public void dispose() &#123; DisposableHelper.dispose(s); DisposableHelper.dispose(this); &#125; @Override public boolean isDisposed() &#123; return DisposableHelper.isDisposed(get()); &#125; void setDisposable(Disposable d) &#123; DisposableHelper.setOnce(this, d); &#125;&#125; 最终会分发给我们最开始的observer。 这样就完成了一次线程的切换。 subscribeOn 的原理探究清楚了，那么我们的observeOn应该和它差不多吧！ 废话少说我们来看源码 123public final Observable&lt;T&gt; observeOn(Scheduler scheduler) &#123; return observeOn(scheduler, false, bufferSize());&#125; 返回的observable对象继续看 123456@SchedulerSupport(SchedulerSupport.CUSTOM)public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123; ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;); ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;); return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));&#125; 熟悉的一匹…这里说一下，scheduler是我们传入的线程不用多说，而后面的boolean值意思是是否延迟发送，看到上面发现默认是没有延迟的，bufferSize()就是我们缓冲区的大小。 然后不用开我们就知道继续看哪些了，没错！ObservableObserveOn 123456789101112131415161718192021public final class ObservableObserveOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123; final Scheduler scheduler; final boolean delayError; final int bufferSize; public ObservableObserveOn(ObservableSource&lt;T&gt; source, Scheduler scheduler, boolean delayError, int bufferSize) &#123; super(source); this.scheduler = scheduler; this.delayError = delayError; this.bufferSize = bufferSize; &#125; @Override protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; if (scheduler instanceof TrampolineScheduler) &#123; source.subscribe(observer); &#125; else &#123; Scheduler.Worker w = scheduler.createWorker(); source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); &#125; &#125; …很清楚吧，对上下游分别包装，然后再不同的线程中订阅 记住这里的source为上游包装好的observable，而下游的observer为包装好的ObserveOnObserver，同样也是内部类 看看代码吧很长先看一部分 12345678910111213141516171819202122232425static final class ObserveOnObserver&lt;T&gt; extends BasicIntQueueDisposable&lt;T&gt;implements Observer&lt;T&gt;, Runnable &#123; private static final long serialVersionUID = 6576896619930983584L; final Observer&lt;? super T&gt; actual; final Scheduler.Worker worker; final boolean delayError; final int bufferSize; SimpleQueue&lt;T&gt; queue; Disposable s; Throwable error; volatile boolean done; volatile boolean cancelled; int sourceMode; boolean outputFused; ObserveOnObserver(Observer&lt;? super T&gt; actual, Scheduler.Worker worker, boolean delayError, int bufferSize) &#123; this.actual = actual; this.worker = worker; this.delayError = delayError; this.bufferSize = bufferSize; &#125; 这里的 actual下游的observer worker 调度工作的工作者 delayError 是否延迟加载 bufferSize 队列的大小 queue：上游observable下发的队列 s： 储存下游observer的Disposable error 错误信息 done 检验是否完毕 cancelled 同步或异步 ​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Overridepublic void onSubscribe(Disposable s) &#123; if (DisposableHelper.validate(this.s, s)) &#123; this.s = s; if (s instanceof QueueDisposable) &#123; @SuppressWarnings(&quot;unchecked&quot;) QueueDisposable&lt;T&gt; qd = (QueueDisposable&lt;T&gt;) s; int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY); if (m == QueueDisposable.SYNC) &#123; sourceMode = m; queue = qd; done = true; actual.onSubscribe(this); schedule(); return; &#125; if (m == QueueDisposable.ASYNC) &#123; sourceMode = m; queue = qd; actual.onSubscribe(this); return; &#125; &#125; queue = new SpscLinkedArrayQueue&lt;T&gt;(bufferSize); actual.onSubscribe(this); &#125;&#125;@Overridepublic void onNext(T t) &#123; if (done) &#123; return; &#125; if (sourceMode != QueueDisposable.ASYNC) &#123; queue.offer(t); &#125; schedule();&#125;@Overridepublic void onError(Throwable t) &#123; if (done) &#123; RxJavaPlugins.onError(t); return; &#125; error = t; done = true; schedule();&#125;@Overridepublic void onComplete() &#123; if (done) &#123; return; &#125; done = true; schedule();&#125; next方法中可以看到上游的observable下发数据压入了队列中 并且最后都会调用schedule方法 12345void schedule() &#123; if (getAndIncrement() == 0) &#123; worker.schedule(this); &#125;&#125; getAndIncrement的原子性很关键的保证了下面的方法不会再未结束时被再次调用 我们发现传入的是this 但是传入的应该是是runable啊没错，我们的这个ObserveOnObserver实现了这个接口 所以我们的执行方发就要在run中 12345678@Overridepublic void run() &#123; if (outputFused) &#123; drainFused(); &#125; else &#123; drainNormal(); &#125;&#125; drainNormal方法是最经常执行的方法，先看这个 12345678910111213141516171819202122232425262728293031323334353637383940414243void drainNormal() &#123; int missed = 1; final SimpleQueue&lt;T&gt; q = queue; final Observer&lt;? super T&gt; a = actual; for (;;) &#123; if (checkTerminated(done, q.isEmpty(), a)) &#123; return; &#125; for (;;) &#123; boolean d = done; T v; try &#123; v = q.poll(); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); s.dispose(); q.clear(); a.onError(ex); return; &#125; boolean empty = v == null; if (checkTerminated(d, empty, a)) &#123; return; &#125; if (empty) &#123; break; &#125; a.onNext(v); &#125; missed = addAndGet(-missed); if (missed == 0) &#123; break; &#125; &#125;&#125; 发现了个死循环，但是死循环肯定有跳出的没错就要继续看checkTerminated方法了 123456789101112131415161718192021222324252627282930313233boolean checkTerminated(boolean d, boolean empty, Observer&lt;? super T&gt; a) &#123; if (cancelled) &#123; queue.clear(); return true; &#125; if (d) &#123; Throwable e = error; if (delayError) &#123; if (empty) &#123; if (e != null) &#123; a.onError(e); &#125; else &#123; a.onComplete(); &#125; worker.dispose(); return true; &#125; &#125; else &#123; if (e != null) &#123; queue.clear(); a.onError(e); worker.dispose(); return true; &#125; else if (empty) &#123; a.onComplete(); worker.dispose(); return true; &#125; &#125; &#125; return false;&#125; 如果订阅已经取消了那么清空队列如果刚刚调用了onNext onError，onCompele方法时导致d为true 然后继续看方法就知道了如果队列为空直接跳出循环 第二死循环开始分发数据出队列， 以及对异常错了处理，然后继续对队列做判空 最后调用了 a.onNext(v);对象就发送到下游了]]></content>
      <tags>
        <tag>RXJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2.X学习]]></title>
    <url>%2F2017%2F08%2F11%2FRxJava2-X%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AE%A2%E9%98%85%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Rxjavarxjava是什么呢，简单来说就是一个异步框架 下面贴出我们最开始学习的最简单的代码 1234567891011121314151617181920212223242526272829303132Observable.create(new ObservableOnSubscribe&lt;Object&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Object&gt; e) throws Exception &#123; e.onNext(new Object()); e.onComplete(); &#125; &#125;).subscribe(new Observer&lt;Object&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Object value) &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125; &#125;); 是不是很熟悉，非常基础的，也是最常使用的 刚开始使用的时候一直好奇 e.onNext(new Object());中的对象是如何传递到 12345@Override public void onNext(Object value) &#123; &#125; 这个方法中的呢…今天我终于能静下心来好好分析其中的原因了。。。 首先我们看Observable ，他是一个抽象类，嗯..有点长跳过 然后是ObservableOnSubscribe的源码 他是一个接口 123456789public interface ObservableOnSubscribe&lt;T&gt; &#123; /** * Called for each Observer that subscribes. * @param e the safe emitter instance, never null * @throws Exception on error */ void subscribe(ObservableEmitter&lt;T&gt; e) throws Exception;&#125; 里面也有我们正要实现的方法 void subscribe(ObservableEmitter e) 再看看ObservableEmitter 他继承于Emitter ，并且添加了几个新的方法。 12345678910111213141516171819202122232425262728public interface ObservableEmitter&lt;T&gt; extends Emitter&lt;T&gt; &#123; /** * Sets a Disposable on this emitter; any previous Disposable * or Cancellation will be unsubscribed/cancelled. * @param d the disposable, null is allowed */ void setDisposable(Disposable d); /** * Sets a Cancellable on this emitter; any previous Disposable * or Cancellation will be unsubscribed/cancelled. * @param c the cancellable resource, null is allowed */ void setCancellable(Cancellable c); /** * Returns true if the downstream disposed the sequence. * @return true if the downstream disposed the sequence */ boolean isDisposed(); /** * Ensures that calls to onNext, onError and onComplete are properly serialized. * @return the serialized ObservableEmitter */ ObservableEmitter&lt;T&gt; serialize();&#125; 这几个东西大概是什么我们有了个大概的了解，然后看看最重要的create方法，毕竟我们需要的Observable对象实例就是create方法返回的 12345@SchedulerSupport(SchedulerSupport.NONE)public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; ObjectHelper.requireNonNull(source, &quot;source is null&quot;); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));&#125; 没错observable对象就是 1RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source)); 这个方法返回的 再来看看onAssembly方法 1234567public static &lt;T&gt; Observable&lt;T&gt; onAssembly(Observable&lt;T&gt; source) &#123; Function&lt;Observable, Observable&gt; f = onObservableAssembly; if (f != null) &#123; return apply(f, source); &#125; return source;&#125; 我们这里发现onAssembly 方法传入的是ObservableCreate，而非Observable对象 所以我们看下ObservableCreate的源码 1234567891011121314151617181920212223public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; &#123; final ObservableOnSubscribe&lt;T&gt; source; public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) &#123; this.source = source; &#125; @Override protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); observer.onSubscribe(parent); try &#123; source.subscribe(parent); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); parent.onError(ex); &#125; &#125; ..... ..... ..... 略 这只是一部分源码也是最重要的 我们可以发现ObservableCreate是继承于observable的所以使用他的实例没有问题 这也是最重要的两个方法， 我们先看看他的构造方法，把我们create传入的ObservableOnSubscribe传到这个构造方法中 最难理解的地方来了。 下面那个方法是干嘛的呢？ CreateEmitter parent = new CreateEmitter(observer);又是干嘛的呢 1CreateEmitter是ObservableCreate的一个静态内部类，并且final修饰，不可继承他实现了ObservableEmitter接口 前面已经做了介绍了ObservableEmitter实现了Emitter接口 说到关联就不得不说observable的subscribe方法，他传入的是我们的 Observer对象 再次做的关联，所以关联肯定是在这个方法完成的， 1234567891011121314151617181920212223@SchedulerSupport(SchedulerSupport.NONE)@Overridepublic final void subscribe(Observer&lt;? super T&gt; observer) &#123; ObjectHelper.requireNonNull(observer, &quot;observer is null&quot;); try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, &quot;Plugin returned null Observer&quot;); subscribeActual(observer); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); // can&apos;t call onError because no way to know if a Disposable has been set or not // can&apos;t call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException(&quot;Actually not, but can&apos;t throw other exceptions due to RS&quot;); npe.initCause(e); throw npe; &#125;&#125; 这是subscribe方法的源码，还记得subscribeActual方法把，没错就是在这里做的回调 但是你们可能直接点击返现subscribeActual是个抽象方法。但是我们具体调用的是ObservableCreate 他实现了里面的抽象方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static final class CreateEmitter&lt;T&gt;extends AtomicReference&lt;Disposable&gt;implements ObservableEmitter&lt;T&gt;, Disposable &#123; private static final long serialVersionUID = -3434801548987643227L; final Observer&lt;? super T&gt; observer; CreateEmitter(Observer&lt;? super T&gt; observer) &#123; this.observer = observer; &#125; @Override public void onNext(T t) &#123; if (t == null) &#123; onError(new NullPointerException(&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;)); return; &#125; if (!isDisposed()) &#123; observer.onNext(t); &#125; &#125; @Override public void onError(Throwable t) &#123; if (t == null) &#123; t = new NullPointerException(&quot;onError called with null. Null values are generally not allowed in 2.x operators and sources.&quot;); &#125; if (!isDisposed()) &#123; try &#123; observer.onError(t); &#125; finally &#123; dispose(); &#125; &#125; else &#123; RxJavaPlugins.onError(t); &#125; &#125; @Override public void onComplete() &#123; if (!isDisposed()) &#123; try &#123; observer.onComplete(); &#125; finally &#123; dispose(); &#125; &#125; &#125; 这是上面CreateEmitter 的类 1source.subscribe(parent); 在这里做了关联究竟是怎么关联的已经走到了8 9分了 我们可以发现source其实就是ObservableOnSubscribe对象。 subscribe这个方法就是 12345678910Observable.create(new ObservableOnSubscribe&lt;Object&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Object&gt; e) throws Exception &#123; e.onNext(new Object()); e.onComplete(); &#125; &#125;) 里的subscribe方法所以 e.onNext(new Object()) 就是调用的CreateEmitter实例parent的onNext方法 123456789public void onNext(T t) &#123; if (t == null) &#123; onError(new NullPointerException(&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;)); return; &#125; if (!isDisposed()) &#123; observer.onNext(t); &#125;&#125; onnext方法里面对传过来的T ，如果不为空并且继续传递则调用observer的onNext方法就完成了关联 怎么样是不是很晕啊….没错我刚开始自己看的时候也是很晕，，但是仔细看几遍就好了。 嗯既然思路弄清楚了就整理一下 observable是如何和Observer关联的 首先调用observable的create方法，返回一个observable对象实例，记住这个observable是他的实现类ObservableCreate 在ObservableCreate中对我们的ObservableOnSubscribe对象进行了传递并且他实现了observable的抽象方法subscribeActual 当我们的observable实例创建后就要调用subscribe和observer关联了，subscribeActual(observer);方法调用了上个步骤中实现的subscribeActual抽象方法，传入的就是我们的observer subscribeActual方法中CreateEmitter parent = new CreateEmitter(observer);的CreateEmitter实现了ObservableEmitter, Disposable两个接口，并且source.subscribe(parent);中的parent其实就是我们的ObservableEmitter，所以我们调用的e.onNext()就是调用的parent中的这个方法 123456789public void onNext(T t) &#123; if (t == null) &#123; onError(new NullPointerException(&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;)); return; &#125; if (!isDisposed()) &#123; observer.onNext(t); &#125; &#125; 其中对T做了非空判断，如果传递的不为空则调用observer的onNext方法。就完成了一次传递！ 其实很简单的只要自己仔细思考。 但是是不是觉得很奇怪，每个方法都有对!isDisposed()做了判断！ 没错我们只会执行一次onerror或者onComplete就是因为他 我们发现在源码中都有个finalily的块调用dispose方法然后isDisposed就为false了也就不会继续执行另一个了 ​ 但这只是最简单的订阅关系，并未实现线程的切换，线程的切换我会在下一篇分析！]]></content>
      <categories>
        <category>rxjava</category>
      </categories>
      <tags>
        <tag>rxjava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络复习]]></title>
    <url>%2F2017%2F08%2F08%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[分组交换和电路交换 分组交换 资源不会被保留 效率高 今天的因特网就是分组交换 ​ 电路交换 资源会被保留 效率低 可以为一个通话保证特定数量的端到端宽带 频分多路复用分时多路复用 ​ 分组交换的时延 处理时延+排队时延+传播时延+传输时延 传输时延和传播时延的区别 传输时延: R= 链路带宽 (bps)L= 分组长度 (比特)发送比特进入链路的时间= L/R 传播时延: d = 物理链路的长度s = 在媒体中传播的速度 (~2x108 m/sec)传播时延 = d/s 传播时延指的是线路传播时延，只与传输介质有关。传输指的是一定数据从开始传输到传输结束的时间，与介质、比特率有关。传输时延=传播时延+数据量/比特率。 传输是指我们接收或者发出文件或者数据；传输可以是非实时性的。 传播是指我们把文件或者数据发出；传播只具有单向性，实时性。 分组交换对比电路交换 电路交换 在数据传输前，必须建立端到端的连接 一旦某个节点故障，必须重新建立连接 连接建立后，数据的传输没有额外的延时 数据中不必包含地址域，仅需较短的虚电路号 数据按序传输，但信道的使用率较低 适合长时间传输大批量的数据，如流数据 分组交换 在数据传输前，不必建立端到端的连接 只要下一个节点空闲，即可传输 信道的使用率较高 数据的传输采用存储转发，延时不可估计 数据中必须包含地址域 接收到的分组不一定按序，可能还需重组 适合传输文本型数据 因特网的分层 应用层: 支持网络应用 FTP、HTTP、DNS、SMTP、DHCP等 FTP：文件传输协议，FTP是因特网上使用得最广泛的文件传送协议。FTP提供交互式的访问，允许客户指明文件类型与格式，并允许文件具有存取权限。FTP其于TCP。 HTTP：超文本传输协议，是面向事务的应用层协议，它是万维网上能够可靠地交换文件的重要基础。http使用面向连接的TCP作为运输层协议，保证了数据的可靠传输。 DNS：域名系统，DNS是因特网使用的命名系统，用来把便于人们使用的机器名字转换为IP地址。 现在顶级域名TLD分为三大类：国家顶级域名nTLD；通用顶级域名gTLD;基础结构域名 域名服务器分为四种类型：根域名服务器；顶级域名服务器；本地域名服务器；权限域名服务器。 SMTP：电子邮件协议，即简单邮件传送协议。SMTP规定了在两个相互通信的SMTP进程之间应如何交换信息。SMTP通信的三个阶段：建立连接、邮件传送、连接释放。 POP3：邮件读取协议，协议通常被用来接收电子邮件 SNMP：简单网络管理协议。由三部分组成：SNMP本身、管理信息结构SMI和管理信息MIB。SNMP定义了管理站和代理之间所交换的分组格式。SMI定义了命名对象类型的通用规则，以及把对象和对象的值进行编码。MIB在被管理的实体中创建了命名对象，并规定类型。 Telnet：远程终端协议，telnet是一个简单的远程终端协议，它也是因特网的正式标准。又称为终端仿真协议。 运输层: 主机到主机数据传输TCP, UDP TCP： 特点：点到点，可靠、有序，全双工，面向连接，流量控制，拥塞控制。 连接时需要三次握手。 断开连接时需要四次挥手 TCP支持的应用协议主要有：Telnet、FTP、SMTP等。 TCP提供IP下的数据可靠传输，它提供的服务包括数据流传送、可靠性、有效流控、全双工操作和多路复用。通过面向连接、端到端和可靠的数据包发送。 TCP协议采用了哪些机制保证数据的可靠传输？ 连接时的 三次握手以及断开时的四次握手 确认机制（超时、稍带确认） 拥塞控制、流量控制 TCP中拥塞控制的方法： 加性增，乘性减 慢启动 对超时事件做出反应 加性增：没有检测到拥塞的情况下，收到一个确认后就把拥塞窗口值增大一点（线性） 乘性减：每发生一次丢包事件就将当前的拥塞窗口值减半 这里要特别注意拥塞控制、流量控制的区别 拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器不至于过载。拥塞控制的前提是：网络能够承受现有的网络负荷。 流量控制：点对点通信量的控制。控制发送端的发送数据的速率。 这里要特别注意选择重传、回退N步的区别 选择重传：只重传出现差错的数据帧。但这时必须加大接收窗口，以便先收下发送序列号不连续但仍在接收窗口中的数据帧。等到所缺序号的数据帧收到后再一并交给主机。 回退N步：当接收方检测出失序的数据帧后，要求发送方重发最后一个正确接收的信息之后所有未确认的帧；或者当发送方发了N个帧以后，发现N帧的前一帧在计时器超时后仍未返回其确认信息，则该帧被判超时或者出错，此时发送方不得不重新发送出错帧以及其后的帧。 UDP： ​ 是无连接的运输层协议 UDP支持的应用层协议主要有：NFS（网络文件系统）、SNMP（简单网络管理协议）、DNS（主域名称系统）、TFTP（通用文件传输协议）等. 而UDP则不为IP提供可靠性、流控或差错恢复功能，是非面向连接，不可靠的传输。 优点： 应用层能够更好地控制要发送的数据和发送时间 无需建立连接 无连接状态 分组首部开销小 应用： 常用于流式多媒体应用 丢包容忍 速率敏感 其他 DNS SNMP 网络层: 从源到目的地数据报的选路 ARP、IP、ICMP、OSPF、BGP等 IP：网络之间互连的协议的外语（internet Protocol）缩写，中文缩写为“网协”. 因特网的地址分配策略被称为无类别域间选路（CIRD）。在采用CIRD之前，IP地址被分为A,B,C,D,E五类，分别为： 不过在这之间，有几个私有地址，是不能够被使用的，包括： A类 10.0.0.0 --10.255.255.255 ​ B类 172.16.0.0–172.31.255.255 ​ C类 192.168.0.0–192.168.255.255 - ARP:地址解析协议，即ARP（Address Resolution Protocol）, ARP协议的主要功能是将32位IP地址转换为48位物理地址。 工作过程：首先每台主机都会在缓冲区建立一个ARP列表，以表示IP与MAC的对应关系。当有数据包发送时，会先检查ARP列表中是否存在该IP对应的MAC地址，如果有，则直接将包发送到这个MAC地址，如果没有，就向本地网段发起一个ARP请求的广播包，网络中所有主机收到这个ARP包后，会先检查自己的IP是否与包中的IP地址一致，如果不一致则忽略，如果一致，则将发送端的MAC地址和IP地址添加到自己的ARP列表中（已存在的则覆盖），然后向发送端发送一个响应包，当发送方收到该响应包后,将接收方的IP与MAC添加到自己的ARP列表中。然后开始数据的传输 - ICMP:ICMP是（Internet Control Message Protocol）Internet控制[报文](https://baike.baidu.com/item/%E6%8A%A5%E6%96%87)协议。它是[TCP/IP协议族](https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE%E6%97%8F)的一个子协议，用于在IP[主机](https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA)、[路由](https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1)器之间传递控制消息。控制消息是指[网络通](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A)不通、[主机](https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA)是否可达、[路由](https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1)是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。 - OSPF:OSPF(Open Shortest Path First[开放式最短路径优先]是一个[内部网关协议](Interior Gateway Protocol，简称IGP），用于在单一[自治系统]（autonomous system,AS）内决策[路由]。是对[链路状态路由协议]的一种实现，隶属内部网关协议（IGP） - BGP:边界网关协议（BGP）是运行于 TCP 上的一种[自治系统]的[路由协议]。 BGP 是唯一一个用来处理像因特网大小的网络的协议，也是唯一能够妥善处理好不相关[路由域]间的多路连接的协议 - RIP:路由信息协议 - NAT（Network Address Translation，网络地址转换）是1994年提出的。当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。 - RARP（Reverse Address Resolution Protocol）：逆向地址解析协议。 数据链路层: 在邻近网元之间传输数据ALOHA、CSMA或CSMA/CD、TDMA、FDMA、CDMA 物理层: “在线上”的比特 任何一种调制解调体制 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2 ​ MAC地址和IP地址有什么本质区别？ MAC地址是数据链路层地址，IP地址是网络层地址； MAC地址没有结构性涵义，IP地址有结构性涵义，表示计算机与网络之间的连接关系。 IP地址就是给每个连接在因特网上的主机（或路由器）分配一个在全世界范围内是唯一的32位的标识符，从而把整个因特网看成是一个单一的，抽象的网络；在实际网络的链路上传输数据帧时，最终还是要用到物理地址； MAC地址在一定程度属于硬件一致，基于物理层。能标识具体的链路通信对象，IP地址给予逻辑域的划分，不受硬件控制； 作为中间系统。转发器、网桥、路由器和网关有何区别？转发器：是物理层中间设备。主要作用是在物理层中实现透明的二进制比特复制，以补偿信号衰减。 网桥：是数据链路层的中间设备。主要作用是根据MAC帧的目的地址对收到的帧进行转发。网桥具有过滤帧的功能。 路由器：网络层的中间设备。作用是在互连网中完成路由选择的功能。 网关：网络层以上的中间系统。作用是在高层进行协议的转换以连接两个不兼容的系统。 C/S模式和P2P模式的区别①：C/S结构是一种客户端/服务器结构，客户端与服务器之间是主从关系，是一种一对多的模式。它的信息和数据需要保存在服务器上，若用户要浏览和下载信息，必须先访问服务器，才能浏览和下载信息，而且客户机之间没有交互的能力。相反，P2P模式不分提供信息服务器和索取信息的客户端，每一台电脑都是信息的发布者和索取者，对等点之间能交互，无需使用服务器。②：C/S模式中信息的存储和管理比较集中、稳定，服务器只公布用户想公布的信息，并且会在服务器中稳定地保存一段时间，该服务器通常也不间断的运行在网络间。而P2P缺乏安全机制，P2P是能给用户带来方便，但也会带来大量垃圾信息，而且各个对等点可以随便进入或者退出网络，会造成网络的不稳定。③：从安全的角度来说，因为系统会出现漏洞，而C/S模式采用集中管理模式，客户端只能被动地从服务器获取信息，所以一旦客户端出了差错，并不会影响整个系统。④：C/S模式的管理软件更新的较快，要跟上技术，必须花费大量精力和金钱在软件的更新换代上，而且工作人员要维护服务器和数据库，也要耗费大量资金。相反的P2P不需要服务器，也就不必耗费大量资金，而且每个对等点都可以在网络上发布和分享信息，这使得闲散资源得以充分的利用。 osi OSI的层 功能 TCP/IP协议 应用层 文件传输，电子邮件，文件服务，虚拟终端 TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 表示层 数据格式化，代码转换，数据加密 无 会话层 解除或建立与别的接点的联系 无 传输层 提供端对端的接口 TCP，UDP 网络层 为数据包选择路由 IP，ICMP，RIP，OSPF，BGP，IGMP 数据链路层 传输有地址的帧以及错误检测功能 SLIP，CSLIP，PPP，ARP，RARP，MTU 物理层 以二进制数据形式在物理媒体上传输数据 ISO2110，IEEE802，IEEE802.2 TCP/IP五层协议 层级 网络设备 应用层 也就是用户使用的应用了。 传输层 四层交换机、也有工作在四层的路由器 网络层 路由器、三层交换机 数据链路层 网桥（现已很少使用）、以太网交换机（二层交换机）、网卡（其实网卡是一半工作在物理层、一半工作在数据链路层） 物理层 网卡，光纤，CAT-5线，中继器、集线器、还有我们通常说的双绞线也工作在物理层]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构————栈]]></title>
    <url>%2F2017%2F08%2F07%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈一种先入后出的数据结构 相关计算题只用另一个栈和其他变量完成栈的排序 思想：使用一个中间变量current，记第一个栈为stack，第二个辅助栈为lstake stack pop一个元素给current，和lstake的栈顶元素比较，当current小于栈顶元素直接push到栈顶， 反之当大于栈顶元素时，一直pushlstake的元素到stake栈顶，直到lstake的栈顶元素大于current的值。 一直重复直到stake的栈为空 12345678910111213141516171819202122232425262728293031323334353637import java.util.Stack;/** * Created by 佟杨 on 2017/8/7. */public class test &#123; public static void main(String args[]) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(1); stack.push(5); stack.push(3); stack.push(2); stack.push(9); stack.push(6); stack.push(7); int current; Stack&lt;Integer&gt; lstake = new Stack&lt;&gt;(); lstake.push(stack.pop()); while (!stack.empty()) &#123; current = stack.pop(); while (!lstake.empty()&amp;&amp;current&gt;lstake.peek())&#123; stack.push(lstake.pop()); &#125; lstake.push(current); &#125; for (int a : lstake) &#123; System.out.print(a + &quot;,&quot;); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八大排序java实现]]></title>
    <url>%2F2017%2F08%2F05%2F%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8Fjava%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[总结整理下八大排序的算法，用java实现。毕竟都是一些面试，平时使用都要用到的算法 冒泡排序 冒泡排序：一趟一趟的比较，比较相邻元素的大小，每趟有一个元素沉入最后面的位置 属于交换类排序 稳定的排序算法 平均时间复杂度O(n*n) 最坏时间复杂度O(n*n) 空间复杂度O(1) n较小时适用 ​ 123456789101112131415public static void bubbleSort(int[] array) &#123; System.out.println(&quot;BubbleSort()&quot;); for (int i = 0; i &lt; array.length; i++) &#123;//第i趟比较 for (int j = i + 1; j &lt; array.length; j++) &#123; if (array[j] &lt; array[i]) &#123; swap(array,j,i); &#125; &#125; &#125; &#125; 12345private static void swap(int[] array, int a, int b) &#123; int t = array[a]; array[a] = array[b]; array[b] = t;&#125; 选择排序 ​ *直接选择排序：第i轮选择剩余最小的元素放入到第i的位置上 ​ * 属于选择类排序 ​ * 不稳定的排序算法 ：如58529第一轮选择交换5和2，破换了原来两个5的顺序 ​ 平均时间复杂度O(nn) ​ 最坏时间复杂度O(nn) ​ * 空间复杂度O(1) ​ * 当n较小时适用 123456789101112public static void xuanze(int[] array)&#123; for (int i=0;i&lt;arr.length-1;i++)&#123; int min=i; for (int j=i+1;j&lt;arr.length;j++)&#123; if (arr[j]&lt;arr[min])&#123; min=j; &#125; &#125; swap(arr,min,i);&#125; 插入排序 ​ *直接插入排序：每一轮第i个元素跟前面的i-1个元素从后向前比较，一直比较到合适插入的位置 ​ * 属于插入类排序 ​ * 稳定的排序算法 ​ 平均时间复杂度O(nn) ​ 最坏时间复杂度O(nn) ​ * 空间复杂度O(1) ​ * 大部分有序时适用 123456789101112131415public static void insertSort(int []array)&#123; int current,j; for (int i=1;i&lt;array.length;i++)&#123; current=array[i]; for ( j=i-1;j&gt;=0&amp;&amp;array[j]&gt;current;j--)&#123; array[j+1]=array[j]; &#125; array[j+1]=current; &#125;&#125; 快速排序 ​ 通过递归和分治的思想，先确定一个值一般为第一个，然后从右向前遍历一旦后面的小，则第一个和这个数字交换位置，然后从左向右遍历。直到两个指针指向同一个位置。 ​ 平均时间复杂度O(nlog2n) ​ 最坏时间复杂度O(nn) ​ * 空间复杂度O(1) ​ * n较大 时适用 123456789101112131415161718192021222324252627282930313233343536373839404142public static void sort(int[] data, int left, int right) &#123; // 枢纽元，一般以第一个元素为基准进行划分 int leftCurrent = left; int rightCurrent = right; if (left &lt; right) &#123; // 从数组两端交替地向中间扫描 int pivotKey = data[left]; System.out.println(&quot;---leftCurrent:&quot; + leftCurrent + &quot;--rightCurrent:&quot; + rightCurrent + &quot;--key:&quot; + pivotKey); // leftCurrent从左往右扫描，rightCurrent从右往左扫描 while (leftCurrent &lt; rightCurrent) &#123; // 找到数组最右边比key小的值的下标 while (leftCurrent &lt; rightCurrent &amp;&amp; pivotKey &lt; data[rightCurrent]) &#123; rightCurrent--; &#125; if (leftCurrent &lt; rightCurrent) &#123; // 把右边比key小的值往前挪 data[leftCurrent] = data[rightCurrent]; leftCurrent++; System.out.println(&quot;a:&quot; + Arrays.toString(data)); &#125; // 找到左边比key大的值的下标 while (leftCurrent &lt; rightCurrent &amp;&amp; pivotKey &gt; data[leftCurrent]) &#123; leftCurrent++; &#125; if (leftCurrent &lt; rightCurrent) &#123; // 把左边比key大的值往右挪 data[rightCurrent] = data[leftCurrent]; rightCurrent--; System.out.println(&quot;b:&quot; + Arrays.toString(data)); &#125; &#125;// end while // 枢纽元素移动到正确位置 data[leftCurrent] = pivotKey; System.out.println(&quot;---&quot; + Arrays.toString(data) + &quot;\n\n&quot;); // 前半个子表递归排序 sort(data, left, leftCurrent - 1); // 后半个子表递归排序 sort(data, leftCurrent + 1, right); &#125;// end if&#125;// 可以这么理解 两个指针 j k分别从左向右和从右向左遍历， 从左向右的一旦发现比key大的就给右边 从右向左的一旦发现比key小的就放左边 这样一直遍历到指针指向同一个位置，这个位置就是jk相同并且是key应该存在的位置 希尔排序 ​ *希尔排序：分组交换的思想，先分组，后交换排序 ​ * 属于交换类排序 ​ * 不稳定的排序算法 ：分组之后交换打破了稳定性 ​ 平均时间复杂度O(nlog2n) ​ * 最坏时间复杂度O(n^s) 1&lt;s&lt;2 ​ * 空间复杂度O(1) ​ * n较大时适用 1234567891011121314151617181920212223242526272829public static void shellSort(int[] data) &#123; int i,j,group; int n=data.length; for (group=n/2;group&gt;0;group=group/2)&#123; for (i=0;i&lt;group;i++)&#123; for (j=i+group;j&lt;n;j+=group)&#123; if (data[j] &lt; data[j - group]) &#123; int temp = data[j]; int k = j - group; while (k &gt;= 0 &amp;&amp; data[k] &gt; temp) &#123; data[k + group] = data[k]; k -= group; &#125; data[k + group] = temp; &#125; &#125; &#125; &#125;&#125; 堆排序 ​ 二叉堆是完全二叉树或者是近似完全二叉树。 二叉堆满足二个特性： 1．父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。 2．每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。 当父结点的键值总是大于或等于任何一个子节点的键值时为最大堆。当父结点的键值总是小于或等于任何一个子节点的键值时为最小堆 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * Created by 佟杨 on 2017/8/6. */public class Template &#123; public void CreatHeap(int a[], int n) &#123; int isfirst = (n -2) / 2;//第一个非叶子节点 for (; isfirst &gt;= 0; isfirst--) &#123; AdjustHeapNode(a, isfirst, n); &#125; &#125; void HeapSort(int a[], int n) &#123; CreatHeap(a, n); int temp; for (int i = 0; i &lt; n - 1; i++) &#123; temp = a[n - 1 - i]; a[n - 1 - i] = a[0]; a[0] = temp; AdjustHeapNode(a, 0, n - 1 - i); &#125; &#125; public void AdjustHeapNode(int a[], int i, int n) &#123; if (n == 1 || i &gt; (n - 2) / 2) //i为叶子节点 (n-2)/2 最后一个非叶子节点的位置 return; int iLeft = 2 * i + 1; int iRight = 2 * i + 2; if (iRight &lt;= n - 1) //说明i有左右两个子节点 三个节点找最大值 &#123; if (a[i] &gt;= a[iLeft] &amp;&amp; a[i] &gt;= a[iRight]) // i 最大 不用调整 return; if (a[i] &lt; a[iLeft] &amp;&amp; a[iRight] &lt;= a[iLeft]) // iLeft 最大 &#123; int temp = a[iLeft]; a[iLeft] = a[i]; a[i] = temp; AdjustHeapNode(a, iLeft, n); return; &#125; if (a[i] &lt; a[iRight] &amp;&amp; a[iLeft] &lt;= a[iRight]) // iRight 最大 &#123; int temp = a[iRight]; a[iRight] = a[i]; a[i] = temp; AdjustHeapNode(a, iRight, n); return; &#125; &#125; else &#123; // 说明i只有左节点 二个节点找最大值 //iLeft为最后一个节点 if (a[i] &gt;= a[iLeft]) return; else &#123; int temp = a[iLeft]; a[iLeft] = a[i]; a[i] = temp; AdjustHeapNode(a, iLeft, n); return; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment懒加载]]></title>
    <url>%2F2017%2F08%2F02%2FFragment%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[说真的！！网上的博客好多都是在别人那直接copy过来的！昨天看算法就是，百度第一页的所有博客几乎都一样而且不是一个人写的，最重要的是他妈的是错的！！！逻辑混乱，代码错误，挫的都一样。真的佩服。今天看懒加载又是这样。。不得不自己琢磨了 懒加载大家都知道懒加载为了什么有事时候Viewpager 可能加载十多个Fragment ，一下子全加载了对用户体验很不好。而且viewpage的setOffscreenPageLimit方法看源码就知道了 1private static final int DEFAULT_OFFSCREEN_PAGES = 1; 1234567891011public void setOffscreenPageLimit(int limit) &#123; if (limit &lt; DEFAULT_OFFSCREEN_PAGES) &#123; Log.w(TAG, &quot;Requested offscreen page limit &quot; + limit + &quot; too small; defaulting to &quot; + DEFAULT_OFFSCREEN_PAGES); limit = DEFAULT_OFFSCREEN_PAGES; &#125; if (limit != mOffscreenPageLimit) &#123; mOffscreenPageLimit = limit; populate(); &#125;&#125; 你无论怎么设置它都至少加载下一页的体验很差！尤其每个fragment都有大量的网络请求和绘制的时候 所以懒加载诞生了。最重要的就是setUserVisibleHint这个方法 1234public void setUserVisibleHint(boolean isVisibleToUser) &#123; super.setUserVisibleHint(isVisibleToUser); &#125; 当fragment可见的时候isVisibleToUser为true，反之亦然。但是这里要注意了，它是在oncreateview之前调用的，所以直接在这里请求绘制控件的话会空指针的！ 所以我们封装一个BaseFragment 1234567891011121314151617181920212223242526272829303132333435363738394041424344package rxjavatest.tycoding.com.iv2ex.ui.fragment;import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.view.View;/** * Created by 佟杨 on 2017/8/1. */public abstract class BaseFragment extends Fragment &#123; protected boolean isVisable; protected boolean isprepared = false; protected boolean isdateInit=false; @Override public void setUserVisibleHint(boolean isVisibleToUser) &#123; super.setUserVisibleHint(isVisibleToUser); isVisable=isVisibleToUser; prepareFetchData(false); &#125; @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); isprepared=true; prepareFetchData(false); &#125; protected void prepareFetchData(boolean force)&#123; if (isVisable &amp;&amp; isprepared &amp;&amp; (!isdateInit || force)) &#123; loadData(); isdateInit = true; &#125; &#125; protected abstract void loadData( );&#125; 分别讲一下上面意思 首先三个boolean值分别是frag是否可见，view是否初始化，fragment是否加载过数据 protected abstract void loadData( ); 这个抽象方法就是在子类中需要实现的，在这里进行数据加载。 prepareFetchData(boolean force)的参数用来我们子类执行是否每次都加载的操作]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己写一个Handler]]></title>
    <url>%2F2017%2F07%2F27%2F%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AAHandler%2F</url>
    <content type="text"><![CDATA[前一阵整理了一下Handler的机制。。大概自己是弄明白的，但是为了巩固下自己，决定自己写一个handler，，当然我们是通过java程序来模拟。 首先回想下我们大概需要哪几个东西，没错，四个。 Message Looper Handler MessageQueue ​ 接下来我们就需要按照自己的印象和想法来实现。只要大概功能就行。 最简单的Message 12345678910111213/** * Created by 佟杨 on 2017/7/27. */public class Message &#123; Handler target; public Object obj; public Object getObj() &#123; return obj; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * Created by 佟杨 on 2017/7/27. */public class MessageQueue &#123; Message[] messages; Lock lock = new ReentrantLock(); Condition ConditionFull; Condition ConditionEmpty; int putIndex; int takeIndex; int count; public MessageQueue() &#123; ConditionFull = lock.newCondition(); ConditionEmpty = lock.newCondition(); messages = new Message[50]; &#125; final void enqueueMessage(Message mes) &#123; try &#123; lock.lock(); while (count == messages.length) &#123; try &#123; ConditionFull.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; messages[putIndex] = mes; putIndex = (++putIndex == messages.length ? 0 : putIndex); count++; ConditionEmpty.signalAll(); &#125; finally &#123; lock.unlock(); &#125; &#125; final Message next()&#123; //取出消息 Message message = null; try&#123; lock.lock(); //取到最后一个 if (count == 0) &#123; try &#123; ConditionEmpty.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; message = messages[takeIndex]; messages[takeIndex] = null; takeIndex = (++takeIndex == messages.length ? 0 : takeIndex); count--; //通知子线程 ConditionFull.signalAll(); &#125;finally&#123; lock.unlock(); &#125; return message; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Created by 佟杨 on 2017/7/27. */public class Looper &#123; static final ThreadLocal&lt;Looper&gt;sThreadLocal=new ThreadLocal&lt;&gt;(); MessageQueue messageQueue; public Looper( ) &#123; messageQueue=new MessageQueue(); &#125; public static Looper myLooper() &#123; return sThreadLocal.get(); &#125; public static void prepare() &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException( &quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper()); &#125; public static void loop() &#123; Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException( &quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); &#125; MessageQueue queue = me.messageQueue; for (;;) &#123; Message msg = queue.next(); if (msg == null || msg.target == null) continue; //转发给handler msg.target.dispatchMessage(msg); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Created by 佟杨 on 2017/7/27. */public class Handler &#123; MessageQueue messageQueue; Looper looper; public Handler() &#123; looper = Looper.myLooper(); if (looper == null) &#123; throw new RuntimeException( &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;); &#125; messageQueue = looper.messageQueue; &#125; public final void sendMessage(Message msg)&#123; MessageQueue queue = messageQueue; if (queue != null) &#123; msg.target = this; queue.enqueueMessage(msg); &#125;else &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessage() called with no mQueue&quot;); throw e; &#125; &#125; public void handleMessage(Message msg) &#123; &#125; /** * Handle system messages here. */ public void dispatchMessage(Message msg) &#123; handleMessage(msg); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.UUID;/** * Created by 佟杨 on 2017/7/19. */public class test &#123; public static void main(String args[]) &#123; Looper.prepare(); Handler handler=new Handler()&#123; @Override public void handleMessage(Message msg) &#123; System.out.println(Thread.currentThread().getName() + &quot;--receiver--&quot; + msg.toString()); &#125; &#125;; for (int i = 0; i &lt; 10; i++) &#123; int finalI = i; new Thread(new Runnable() &#123; public void run() &#123; while (true) &#123; Message msg = new Message(); synchronized (UUID.class) &#123; msg.obj = Thread.currentThread().getName()+&quot;--send---+&quot;+String.valueOf(finalI); &#125; System.out.println(msg); handler.sendMessage(msg); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start(); &#125; //开始消息循环 Looper.loop(); &#125;&#125; 执行程序]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[handler的实现原理]]></title>
    <url>%2F2017%2F07%2F23%2Fhandler%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[说真的关于handler的原理的文章，网上多的是，之前由于自己懒惰，都是自己看网上分析的博客，然后稍微看一些源码，给自己弄的一知半解的，所以今天终于内心沉了下来，准备自己看看源码按照自己思路整理一下handler的实现。 handler是什么我就不多说了。。如果这个都不知道那就别往下看了。闲话短说，直接开始，我们一般使用handler都是直接使用内部类的方式 1234567Handler handler=new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); &#125;&#125;; 这样，然后handleMessage更新ui信息。 说到handler不得不说其他几个类了。 Message 意为消息，发送到Handler进行处理的对象，携带描述信息和任意数据。 MessageQueue 意为消息队列，Message的集合。 Looper 有着一个很难听的中文名字，消息泵，用来从MessageQueue中抽取Message，发送给Handler进行处理。 Handler 处理Looper抽取出来的Message。 ​ 我们可以这样理解这四个东西。 首先线程调用Looper.prepare()方法，获取当前线程绑定的Looper对象，如果当前线程存在了Looper对象，则会抛出异常（Only one Looper may be created per thread） 之所以在主线程我们自己没有调用Looper.prepare()方法是因为在ActivityThread初始化的时候会自己初始化一个Looper对象。 123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; ThreadLocal不用多说，线程私有的所以没有Looper对象 的话会自己在本线程添加一个Looper对象。我们看下这个方法 Looper(quitAllowed) 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 初始化一个消息队列，并且获取当前的线程。 然后调用Looper.loop()方法，看一下源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); &#125; final MessageQueue queue = me.mQueue;/、拿到消息队列 // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn&apos;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; 可以看到我们如果不调用Looper.prepare方法的话则会抛出异常， 123public static @Nullable Looper myLooper() &#123; return sThreadLocal.get();&#125; 通过myLooper()方法获取线程中的looper对象。 final MessageQueue queue = me.mQueue;拿到消息队列 然后看源码很容易就可以知道进入一个死循环，从消息队列中源源不断的拿到信息， 1msg.target.dispatchMessage(msg); 这个代码很重要，尤其这个方法dispatchMessage（）可是点击这个方法发现找不到，我就很奇怪，难道这个方法不在looper类里面？于是看了一下handler的源码发现确实是这样。 我们先把这个放着块，等会再看。 看看handler的构造方法。 123public Handler() &#123; this(null, false);&#125; 123public Handler(Looper looper) &#123; this(looper, null, false);&#125; 123public Handler(Callback callback) &#123; this(callback, false);&#125; 123public Handler(Looper looper, Callback callback) &#123; this(looper, callback, false);&#125; 123public Handler(boolean async) &#123; this(null, async);&#125; 这么多的构造方法。。但是他们都使用了this，指向了最终的也是每次初始化都会调用到的构造方法 12345678910111213141516171819public Handler(Callback callback, boolean async) &#123; if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 从源码我们可以看到。。在这里handler里面的looper对象得到了绑定，拿到之前looper的对象，如果这个looper对象为空的话则会抛出异常，让你调用Looper.prepare()方法。 然后就是消息队列的关联。然后我们看源码可以发现，，这里面就不贴了太多了。。自己看也行，发现好多方法比如postAtTime（）最终都是调用的方法sendMessageAtTime（）； 12345678910public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; 返回的是这个方法 enqueueMessage(queue, msg, uptimeMillis); 再看看这个方法 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 1msg.target = this;就是这个方法，是不是有点眼熟， msg.target.dispatchMessage(msg); 没错在这里把msg.target 赋值成了handler本身，这样就关联起来了。所以之前的那个方法在handler里面可以找到 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 怎么样很熟悉吧 handleMessage(msg);这个方法就是我们最终回调自己写的方法。我们可以看到他是一个空方法。。因为要自己完成接下来的事情。 12public void handleMessage(Message msg) &#123;&#125; 其中有个问题应该有人注意到了为什么那个消息队列的死循环存在主线程中还不会造成ANR？因为我们的任何点击事件，各种处理都是有这个循环来做的，也就是说我们之所以造成了ANR是因为自己的操作不当导致了Looper.loop()方法阻塞。。而不是 Looper.loop()阻塞了主线程。。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Collction接口集合]]></title>
    <url>%2F2017%2F07%2F22%2FCollction%E6%8E%A5%E5%8F%A3%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[如图所示可以清楚的看到实现Collection接口的集合类。一目了然。 List我们先从最常见的List子接口来看。 ArrayList这是我们刚开始学java最最经常用到的结合类了，他支持List接口的全部功能，而且看他的名字就知道他的底层是基于数组实现的一个List类。 1List&lt;String&gt; list = new ArrayList&lt;&gt;(initalCapacity：6); 如上所示我们初始化了一个长度为6的List。 通过观察源码可以发现 12345678910public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+ initialCapacity); &#125;&#125; 当我们在构造方法中传入数值的时候他会初始化我们自定义长度的一个数组。如果为负数则抛出异常。 如果不指定参数的话则调用默认的构造函数 123public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 1private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; 看代码就看出来了。初始化一个长度为0的数组。 private static final int DEFAULT_CAPACITY = 10; 看出来了默认大小为10 123456789public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // 数组的大小增加1 elementData[size++] = e; return true; &#125; ensureCapacityInternal方法就是确保数组拥有足够的大小来装填货物。 由此就可以知道了ArrayList是一个动态扩展的数组 Vector它和ArrayList差不多。只不过他是线程安全的，之所以是线程安全的是因为他的操作数据的方法都加上了关键字synchronized，所以他的性能很差。。一般不会使用。 Vector和ArrayList的区别： ArrayList是线程不安全的，Vector是线程安全的。 Vector的性能比ArrayList差。 ArrayList每次动态扩大只增加本身的50%，而Vector会增加一倍 ​ Stack他是Vector的子类，所以也是线程安全的，但是性能较差，通常用他模拟实现栈这个数据结构，即先入后出。 他有几个常见方法 empty() 判断是否为空 peek() 查看栈顶部的对象，但是不移除他 pop()移除栈顶的对象，并且返回他 push()把对象压到栈顶 search(object o) 返回对象在栈的位置。注意他的基数是1,即从1开始 ​ LinkedList它实现了List接口之外还实现了Deque接口，看名字可以看出来他的底部实现和ArrayList完全不一样，他是使用链表实现的，因此在随机访问集合元素的时候性能很差，但是在插入删除元素的时候性能很好，和ArrayList各有千秋，互有利弊。由于实现了Deque接口所以他也有双端队列的特性所以新增加了几种方法 1234567891011121314void addFirst(E e):将指定元素插入此列表的开头。void addLast(E e): 将指定元素添加到此列表的结尾。E getFirst(E e): 返回此列表的第一个元素。E getLast(E e): 返回此列表的最后一个元素。boolean offerFirst(E e): 在此列表的开头插入指定的元素。boolean offerLast(E e): 在此列表末尾插入指定的元素。E peekFirst(E e): 获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。E peekLast(E e): 获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。E pollFirst(E e): 获取并移除此列表的第一个元素；如果此列表为空，则返回 null。E pollLast(E e): 获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。E removeFirst(E e): 移除并返回此列表的第一个元素。boolean removeFirstOccurrence(Objcet o): 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。E removeLast(E e): 移除并返回此列表的最后一个元素。boolean removeLastOccurrence(Objcet o): 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。 注意他也是非线程安全的。 setHashSetHashSet是Set接口的典型实现，实现了Set接口中的所有方法，并没有添加额外的方法，大多数时候使用Set集合时就是使用这个实现类。HashSet按Hash算法来存储集合中的元素。因此具有很好的存取和查找性能。 1.不能保证元素的排列顺序，顺序可能与添加顺序不同，顺序也有可能发生变化。2.HashSet不是同步的，如果多个线程同时访问一个HashSet，则必须通过代码来保证其同步。3.集合元素值可以是null。 他判断两个元素是否相等有个特点就是两个对象的equals方法相等，并且他的对象的hashCode方法也是相等才可以 所以有四种情况 1.如果有两个元素通过equal()方法比较返回false，但它们的hashCode()方法返回不相等，HashSet将会把它们存储在不同的位置。 2.如果有两个元素通过equal()方法比较返回true，但它们的hashCode()方法返回不相等，HashSet将会把它们存储在不同的位置。 3.如果两个对象通过equals()方法比较不相等，hashCode()方法比较相等，HashSet将会把它们存储在相同的位置，在这个位置以链表式结构来保存多个对象。这是因为当向HashSet集合中存入一个元素时，HashSet会调用对象的hashCode()方法来得到对象的hashCode值，然后根据该hashCode值来决定该对象存储在HashSet中存储位置。 4.如果有两个元素通过equal()方法比较返回true，但它们的hashCode()方法返回true，HashSet将不予添加。 LinkedHashSetLinkedHashSet是HashSet对的子类，但是他使用链表维护元素的次序，使得元素是以插入的顺序来保存的。 但是由于插入顺序的保证，所以性能没有HashSet高。但是它依旧不能有重复元素。 其实HashSet的实质是一个HashMap。HashSet的所有集合元素，构成了HashMap的key，其value为一个静态Object对象。因此HashSet的所有性质，HashMap的key所构成的集合都具备。 比如keyset方法返回一个set集合。 TreeSetTreeSet是SortedSet接口的实现类，正如SortedSet名字所暗示的，TreeSet可以确保集合元素处于排序状态。此外，TreeSet还提供了几个额外的方法。 12345678comparator():返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的自然顺序，则返回null。first():返回此 set 中当前第一个（最低）元素。last(): 返回此 set 中当前最后一个（最高）元素。lower(E e):返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。higher(E e):返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。subSet(E fromElement, E toElement):返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）。headSet(E toElement):返回此 set 的部分视图，其元素小于toElement。tailSet(E fromElement):返回此 set 的部分视图，其元素大于等于 fromElement。 TreeSet支持两种排序方法：自然排序和定制排序。在默认情况下，TreeSet采用自然排序。 自然排序 Java提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法,该方法返回一个整数值，实现该接口的类必须实现该方法，实现了该接口的类的对象就可以比较大小了。当一个对象调用该方法与另一个对象比较时，例如obj1.compareTo(obj2),如果该方法返回0，则表明两个对象相等；如果该方法返回一个整数，则表明obj1大于obj2;如果该方法返回一个负整数，则表明oj1小于obj2。 TreeSet会调用集合中元素所属类的compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序排列，即把通过compareTo(Object obj)方法比较后比较大的的往后排。这种方式就是自然排序。 Java的一些常用类已经实现了Comparable接口，并提供了比较大小的标准。例如，String按字符串的UNICODE值进行比较，Integer等所有数值类型对应的包装类按它们的数值大小进行比较。除了这些已经实现Comparable接口类之外，如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable接口，否则就会出现异常。注意：TreeSet中只能添加同一种类型的对象，否则无法比较，会出现异常。 定制排序 TreeSet的自然排序是根据集合元素中compareTo(Object obj)比较的大小，以升序排列。 该接口包含一个int compare(T o1,T o2)方法，该方法用于比较o1,o2的大小：如果该方法返回正整数，则表明o1大于o2；如果该方法返回0，则表明o1等于o2;如果该方法返回负整数，则表明o1小于o2。 注意 如果排序之后改变了TreeSet的值则他不会自动再次排序 TreeSet中判断集合元素相等对于TreeSet集合而言，判断两个对象是否相等的唯一标准是：两个对象通过compareTo(Object obj)方法比较是否返回0——如果通过compareTo(Object obj)方法比较返回0，TreeSet则会认为它们相等，不予添加入集合内；否则就认为它们不相等，添加到集合内。 EnumSetEnumSet是一个专为枚举类设计的集合类，EnumSet中的所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显示或隐式地指定。EnumSet的集合元素也是有序的，EnumSet以枚举值在EnumSet类内的定义顺序来决定集合元素的顺序。 这个集合真的不咋常用，，他是线程不安全的。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android四大组件-Broadcast]]></title>
    <url>%2F2017%2F07%2F20%2FAndroid%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Broadcas%2F</url>
    <content type="text"><![CDATA[BroadcastReceiver我们自定义的BroadcastReceiver需要继承BroadcastReceiver这个抽象基类，并且实现抽象方法onReceive(context, intent)。这个方法也是运行在UI线程的，所以也不要在这个方法中作过多了耗时操作。。不然就ANR了。。 例子 12345678class MyBroadcastReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent) &#123; Log.d(&quot;MyBroadcastReceiver:&quot;,intent.getStringExtra(&quot;name&quot;)); &#125;&#125; 广播的注册类型分为两种，一种是静态注册一种是动态注册 动态注册动态注册时，无须在AndroidManifest中注册组件。直接在代码中通过调用Context的registerReceiver函数，可以在程序中动态注册BroadcastReceiver。registerReceiver的定义形式如下： 12345678910111213141516171819202122232425262728293031323334public class MainActivity extends Activity &#123; private MyBroadcastReceiver receiver; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); IntentFilter intentFilter=new IntentFilter(); intentFilter.addAction(&quot;MyBroadcastReceiver&quot;); receiver=new MyBroadcastReceiver(); registerReceiver(receiver,intentFilter); Intent intent=new Intent(); intent.setAction(&quot;MyBroadcastReceiver&quot;); intent.putExtra(&quot;name&quot;,&quot;name&quot;); sendBroadcast(intent); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(receiver); &#125; class MyBroadcastReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent) &#123; Log.d(&quot;MyBroadcastReceiver:&quot;,intent.getStringExtra(&quot;name&quot;)); &#125; &#125;&#125; 当此Activity实例化时，会动态将MyBroadcastReceiver注册到系统中。当此Activity销毁时，动态注册的MyBroadcastReceiver将不再接收到相应的广播。 切记一定要进行解绑定unregisterReceiver(mBroadcastReceiver)。 静态注册直接在配置文件AndroidManifest.xml进行注册。 123456789&lt;receiver android:enabled=[&quot;true&quot; | &quot;false&quot;]android:exported=[&quot;true&quot; | &quot;false&quot;]android:icon=&quot;drawable resource&quot;android:label=&quot;string resource&quot;android:name=&quot;string&quot;android:permission=&quot;string&quot;android:process=&quot;string&quot; &gt;. . .&lt;/receiver&gt; 其中，需要注意的属性android:exported ——此broadcastReceiver能否接收其他App的发出的广播，这个属性默认值有点意思，其默认值是由receiver中有无intent-filter决定的，如果有intent-filter，默认值为true，否则为false。（同样的，activity/service中的此属性默认值一样遵循此规则）同时，需要注意的是，这个值的设定是以application或者application user id为界的，而非进程为界（一个应用中可能含有多个进程）；android:name —— 此broadcastReceiver类名；android:permission ——如果设置，具有相应权限的广播发送方发送的广播才能被此broadcastReceiver所接收；android:process ——broadcastReceiver运行所处的进程。默认为app的进程。可以指定独立的进程（Android四大基本组件都可以通过此属性指定自己的独立进程） 广播的类型 Normal Broadcast：普通广播 此处将普通广播界定为：开发者自己定义的intent，以context.sendBroadcast_”AsUser”(intent, …)形式。具体可以使用的方法有：sendBroadcast(intent)/sendBroadcast(intent, receiverPermission)/sendBroadcastAsUser(intent, userHandler)/sendBroadcastAsUser(intent, userHandler,receiverPermission)。普通广播会被注册了的相应的感兴趣（intent-filter匹配）接收，且顺序是无序的。如果发送广播时有相应的权限要求，BroadCastReceiver如果想要接收此广播，也需要有相应的权限。 System Broadcast: 系统广播 Android系统中内置了多个系统广播，只要涉及到手机的基本操作，基本上都会发出相应的系统广播。如：开启启动，网络状态改变，拍照，屏幕关闭与开启，点亮不足等等。每个系统广播都具有特定的intent-filter，其中主要包括具体的action，系统广播发出后，将被相应的BroadcastReceiver接收。系统广播在系统内部当特定事件发生时，有系统自动发出。 Ordered broadcast：有序广播 有序广播的有序广播中的“有序”是针对广播接收者而言的，指的是发送出去的广播被BroadcastReceiver按照先后循序接收。有序广播的定义过程与普通广播无异，只是其的主要发送方式变为：sendOrderedBroadcast(intent, receiverPermission, …)。 对于有序广播，其主要特点总结如下： 1&gt;多个具当前已经注册且有效的BroadcastReceiver接收有序广播时，是按照先后顺序接收的，先后顺序判定标准遵循为：将当前系统中所有有效的动态注册和静态注册的BroadcastReceiver按照priority属性值从大到小排序，对于具有相同的priority的动态广播和静态广播，动态广播会排在前面。 2&gt;先接收的BroadcastReceiver可以对此有序广播进行截断，使后面的BroadcastReceiver不再接收到此广播，也可以对广播进行修改，使后面的BroadcastReceiver接收到广播后解析得到错误的参数值。当然，一般情况下，不建议对有序广播进行此类操作，尤其是针对系统中的有序广播。 Sticky Broadcast：粘性广播(在 android 5.0/api 21中deprecated,不再推荐使用，相应的还有粘性有序广播，同样已经deprecated)。 既然已经deprecated，此处不再多做总结。 Local Broadcast：App应用内广播（此处的App应用以App应用进程为界 由前文阐述可知，Android中的广播可以跨进程甚至跨App直接通信，且注册是exported对于有intent-filter的情况下默认值是true，由此将可能出现安全隐患如下： 1.其他App可能会针对性的发出与当前App intent-filter相匹配的广播，由此导致当前App不断接收到广播并处理； 2.其他App可以注册与当前App一致的intent-filter用于接收广播，获取广播具体信息。 无论哪种情形，这些安全隐患都确实是存在的。由此，最常见的增加安全性的方案是： 1.对于同一App内部发送和接收广播，将exported属性人为设置成false，使得非本App内部发出的此广播不被接收； 2.在广播发送和接收时，都增加上相应的permission，用于权限验证； 3.发送广播时，指定特定广播接收器所在的包名，具体是通过intent.setPackage(packageName)指定在，这样此广播将只会发送到此包中的App内与之相匹配的有效广播接收器中。 App应用内广播可以理解成一种局部广播的形式，广播的发送者和接收者都同属于一个App。实际的业务需求中，App应用内广播确实可能需要用到。同时，之所以使用应用内广播时，而不是使用全局广播的形式，更多的考虑到的是Android广播机制中的安全性问题。 相比于全局广播，App应用内广播优势体现在： 1.安全性更高； 2.更加高效。 ​ 1).对于静态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是ReceiverRestrictedContext； 2).对于全局广播的动态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是Activity Context； 3).对于通过LocalBroadcastManager动态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是Application Context。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android四大组件-Activity]]></title>
    <url>%2F2017%2F07%2F20%2FAndroid%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-Activity%2F</url>
    <content type="text"><![CDATA[Activity的生命周期 正常Activity的启动经历以下过程 onCreat Activity的创建，做一切初始化的操作，这个时候Activity还不可见。 onStart Activity已经展现在前台页面，但是还是不可以交互。 onResume Activity可见，并且可以交互。可以做一些onPause或者onStop释放资源的的回收操作 Activity进入运行状态 onPause Activity进入后台之前可见的时候做一些回收工作，只有当前Activity的onpause方法执行完事之后下个Activity的onResume方法才会执行 onStop Activity不可见。回收操作，不能太过于耗时。 onDestory Activity销毁，可以做一些大量的回收操作 ​ 如果ACtivity在进入onStop方法后未被销毁，而又被展现到前台页面则会调用onRestart()方法 onCreate的方法 123protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState);&#125; 其中savedInstanceState是一个Bundle类型的参数，会在onPause()或onStop()之前执行，在她和map差不多，都是键值对形式，我们可以在Activity快被销毁的时候储存一些东西 调用方法 1234@Overrideprotected void onSaveInstanceState(Bundle outState) &#123; super.onSaveInstanceState(outState);&#125; 在这里进行存储。 onRestoreInstanceState 这个方法会在Activity真正被销毁的时候才会执行。比如按下bcak键。 Activity的四种LaunchMode standard 模式 这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。使用场景：大多数Activity。 singleTop 模式 如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。使用场景如新闻类或者阅读类App的内容页面。 singleTask 模式 如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。使用场景如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。 singleInstance 模式 在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。使用场景如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -&gt; B (singleInstance) -&gt; C，完全退出后，在此启动，首先打开的是B。 如何判断一个Activity加载完毕。使用onResume方法？ 错。。这个不知道为啥就是错误的， 因为之前做过一个播放器，里面的mediaController是一个自定义的Popuwindow，需要加载玩Activity就显示，但是我放在onResume里面总是报错，显示窗口泄露，找不到Activity于是高了半天才发现这个方法。这个方法表示Activity加载完毕，可以做一些加载完毕就做得事情，如popuwindow的展示，测量加载完毕的View长度，如果在其他方法里面测量的话会导致长度错误或者为0 12345@Overridepublic void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); &#125; 这个方法是屏幕的旋转。当屏幕旋转的时候可以在这个方法进行操作。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA FIle的排序]]></title>
    <url>%2F2017%2F07%2F19%2FJAVA-FIle%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF%2F</url>
    <content type="text"><![CDATA[12Collections.sort();这个方法 123456789101112131415private List&lt;File&gt; sortFileList(List&lt;File&gt; list) &#123; Collections.sort(list, new Comparator&lt;File&gt;() &#123; @Override public int compare(File o1, File o2) &#123; if (o1.isDirectory() &amp;&amp; o2.isFile()) return -1; if (o1.isFile() &amp;&amp; o2.isDirectory()) return 1; return o1.getName().compareToIgnoreCase(o2.getName()); &#125; &#125;); return list; &#125; 实现 Comparator接口。就可以实现排序了 同样对于filelist这个方法也有一个FileFilter的接口传入，比如一些隐藏文件我们可以直接让他不显示 1234567891011121314file.listFiles(new FileFilter() &#123; @Override public boolean accept(File pathname) &#123; if(pathname.getName().startsWith(&quot;.&quot;))&#123; return false; &#125;else&#123; return true; &#125; &#125;&#125;); 这样就可以了。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试]]></title>
    <url>%2F2017%2F07%2F15%2F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能优化]]></title>
    <url>%2F2017%2F05%2F11%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[布局优化尽量少用嵌套，能用linearLayout和frameLayout解决最好不要用RelativeLayout。 因为view的绘制会花更多的时间。 使用 和ViewStub 不用多说，大家应该很熟悉，可以指定一个布局文件到当前布局中，比如toolbar的设置，很多的app 中activity的toolbar都是相同的，没必要每个都写，这个标签是可以有id 的，并且可以设置宽高。其他的不行 它一般和标签一起使用用来减少布局的层数 ViewStub 他继承于view，并且非常轻量级，宽高都是0，所以它本身不参与绘制过程。它的意义在于在需要的时候加载所需的布局文件。比如一些隐藏的布局，在需要的时候显示！ 12345678&lt;ViewStub android:inflateId=&quot;@id/inflateid&quot; android:id=&quot;@+id/viewstub_demo_image&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;5dip&quot; android:layout_marginRight=&quot;5dip&quot; android:layout=&quot;@layout/viewstub_demo_image_layout&quot;/&gt; inflateid是加载布局的根元素的id，viewstub_demo_image是viewStub的id， 1((viewstub)findviewbyId(R.id.viewstub_demo_image)).setVisibility(View.Visible); 1View myview=((ViewStub)findViewById(R.id.viewstub_demo_image)).infalte(); 这时候布局会被替换掉，但是目前Viewstub不支持标签 ​ 绘制优化 尽量不要在onDraw方法中进行大量的运算，循环，创建性的布局对象（会频繁调用onDraw方法） 内存泄漏优化不要让静态变量持有禁用activity，会导致activity无法被销毁。或者progressDialog 123private static ProgressDialog dialog; dialog=new ProgressDialog(this); 这个this也对activity有引用，所以无法被销毁。 单利对象— 因为单例模式的对象适合applicantion的生命周期是一样的，所以当有时候我们不去解除绑定的话，activity会一直持有这个单例对象，会导致无法被销毁 属性动画在activity被销毁时要调用 animator.cancle()方法 不要在主线程中去做过多复杂的操作，这些都尽量去异步的放在子线程中去执行。 不然很容易anr，如果产生anr 系统会在/data/anr 目录下创建一个traces.txt文件。通过分析这个文件我们就能分析出ANR产生的原因。 Listview不要在getView方法中进行耗时操作。或者开启大量的异步任务。可以尝试开启硬件加速。和使用viewHolder减少findviewById方法。或者监听话筒状态比如，滑动的时候不要加载图片。分页加载等 线程的优化尽量使用线程池，避免程序中存在大量的THread。线程池可以重用内部的线程，避免了创建和销毁的开销。而且还可以控制线程的最大并发数。避免线程强占系统资源导致阻塞。 杂七杂八不要创建过多的对象，不重要的对象可以使用 软引用和弱引用 不要使用枚举 常量使用 static final修饰 使用Android 特有的数据结构。 SparesArray 和Pair等 缓存采用三级缓存，内存，磁盘，网络 使用静态内部类，不然由于内部类对外存在持有，导致外部类不会被销毁]]></content>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片缓存与bitmap的加载]]></title>
    <url>%2F2017%2F05%2F07%2F%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98%E4%B8%8Ebitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"></content>
      <tags>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[drawable]]></title>
    <url>%2F2017%2F05%2F04%2Fdrawable%2F</url>
    <content type="text"><![CDATA[drawable他是一个图像的概念，不完全是指图片，一般是通过xml文件定义，她是一个抽象类，有着非常多的子类，子类都是直接继承它。 bitmapdrawable 代表一张图片. xml 属性有几个比较常用 src —代表资源id antialias —抗锯齿（开） dither—抖动效果（开）开启会更好的适配 filter —在拉伸等情况下可以更好的显示（开启） gravity—当图片小于容器的时候选择的属性 有很多 mipMap— 一种文理映射，不常用 titleMode—平铺模式 ​ ShapeDrawable 非常常见的drawable shape :有四个属性 rectangle：矩形 oval：椭圆 line ：横线 ring ：圆环 corners :表示shape四个角的角度。只适用于矩形 radius：四个角的角度，优先度低，会被其它属性覆盖 topLeftRadius：左上角 topRightRadius:右上角 bottomLeftRadius：左下角 bottomRightRadius：右下角 ​ gradient 和solid 互斥，表示渐变，而solid表示纯色填充 angle :渐变的角度，默认为0,值必须是45的倍数，0表示从左到右，90表示从上到下 centerX：渐变的中心横坐标 centerY：渐变中心的纵坐标 startColor：渐变变的起始颜色 centerColor：渐变的中间色 endColor：渐变的结束颜色 gradientRadius：渐变半径 useLevel：一半为false，当drawable作为statelistDrawable的时候为true type：渐变类别，linear（线性）radoal（径向渐变）sweep（扫描渐变） ​ solid:填充的颜色，全色填充 stroke:shape的描边 width:描边的宽度 color：描边的颜色 dashWidth：虚线的线段宽度 dashGap：虚线的线段之间的间隔 ​ padding 表示空白，表示包含它的view的空白 size shape的大小 ​ LayerDrawable 层次化的drawable集合，标签为 ,通过item实现叠加效果 StateListDrawable 标签，表示Drawable集合，每个drawable对应着view的一种状态 比如button的点击等等 view的常见状态 state_pressed，表示按下的状态，比如button被按下，但是没有松开 state_focused ,表示view获取了焦点 state_selected,表示选择了view state_checked,表示用户选中的view 一般在checkbox state_enabled,表示view处于可用状态 ​ TransitionDrawable 用于实现两个Drawable之间的淡入淡出效果 insetDrawable 可以将其他Drawable内嵌到自己当中并且可以在四周留出间距 当自己的drawable需要和实际的view有大小区别的时候 scale 根据自己等级 level将指定的Drawable缩放到一定的比例 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;scale android:interpolator= &quot;@android:anim/decelerate_interpolator&quot; android:fromXScale=&quot;0.0&quot; android:toXScale=&quot;1.5&quot; android:fromYScale=&quot;0.0&quot; android:toYScale=&quot;1.5&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:startOffset=&quot;0&quot; android:duration=&quot;10000&quot; android:repeatCount=&quot;1&quot; android:repeatMode=&quot;reverse&quot; /&gt; &lt;/set&gt; &lt;!-- fromXDelta,fromYDelta 起始时X，Y座标,屏幕右下角的座标是X:320,Y:480 toXDelta， toYDelta 动画结束时X,Y的座标 --&gt; &lt;!-- interpolator 指定动画插入器 常见的有加速减速插入器 accelerate_decelerate_interpolator 加速插入器 accelerate_interpolator， 减速插入器 decelerate_interpolator。 fromXScale,fromYScale， 动画开始前X,Y的缩放，0.0为不显示， 1.0为正常大小 toXScale，toYScale， 动画最终缩放的倍数， 1.0为正常大小，大于1.0放大 pivotX， pivotY 动画起始位置，相对于屏幕的百分比,两个都为50%表示动画从屏幕中间开始 startOffset， 动画多次执行的间隔时间，如果只执行一次，执行前会暂停这段时间， 单位毫秒 duration，一次动画效果消耗的时间，单位毫秒， 值越小动画速度越快 repeatCount，动画重复的计数，动画将会执行该值+1次 repeatMode，动画重复的模式，reverse为反向，当第偶次执行时，动画方向会相反。 restart为重新执行，方向不变 --&gt; ​ CliPDrawable 可以通过自己等级来剪裁另一个Drawable clipOrientation表示剪裁的方向 1testClipDrawable.setLevel(3000) level 为0-10000 ，例如3000表示剪裁了30%；]]></content>
      <tags>
        <tag>drawable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[view的工作原理]]></title>
    <url>%2F2017%2F05%2F02%2Fview%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[ViewRoot是对应ViewRootImpl类，他是连接windowmangager和DecorView的纽带。 view的三大绘制流程都是从viewroot开始的，在ActivityThread中，activity对象被创建完成后，会把decorview添加到window中。同时创建vIewrootImpl对象。 view的绘制从viewroot的performTraversals方法开始分别对应 measure，layout，和draw，分别对应 测量宽高 确定view在父容器中的位置 绘制 ​ performTraversals会依次调用perfromMeasure，performLayout,performDraw 方法，这三个方法会完成顶级view的 三个绘制过程，其中的performMeasure会调用measure ，然后再调用onmeasure 然后再onmeasure方法中会继续对子view进行measure过程，这样就遍历了整个view树。 其他两个方法也是类似 DecorView作为顶级的view其实包含一个linearlayout，分为两个部分，一个titlebar和content，所以我们的oncreate方法中是setcontentview而不是setview MeasureSpecmeasureSpec会根据view的layoutparams和父容器施加的规则转换而来 MeasureSpec是一个32位的int值，前两位代表测量模式SpecMode，后面代代表SpecSize测量大小 SpecMode分为三种 UNSPECIFIED 父容器对view的宽高没有任何的限制，要多打给多大，一般出现在系统内部 EXACTLY 精确大小，表示view的大小就是spceSize， 如match_parent，或者精确的一个数值 AT_MOST 父容器给顶了一个大小，view的大小不能超过它，比如wrap_contet ​ 最顶级的view decorview的大小是由他自己的layoutparams和窗口的尺寸决定，而其他的view都是父容器的规则和自身的layoutparams决定。 MeasureSpec一旦确定后 onMeasure就可以确定view的最终宽高 padding代表父容器已经占用的大小，所以实际可用大小为父容器大小减去padding。 1int size=Math.max(0,specSize-padding); view的工作流程———–Measure————layout———–draw measure如果是viewgroup则除了测量自己的大小，还要去遍历调用字view 的measure的方法如果是view则只调用measure view的measure方法是一个final方法，不能被重写而在measrue方法中会调用onMseasure方法。 viewgroup的measure过程viewgroup是抽象类没有实现onMeasure，但是有一个measureChildren方法。 之所以它没有实现测量方法，是因为他需要子类去实现这个方法如linearlayout等，因为每个的布局特性导致他们的测量方法不同。 记住 view的onMeasure过程不是和acitvity同步的，所以在oncreate和onstart或者onresume中无法获取到真正的宽高 所以要使用如下方法调用是比较正确的 通过onWindowFocusChanged方法 12345678public void onWindowFocusChanged(boolean hasFocus)&#123; surper.onWindowFocusChanged(hasFocus); if(hasFocus)&#123; int height=view.getmeasureheight（）； int width=view.getmeasureWidth（）； &#125; &#125; 通过view.post方法 post一个runable投入到消息队列，然后等待Looper调用runable的时候view已经初始化好了 123456789view.post(new runable()&#123; @Override public void run()&#123; // 获取宽高 int height=view.getmeasureheight（）； int width=view.getmeasureWidth（）； &#125;); ​ 通过ViewTreeObserver的回调方法 通过view.measure(int WidthMeasureSpec,int HeightMeasureSpec) match_parent 直接放弃，无法获取 具体的数值 ​ warp_content layoutViewGroup调用layout方法确定自己的位置，当自己的位置确定后他会调用onlayout方法遍历子元素的laout方法，然后子元素在去调用layout方法 layout方法确定本身的位置，onlayout确定子元素的位置 layout方法会通过 setfrme 确定view的四个顶点位置mLeft，mRight,mTop,mbottom.四个点确定了位置也就确定了然后调用onlayout方法 ，它和onmeasure方法一样，viewgroup没有具体的实现， drawdraw的过程遵循四步骤 绘制背景 绘制自己（onDraw） 绘制children（dispatchDraw） 绘制装饰（onDrawScrollBars） View的特殊方法 ——–setWillNotDraw 表示一个view如果不需要绘制则可以设置为ture，这样系统会进行优化。viewgroup会默认的开启这个方法，如果我们的自定义view需要onDraw方法来绘制东西，则我们需要关闭这个方法]]></content>
      <tags>
        <tag>view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[希尔排序]]></title>
    <url>%2F2017%2F04%2F28%2F%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324static void xier()&#123; int i,j,h,v; for (h=1;h==test.length/9;h=h*3+1); for (;h&gt;0;h=h/3)&#123; for (i=h+1;i==test.length;i+=1)&#123; v=test[i]; j=i; while (j&gt;h&amp;&amp;test[j-h]&gt;v) &#123; test[j]=test[j-h]; j-=h; &#125; test[j]=v; &#125; &#125;&#125; 通过设置一个间距在可以在较远的距离进行位置交换，并且不断缩小这个间距知道距离变为1，这个时候的数组已经变得基本有序，最后的一次排序也就成为了插入排序，但是因为数组有序度高所以耗时短、]]></content>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序（冒泡排序，插入排序）]]></title>
    <url>%2F2017%2F04%2F28%2F%E6%8E%92%E5%BA%8F%EF%BC%88%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最常见也是最简单的冒泡排序时间复杂度0（n^2）; 1234567891011for (int i = 0; i &lt; test.length-1; i++) &#123; for (int j = i+1; j &lt; test.length; j++) &#123; if (test[j] &lt; test[i]) &#123; int temp = test[j]; test[j] = test[i]; test[i] = temp; &#125; &#125;&#125; 插入排序； 数据量较小时速度很快。 进行局部排序，一部分一部分来。 123456789101112131415private static void charu() &#123; int v ,j; for (int i=1;i&lt;test.length;i++)&#123; v=test[i]; j=i; while (test[j-1]&gt;v&amp;&amp;j&gt;=1)&#123; test[j]=test[j-1]; j--; &#125; test[j]=v; &#125;]]></content>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序（选择排序）]]></title>
    <url>%2F2017%2F04%2F27%2F%E6%8E%92%E5%BA%8F%EF%BC%88%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[假定第一个就是最小的然后遍历所有后面的数值，一旦比他小就把最小的下标改为它，直到遍历了所有的数据 1234567891011121314151617181920212223242526272829package com.company;public class Main &#123; static int test[] = &#123; 3, 15, 48, 7, 89, 45646, 145, 156, 484, 4, 56, 456, 18478, &#125;; public static void main(String[] args) &#123; for (int i = 0; i &lt; test.length - 1; i++) &#123; int min = i; for (int j = i+1; j &lt; test.length; j++) &#123; if (test[j] &lt; test[min]) &#123; min = j; &#125; &#125; int temp = test[min]; test[min] = test[i]; test[i] = temp; &#125; for (int i = 0; i &lt; test.length; i++) &#123; System.out.print(test[i]+&quot;,&quot;); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8-行为参数传递代码]]></title>
    <url>%2F2017%2F04%2F22%2Fjava8-%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[handler和messsage]]></title>
    <url>%2F2017%2F04%2F19%2Fhandler%E5%92%8Cmesssage%2F</url>
    <content type="text"><![CDATA[handler和message的原理这里总结一下handler和message的原理和需要注意的一些问题！ 首先安卓的主线程是不安全的，我们的耗时操作需要在子线程运行 ​ 于是产生了handler和message 这里需要记一下 handler的创建是不能再子线程的，除非在子线程创建之前调用了 1Looper.prepare(); 其实到这里就应该明白了，我们的主线程，app启动的时候在activitythread里就已经初始化了一个 Looper.prepareMainLooper(); 因为activity要执行attach ，而attach则会初始化这些东西。似的looper处于无限循环等待的状态中 一个线程只能创建一个looper， 123456public static final void prepare() &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); &#125; sThreadLocal.set(new Looper()); &#125; 从源码可以看出 如果线程不为空的话会抛出这个异常。 然而我们的message是如何通过handler把自己消息传送到handlerMessage的方法中的呢？ 这就涉及到了sendMessageAtTime（）的方法。 123456789101112131415public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; boolean sent = false; MessageQueue queue = mQueue; if (queue != null) &#123; msg.target = this; sent = queue.enqueueMessage(msg, uptimeMillis); &#125; else &#123; RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); &#125; return sent; &#125; 一个message对象和时间，时间表示发送消息的时间，若不是sendMessageDelayed 则时间为0，立即发送，然后将msg发送到MessageQueue的enqueueMessage方法中，他是一个消息队列，这个方法实在looper的构造函数中创建的 12345678910111213141516171819202122232425262728293031323334final boolean enqueueMessage(Message msg, long when) &#123; if (msg.when != 0) &#123; throw new AndroidRuntimeException(msg + &quot; This message is already in use.&quot;); &#125; if (msg.target == null &amp;&amp; !mQuitAllowed) &#123; throw new RuntimeException(&quot;Main thread not allowed to quit&quot;); &#125; synchronized (this) &#123; if (mQuiting) &#123; RuntimeException e = new RuntimeException(msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(&quot;MessageQueue&quot;, e.getMessage(), e); return false; &#125; else if (msg.target == null) &#123; mQuiting = true; &#125; msg.when = when; Message p = mMessages; if (p == null || when == 0 || when &lt; p.when) &#123; msg.next = p; mMessages = msg; this.notify(); &#125; else &#123; Message prev = null; while (p != null &amp;&amp; p.when &lt;= when) &#123; prev = p; p = p.next; &#125; msg.next = prev.next; prev.next = msg; this.notify(); &#125; &#125; return true; &#125; 在 msg.when = when; 开始如果当前处理的消息为空或者时间为0.或者时间小于当前待处理消息的时间，则把当前的消息插入队列，如果时间为零的话，则把这个mMessage赋值为新的msg，然后这个msg的next指向刚才的message，这样就把消息插在头部了 消息的出队123456789101112131415161718192021public static final void loop() &#123; Looper me = myLooper(); MessageQueue queue = me.mQueue; while (true) &#123; Message msg = queue.next(); // might block if (msg != null) &#123; if (msg.target == null) &#123; return; &#125; if (me.mLogging!= null) me.mLogging.println( &quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what ); msg.target.dispatchMessage(msg); if (me.mLogging!= null) me.mLogging.println( &quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); msg.recycle(); &#125; &#125; &#125; 一个死循环，它的简单逻辑就是如果当前MessageQueue中存在mMessages(即待处理消息)，就将这个消息出队，然后让下一条消息成为mMessages，否则就进入一个阻塞状态，一直等到有新的消息入队， msg.target.dispatchMessage(msg); 注意这个方法的dispatchMessage， 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; 这个就是mCallback的调用然后handlerMessage。 12345另外除了发送消息之外，我们还有以下几种方法可以在子线程中进行UI操作：1. Handler的post()方法2. View的post()方法3. Activity的runOnUiThread()方法 handler的post方法其实就是把runnable传入callback中然后再主线程中 调用run方法 view的post是直接调用handler的post方法 Activity的runOnUiThread()方法 1234567public final void runOnUiThread(Runnable action) &#123; if (Thread.currentThread() != mUiThread) &#123; mHandler.post(action); &#125; else &#123; action.run(); &#125; &#125; 如果当前的线程不是主线程的话则会自动调用handler的post方法 实际可以这么理解 Message 意为消息，发送到Handler进行处理的对象，携带描述信息和任意数据。 MessageQueue 意为消息队列，Message的集合。 Looper 有着一个很难听的中文名字，消息泵，用来从MessageQueue中抽取Message，发送给Handler进行处理。 Handler 处理Looper抽取出来的Message。 （抄来的，很好理解）]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bitmap上写字]]></title>
    <url>%2F2017%2F04%2F17%2Fbitmap%E4%B8%8A%E5%86%99%E5%AD%97%2F</url>
    <content type="text"><![CDATA[网易云的锁屏歌词是如何实现的？？学长突然问了我这个问题，是啊，怎麼实现的呢？貌似google并没有给我们这个接口，可是这些巨头却实现了，考虑了半天，也百度 google了一会，最后才知道 这些歌词是通过bitmap的实时渲染文字更新呢，可是这又有个问题，如果使用bitmap的话，那么多图片肯定会内存爆炸的！ 所以这里用到了个软引用（我觉得弱引用也可以） 所以话不过说，开写！ 界面非常简单就一个按钮和图片 可是我们要实现歌词的实时变换，怎麼实现呢。。我这就简化了下，用了个定时气 timer； 没个3秒钟就会自己自动渲染。 1234567891011imageView = (ImageView) findViewById(R.id.img);button = (Button) findViewById(R.id.button);button.setOnClickListener(this);list = new ArrayList&lt;&gt;();list.add(&quot;陪你把沿路感想活出了答案&quot;);list.add(&quot;陪你把独自孤单变成了勇敢&quot;);list.add(&quot;一次次失去又重来 我没离开&quot;);list.add(&quot;陪伴是 最长情的告白&quot;);list.add(&quot;陪你把想念的酸 拥抱成温暖&quot;);list.add(&quot;未来多漫长 再漫长 还有期待&quot;);list.add(&quot;陪伴你 一直到 故事给说完&quot;); list 就是歌词了，这里简化了 12345678910111213141516171819202122232425@Override public void onClick(View v) &#123; final Timer timer = new Timer(); final Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.ic_b33); timer.schedule(new TimerTask() &#123; int i = 0; @Override public void run() &#123; i++; if (i == list.size()) &#123; //timer.cancel(); i=0; &#125; Message message = new Message(); message.obj = getNewBitMap(list.get(i), bitmap,i); handler.sendMessage(message); &#125; &#125;, 200, 3000); &#125; 这是点击事件 这是 渲染图片的方法。 123456789101112131415161718192021222324public Bitmap getNewBitMap(String text, Bitmap bitmap,int i) &#123; if (mImageCache.containsKey(i))&#123; if (mImageCache.get(i).get()!=null)&#123; Log.d(&quot;===&quot;,&quot;return&quot;); return mImageCache.get(i).get(); &#125; &#125; WindowManager windowManager=getWindowManager(); Bitmap newBitmap = Bitmap.createBitmap(windowManager.getDefaultDisplay().getWidth(),windowManager.getDefaultDisplay().getHeight(), Bitmap.Config.ARGB_4444); Canvas canvas = new Canvas(newBitmap); canvas.drawBitmap(bitmap, 0, 0, null); TextPaint textPaint = new TextPaint(); textPaint.setAntiAlias(true); textPaint.setTextSize(160F); StaticLayout sl = new StaticLayout(text, textPaint, newBitmap.getWidth(), Layout.Alignment.ALIGN_CENTER, 1.0f, 0.0f, false); canvas.translate(6, 40); sl.draw(canvas); mImageCache.put(i,new SoftReference&lt;Bitmap&gt;(newBitmap)); return newBitmap; &#125; 还有通过hander 更新画面 123456789Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; Bitmap bitmap = (Bitmap) msg.obj; imageView.setImageBitmap(bitmap); super.handleMessage(msg); &#125; &#125;; 这里的图片方法就比较好理解了，首先new一个新的bitmap对象，它代表新的要加载的bitmap，它是用来加载原来的bitmap和文字的，然后文字卸载上面，填到map中，如果他因为内存原因被回收了，则重新渲染这个图片。。非常好理解！ http://i4.buimg.com/567571/a15846a46351cfc0.jpg http://i4.buimg.com/567571/e0299fd22afae178.jpg]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svg]]></title>
    <url>%2F2017%2F04%2F12%2Fsvg%2F</url>
    <content type="text"><![CDATA[SVG 意为可缩放矢量图形（Scalable Vector Graphics），是使用 XML 来描述二维图形和绘图程序的语言；使用 SVG 的优势在于： 1.SVG 可被非常多的工具读取和修改（比如记事本）,由于使用xml格式定义，所以可以直接被当作文本文件打开，看里面的数据； 2.SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强，SVG 图就相当于保存了关键的数据点，比如要显示一个圆，需要知道圆心和半径，那么SVG 就只保存圆心坐标和半径数据，而平常我们用的位图都是以像素点的形式根据图片大小保存对应个数的像素点，因而SVG尺寸更小； 3.SVG 是可伸缩的，平常使用的位图拉伸会发虚，压缩会变形，而SVG格式图片保存数据进行运算展示，不管多大多少，可以不失真显示； 4.SVG 图像可在任何的分辨率下被高质量地打印; 5.SVG 可在图像质量不下降的情况下被放大; 6.SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图）; 7.SVG 可以与 Java 技术一起运行; 8.SVG 是开放的标准; 9.SVG 文件是纯粹的 XML; 指令12345678910M = moveto 相当于 android Path 里的moveTo(),用于移动起始点 L = lineto 相当于 android Path 里的lineTo()，用于画线 H = horizontal lineto 用于画水平线 V = vertical lineto 用于画竖直线 C = curveto 相当于cubicTo(),三次贝塞尔曲线 S = smooth curveto 同样三次贝塞尔曲线，更平滑 Q = quadratic Belzier curve quadTo()，二次贝塞尔曲线 T = smooth quadratic Belzier curveto 同样二次贝塞尔曲线，更平滑 A = elliptical Arc 相当于arcTo()，用于画弧 Z = closepath 相当于closeTo(),关闭path]]></content>
      <tags>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法基础]]></title>
    <url>%2F2017%2F04%2F10%2F%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[searchview]]></title>
    <url>%2F2017%2F04%2F10%2Fsearchview%2F</url>
    <content type="text"><![CDATA[toolbar toolbar自带的搜索框其实非常实用 首先就是穿件menu的菜单！ 1234567891011121314@Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.search, menu); SearchManager searchManager = (SearchManager) getSystemService(Context.SEARCH_SERVICE); searchView = (SearchView) menu.findItem(R.id.ab_search).getActionView(); searchView.setSearchableInfo( searchManager.getSearchableInfo(getComponentName())); searchView.setOnQueryTextListener(this); return true; &#125; search.xml (menu)1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;item android:id=&quot;@+id/ab_search&quot; android:orderInCategory=&quot;60&quot; android:title=&quot;action_search&quot; app:actionViewClass=&quot;android.support.v7.widget.SearchView&quot; app:showAsAction=&quot;ifRoom&quot;/&gt;&lt;/menu&gt; xml12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;searchable xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:label=&quot;@string/app_name&quot; android:imeOptions=&quot;actionSearch&quot; android:hint=&quot;搜索&quot; /&gt; 上面这三行代码就是为了创建菜单而实现的。 12searchView.setOnQueryTextListener(this);实现setOnQueryTextListener接口判断数据的变化 和listview或者recycleview实现实时数据的搜索！这个刚开始觉得挺难的，试着写了一下，其实还可以！ 这需要adapter实现 filter的接口 重写 publishResults 和performFiltering方法！ 1234567891011121314151617181920212223242526@Override public Filter getFilter() &#123; return new Filter() &#123; @Override protected FilterResults performFiltering(CharSequence constraint) &#123; FilterResults results = new FilterResults(); List&lt;Map&lt;String, String&gt;&gt; datalist = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; mlist.size(); i++) &#123; if (mlist.get(i).get(&quot;title&quot;).contains(constraint)) &#123; datalist.add(mlist.get(i)); &#125; &#125; results.values = datalist; return results; &#125; @Override protected void publishResults(CharSequence constraint, FilterResults results) &#123; list=((List&lt;Map&lt;String, String&gt;&gt;) results.values); notifyDataSetChanged(); &#125; &#125;; 这里需要注意一下！因为你的数据实在实时刷新的，所以一旦回删数据的时候会导致数据恢复不了，所以初始化数据的时候一定要注意初始化一个 mdatalist 用来存放所有的数据，list用来实时更新加载数据！]]></content>
      <tags>
        <tag>toolbar的搜索框</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android头像缓存]]></title>
    <url>%2F2017%2F04%2F08%2FAndroid%E5%A4%B4%E5%83%8F%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[其实没那么难！之前一直抵触写这些东西，而且很多都是直接百度的，根本没有去想怎么回事。这不，今天下午有遇到这些问题了，无奈找了个网上的例子，看似很简单，可是使用中却发现根本不是那回事！ 当我们遇到listview 或者recycleview加载图片或者头像的时候 如果直接在getview的方法里面写一个异步的方法来加载图片的话写起来是简单，但是这样会导致item每次被重绘的时候都会去执行这个异步任务！导致app变卡，以及耗费流量等等有损用户体验的事情！ 于是今天下午自己逼着自己写了一个！才发现其实根本没有那么难。。。 思想其实就是每次加载的时候去你的本地文件夹判断是否有这个图片，如果有就直接加载，如果没有就去网络获取加载，在保存到本地！ 123456789String path=context.getExternalFilesDir(Environment.DIRECTORY_PICTURES).getPath(); imageView.setBackgroundResource(R.drawable.ic_img_load); final File file = new File(path + &quot;/iv2ex&quot;); String u = url.replace(&quot;/&quot;, &quot;!&quot;); u = u.replace(&quot;.&quot;, &quot;!&quot;); if (!file.exists()) &#123; file.mkdirs(); &#125; final File f = new File(file, u ); 这是文件夹的判断，如果没有父类文件夹直接创建！，然后记得吧图片的地址给转义下里面的“ /”不然会导致找不到文件。然后如果文件存在直接加载 12345678910if (f.exists()) &#123; try &#123; FileInputStream fos = new FileInputStream(f); Bitmap bitmap = BitmapFactory.decodeStream(fos); Drawable drawable = new BitmapDrawable(bitmap); imageView.setImageDrawable(drawable); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); imageView.setBackgroundResource(R.drawable.ic_person_outline_black_24dp); &#125; 如果文件不存在！ 1234567891011URL picUrl = null; try &#123; picUrl = new URL(url); Bitmap bitmap = BitmapFactory.decodeStream(picUrl.openStream()); OutputStream os = new FileOutputStream(f); bitmap.compress(Bitmap.CompressFormat.JPEG, 100, os); os.flush(); os.close(); subscriber.onNext(bitmap); subscriber.onCompleted(); 12Drawable drable = new BitmapDrawable(bitmap); imageView.setImageDrawable(drable); 我的异步任务是用rxjava写的。。很方便链式的。。 到这里就结束了，其实真的很简单，之前总是把事情想的非常复杂。。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统分享]]></title>
    <url>%2F2017%2F04%2F04%2F%E7%B3%BB%E7%BB%9F%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[系统分享Android手机调用系统分享是个很常见的事情，所以今天来总结下分享的功能。 当分享单个文本的时候 1234567Intent shareIntent = new Intent(); shareIntent.setAction(Intent.ACTION_SEND); shareIntent.putExtra(Intent.EXTRA_TEXT, &quot;你要分享的文本&quot;); shareIntent.setType(&quot;text/plain&quot;); //设置分享列表的标题，并且每次都显示分享列表 startActivity(Intent.createChooser(shareIntent, &quot;分享到&quot;));//分享的标题 分享单个照片的时候 12345678910String imagePath =&quot;-------------&quot;//由文件得到uriUri imageUri = Uri.fromFile(new File(imagePath));Log.d(&quot;share&quot;, &quot;uri:&quot; + imageUri); //输出：Intent shareIntent = new Intent();shareIntent.setAction(Intent.ACTION_SEND);shareIntent.putExtra(Intent.EXTRA_STREAM, imageUri);shareIntent.setType(&quot;image/*&quot;);startActivity(Intent.createChooser(shareIntent, &quot;分享到&quot;)); 分享多个照片的时候 1234567891011ArrayList&lt;uri&gt; uriList = new ArrayList&lt;&gt;();String path = Environment.getExternalStorageDirectory() + File.separator;uriList.add(Uri.fromFile(new File(path+&quot;1.jpg&quot;)));uriList.add(Uri.fromFile(new File(path+&quot;2.jpg&quot;)));uriList.add(Uri.fromFile(new File(path+&quot;3.jpg&quot;)));Intent shareIntent = new Intent();shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE);shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, uriList);shareIntent.setType(&quot;image/*&quot;);startActivity(Intent.createChooser(shareIntent, &quot;分享到&quot;));]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓图库那些事]]></title>
    <url>%2F2017%2F04%2F04%2F%E5%AE%89%E5%8D%93%E5%9B%BE%E5%BA%93%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[相机的调用调用Intent的参数MediaStore.ACTION_IMAGE_CAPTURE实现 然后在startActivityForResult方法实现返回的数据。 12345678Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);//存放相机返回的图片File file = new File(filePath);if(file.exists())&#123;file.delete()&#125;Uri uri = Uri.fromFile(file);intent.putExtra(MediaStore.EXTRA_OUTPUT,uri);startActivityForResult(intent1,TAKE_PHOTO); 调用图库Intent的Action参数Intent.ACTION_GET_CONTENT 实现 12345Intent intent = new Intent(Intent.ACTION_GET_CONTENT);//选择图片格式intent.setType(&quot;image/*&quot;);intent.putExtra(&quot;return-data&quot;,true);startActivityForResult(intent,1); 这里在startActivityForResult 返回的是一个图片的uri； 调用系统的照片剪裁功能1234567891011Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;); intent.setDataAndType(uri, &quot;image/*&quot;); intent.putExtra(&quot;crop&quot;, &quot;true&quot;); intent.putExtra(&quot;aspectX&quot;, background.getWidth());//图片的关高比 intent.putExtra(&quot;aspectY&quot;, background.getHeight()); intent.putExtra(&quot;outputX&quot;, 500); intent.putExtra(&quot;outputY&quot;, 500);//图片的宽高 intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG);输出的图片格式 intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(file));输出的图片位置 intent.putExtra(&quot;return-data&quot;, false);是否有返回值？ startActivityForResult(intent, 3); 这里要注意系统剪裁完的图片会返回一个缩略图，具体为啥会这样因为内存原因，如果内存太大了的话在内存间传递会导致oom，我也是搞了好久才发现，所以不要返回值，直接记住他的uri，然后再回调方法里面去找到图片在进行其他处理。 备注如果存放照片的值出现filenotfound的异常的时候注意看看文件夹的父文件夹是否存在，最好用file.mkdirs()方法。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发布了人生第一款应用]]></title>
    <url>%2F2017%2F03%2F30%2F%E5%8F%91%E5%B8%83%E4%BA%86%E4%BA%BA%E7%94%9F%E7%AC%AC%E4%B8%80%E6%AC%BE%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[downloadmangager的使用]]></title>
    <url>%2F2017%2F03%2F29%2Fdownloadmangager%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[downloadmangager这是一个Android 2.3自带的一个下载api，它非常的方便，自动帮你写好了下载，暂停，和下载失败等等需要我们自己写的东西。 简单的使用 调用downloadmanger的requset方法 12DownloadManager.Request request = new DownloadManager.Request (Uri.parse(&quot;http://7xstld.com1.z0.glb.clouddn.com/kechengbiao.apk&quot;));// 字符串网址 request方法： 1setAllowedNetworkTypes\\设置允许下载的网络类型 1setNotificationVisibility \\设置下载在下拉菜单是否可见 (DownloadManager.Request.VISIBILITY_VISIBLE) 1setTitle 设置标题 1setDescription 设置描述 1setAllowedOverRoaming 设置是否可以被移除 123setDestinationInExternalFilesDir 设置下载地址 因人而异(SettingActivity.this, Environment.DIRECTORY_DOWNLOADS, &quot;kbdown&quot;)； ​ 1DownloadManager downloadManager = (DownloadManager) getSystemService(DOWNLOAD_SERVICE); enqueue 12long id = downloadManager.enqueue(request);// 返回一个id ，可以用这个id来查询下载信息 下载成功后会发出一个DownloadManager.ACTION_DOWNLOAD_COMPLETE这个广播并传递downloadId作为参数。通过接受广播我们可以打开对下载完成的内容进行操作 取消删除下载 1downloadManager.remove(REFERENCE_1, REFERENCE_2, REFERENCE_3); 查询状态 你可以通过查询Download Manager来获得下载任务的状态，进度，以及各种细节，通过query方法返回一个包含了下载任务细节的Cursor。 query方法传递一个DownloadManager.Query对象作为参数，通过DownloadManager.Query对象的setFilterById方法可以筛选我们希望查询的下 载任务的ID。也可以使用setFilterByStatus方法筛选我们希望查询的某一种状态的下载任务，传递的参数是DownloadManager.STATUS_*常量，可以指定 正在进行、暂停、失败、完成四种状态。 Download Manager包含了一系列COLUMN_*静态String常量，可以用来查询Cursor中的结果列索引。我们可以查询到下载任务的各种细节，包括状态， 文件大小，已经下载的字节数，标题，描述，URI，本地文件名和URI，媒体类型以及Media Provider download URI 对于暂停和失败的下载，我们可以通过查询COLUMN_REASON列查询出原因的整数码。对于STATUSPAUSED状态的下载，可以通过DownloadManager.PAUSED静态常量来翻译出原因的整数码，进而判断出下载是由于等待网络连接还是等待WiFi连接还是准备重新下载三种原因而暂停。对于STATUSFAILED状态的下载，我们可以通过DownloadManager.ERROR来判断失败的原因，可能是错误码（失败原因）包括没有存储设备，存储空间不足，重复的文件名，或者HTTP errors。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView的使用]]></title>
    <url>%2F2017%2F03%2F28%2FRecyclerView%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[之前写Android程序遇到列表显示都是使用listview，可能因为自己要写的东西比较简单吧，所以一直没去用recycleview。但是今天遇到了个让人恼火的事情，就是listview和CollapsingToolbarLayout不兼容，无法实现toolbar的折叠效果，即使外面裹上了一层NestedScrollView 还要自己去重写listview的方法，非常麻烦，而且貌似在Android5.0有bug？就是他的下面会溢出屏幕一个toolbar的高度，数据显示不全，于是今天去搞了下recyclevierecycleview和listview的思想差不多。虽然他的实现方法和listview差不多，但是还是有很大不同的，而且recycleview比listview比起来优势更多，更适合自定义，而且性能也很好，因为recycleview是直接继承groupview的，减少了图像的一层层的绘制，而listview则继承listview的抽象类。 具体recycle 的实现方法 12345recyclerView= (RecyclerView) findViewById(R.id.Recycle);final LinearLayoutManager manager=new LinearLayoutManager(this);recyclerView.setLayoutManager(manager);recyclerView.setHasFixedSize(true);recyclerView.addItemDecoration(new SpacesItemDecoration(3));//给recycleview添加分割线，因为recycle没有自带类似listview的driver; SpacesItemDecoration方法（下划线）12345678910111213141516171819public class SpacesItemDecoration extends RecyclerView.ItemDecoration &#123; private int space; public SpacesItemDecoration(int space) &#123; this.space = space; &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; outRect.left = space; outRect.right = space; outRect.bottom = space; // Add top margin only for the first item to avoid double space between items if (parent.getChildPosition(view) == 0) outRect.top = space; &#125; &#125; recycleview的adapter12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class GradeRecyclerAdapter extends RecyclerView.Adapter&lt;GradeRecyclerAdapter.ViewHolder&gt; &#123; private List&lt;Map&lt;String, String&gt;&gt; list; private Activity activity; //构造方法 public GradeRecyclerAdapter(List&lt;Map&lt;String, String&gt;&gt; list, Activity activity) &#123; this.list = list; this.activity = activity; &#125;//viewholder @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_list_library, parent,false); ViewHolder viewHolder = new ViewHolder(view); return viewHolder; &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; holder.bookname.setText(list.get(position).get(&quot;name&quot;)); holder.place.setText(list.get(position).get(&quot;palce&quot;)); holder.writer.setText(list.get(position).get(&quot;writer&quot;)); holder.num.setText(list.get(position).get(&quot;num&quot;)); final int a=position; holder.more.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(activity, BookDetalActivity.class); intent.putExtra(&quot;url&quot;, list.get(a).get(&quot;url&quot;)); activity.startActivity(intent); &#125; &#125;); &#125; @Override public int getItemCount() &#123; return list.size(); &#125; public static class ViewHolder extends RecyclerView.ViewHolder &#123; TextView bookname; TextView place; TextView writer; TextView num; TextView more; public ViewHolder(View itemView) &#123; super(itemView); bookname = (TextView) itemView.findViewById(R.id.bookname); place = (TextView) itemView.findViewById(R.id.place); writer = (TextView) itemView.findViewById(R.id.num); num = (TextView) itemView.findViewById(R.id.writer); more = (TextView) itemView.findViewById(R.id.moer); &#125; &#125;&#125; 以上就是recycleview的简单实现啦，很简单。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓学习路线]]></title>
    <url>%2F2017%2F03%2F28%2F%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[学了这么久安卓，忽然发现自己会的太少了，于是在ｖ２ｅｘ上求助，偶然发现好心人推荐的一个博客非常不错，里面总结了很多关于安卓学习用到的东西，今天在这跟大家分享下。 1http://www.jianshu.com/p/af2de05aadff]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux环境下搭建hexo博客]]></title>
    <url>%2F2017%2F03%2F28%2FLinux%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[之前一直用windows系统 ，直到前几天换了国产的linux系统deepin，发现这个系统真的不错！很漂亮尤其我这种做安卓开发的，用了deepin之后发现 as的打开速度快乐特别多。好了言归正传，我在这里讲一下如何在linux系统下搭建hexo个人博客。 第一步： 安装git1$ sudo apt-get install git 第二步：安装node.js之前上网google资料的时候走了好多弯路，网上很多人都说最好不用 apt-get的方法可是最后发现这个方法是最省力最方便的。1sudo apt-get install nodejs 1sudo apt-get install npm 直接运行以上两个命令，安装node.js 如果不好使把sudo去掉，或者 1sudo su 这时候让你输入密码然后在root用户下运行命令 如果直接安装的方法不管用了，别急还有另外两种方法去官网下载好node.js文件后 1cd node-***(你的node.js文件)/bin 1./node -v 然后将node命令设置全局可用： 1 ln -s /home/tongyangmysofltware/node-v0.10.28-linux-x64/bin/node /usr/local/bin/node 1ln -s /home/tongyang/mysofltware/node-v0.10.28-linux-x64/bin/npm /usr/local/bin/npm 这个目录根据个人情况而定 第三步：hexo的安装node.js安装完成后我们就可以安装hexo了 1npm install hexo-cli -g 初始化hexo 1hexo init 安装依赖包 1npm install 生成静态页面 1hexo generate （可以简写成 hexo g） 开启本地服务 1hexo server (同理简写成 hexo s) 浏览器打开http://localhost:4000就可以看到自己博客啦，不过现在还没有和自己github关联 第四步：发布自己的博客到github上1检查本地是否存在id1打开git bash，输入命令ls -al ~/.ssh。 如果存在直接跳过 如果没有 1234$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;# Creates a new ssh key using the provided email # Generating public/private rsa key pair. # Enter file in which to save the key (/home/you/.ssh/id_rsa): 直接Enter就行。然后，会提示你输入密码，如下(建议输一个，安全一点，当然不输也行)： 12Enter passphrase (empty for no passphrase): [Type a passphrase] # Enter same passphrase again: [Type passphrase again] 完了之后，大概是这样。 123Your identification has been saved in /home/you/.ssh/id_rsa. # Your public key has been saved in /home/you/.ssh/id_rsa.pub. # The key fingerprint is: # 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@youremail.com 你的秘钥已经生成 知道.shh下面的id_rsa. 或者id_rsa.pub. 复制你的秘钥所有内容 登陆你的github帐户。然后 Account Settings -&gt; 左栏点击 SSH Keys -&gt; 点击 Add SSH key 然后你复制上面的公钥内容，粘贴进“Key”文本域内。 title域，你随便填一个都行。 完了，点击 Add key。 可以使用一下命令查看是否成功 1$ ssh -T git@github.com 如果，看到： 1Hi username! You&apos;ve successfully authenticated, but GitHub does not # provide shell access. 就表示你的设置已经成功了。 至于怎么在github上面生成自己博客页面我就不多说了，不会的百度吧，因为我想作为一个程序员，连基友交友平台都不知道怎么用，那就太尴尬了。 在hexo文件夹的的住配置文件里面拉到最下面修改成这样 1234deploy: type: git repo: git@github.com:tongyangl/tongyangl.github.io.git branch: master 记住这个 repo是你在github上面的地址！ 最后直接在hexo页面执行以下命令 1hexo d 大多数都会成功 如果还不成功提示未找到git也可以用一些麻烦的方法push自己的博客 新建一个文件夹blog 1git clone 你github的博客地址 然后 12hexo ghexo s 删除blog的文件夹的内容 在hexo文件夹的public文件下的所有内容都复制到blog 然后 123git add ×git commit -m 你的commit内容随便你写git push]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View]]></title>
    <url>%2F2017%2F01%2F14%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%2F</url>
    <content type="text"><![CDATA[自定义view Paint就相当于画笔，有着颜色等属性。 setARGB/setColor 设置颜色 setAlpha 设置透明度 setAntiAlias 设置是否抗锯齿 setShader 设置画笔的填充效果 setShadowLayer 设置阴影 setStyle 设置画笔风格 setStrokeWidth 设置空心边框的宽度 setTextSize 设置绘制文本时文字的大小 setStrokeCap(Paint.Cap.ROUND) 设置为圆角 Canvas就相当于画板或者画纸。有着宽高等属性 draw则相当于画的动作比如画个正方形等。 drawArc 绘制弧 drawBitmap 绘制位图 drawCircle 绘制圆形 drawLine 绘制线 drawOval 绘制椭圆 drawPath 绘制路径 drawPoint 绘制一个点 drawPoints 绘制多个点 drawRect 绘制矩形 drawRoundRect 绘制圆角矩形 drawText 绘制字符串 drawTextOnPath 沿着路径绘制字符串 这些都是draw的一些方法，记住一些常见的就好了，都是英文，很好记，毕竟as的代码提示 ​ 好了，我们先从自己画一个圆开始，首先自己写一个MyView的类继承View 记得三个构造方法！ 然后再onDraw方法里面 1234mPaint = new Paint(); mPaint.setAntiAlias(true);//去掉锯齿 mPaint.setColor(color);设置画笔的颜色 canvas.drawCircle(length, length, length, mPaint); 设置圆的大小 这样我们在自己lyout文件里用上自己自定义view就可以出现了！ 怎么样，很简单吧！ 具体的正方形啥的就不一一去试了 什么？颜色和大小都是写死的。。 嗯，别人的都是可以自定义大小等属性的。于是研究了一下 我们要自定义一个属于我们自己属性 在value下面创建attrs的xml文件 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;Myview&quot;&gt; &lt;attr name=&quot;MyLength&quot; format=&quot;integer&quot;&gt; &lt;/attr&gt; &lt;attr name=&quot;MyColor&quot; format=&quot;color&quot;&gt; &lt;/attr&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 写好我们自定义view的名字和属性类型。 接下来就是去我们自定义view拿到我们的属性了 TypeArray我们可以通过它来获取我们的自定义view。 12345TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.Myview); color = ta.getColor(R.styleable.Myview_MyColor, Color.RED); length = ta.getFloat(R.styleable.Myview_MyLength, 0); Log.d(&quot;===&quot;, color + &quot;...&quot;); ta.recycle(); 通过这个数组我们获取到了我们设置的属性 记得最后一定要回收！ ta.recycle(); 好了接下来去xml文件去设置自己的属性吧，属性名字就是我们的项目名字 12345&lt;rxjavatest.tycoding.com.beziertest.Myview BezierTest:MyLength=&quot;200&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; BezierTest:MyColor=&quot;@color/colorPrimaryDark&quot; /&gt; 像这样，我以为就万事大吉了。。可是tmd，绘制圆不显示。。去构造方法log不出来我们获取的属性。。这就奇了怪了。。于是鼓捣了半个钟头，md！就该自己研究，之前受到网上其他人写的东西的影响，我的其他两个构造方法没有调用我们获取的这个构造方法。 所以一样要这么写出来 1234567891011121314151617public Myview(Context context) &#123; this(context, null); &#125; public Myview(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.Myview); color = ta.getColor(R.styleable.Myview_MyColor, Color.RED); length = ta.getFloat(R.styleable.Myview_MyLength, 0); Log.d(&quot;===&quot;, color + &quot;...&quot;); ta.recycle(); &#125; public Myview(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; this调用构造方法就不说了。。java基础 这样再次打开！！！ 控件的大小和颜色我们可以随心所欲的控制了。 之所以要把那两个构造函数写出来因为 ·public view（Context context） 当在代码中创建对象时会被调用 ·public View (Context context, AttributeSet attrs) 这个是xml来创建new view的对象时候用到所以我们的所有的属性都应该指向我们那个 public Myview(Context context, AttributeSet attrs, int defStyleAttr) ​ 当然这是最基础最简单的东西，，还有很多我学到在记录。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用序列化器生成xml文件]]></title>
    <url>%2F2016%2F11%2F15%2F%E5%88%A9%E7%94%A8%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E7%94%9F%E6%88%90xml%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384List&lt;Message&gt; smsList; // 虚拟10条短信 smsList = new ArrayList&lt;Message&gt;(); for (int i = 0; i &lt; 10; i++) &#123; Message sms = new Message(&quot;小志好棒&quot; + i, System.currentTimeMillis() + &quot;&quot;, &quot;138&quot; + i + i, &quot;1&quot;); smsList.add(sms); &#125; &#125; public void click(View v)&#123; //使用xml序列化器生成xml文件 //1.拿到序列化器对象 XmlSerializer xs = Xml.newSerializer(); //2.初始化 File file = new File(&quot;sdcard/sms2.xml&quot;); try &#123; FileOutputStream fos = new FileOutputStream(file); //enconding:指定用什么编码生成xml文件 xs.setOutput(fos, &quot;utf-8&quot;); //3.开始生成xml文件 //enconding:指定头结点中的enconding属性的值 xs.startDocument(&quot;utf-8&quot;, true); xs.startTag(null, &quot;message&quot;); for (Message sms : smsList) &#123; xs.startTag(null, &quot;sms&quot;); xs.startTag(null, &quot;body&quot;); xs.text(sms.getBody() + &quot;&lt;body&gt;&quot;); xs.endTag(null, &quot;body&quot;); xs.endTag(null, &quot;sms&quot;); &#125; xs.endTag(null, &quot;message&quot;); //告诉序列化器，文件生成完毕 xs.endDocument(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;================================================================================================================================================================================================package com.itheima.createxml.domain;public class Message &#123; private String body; private String date; private String address; private String type; public String getBody() &#123; return body; &#125; public void setBody(String body) &#123; this.body = body; &#125; public String getDate() &#123; return date; &#125; public void setDate(String date) &#123; this.date = date; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; public Message(String body, String date, String address, String type) &#123; super(); this.body = body; this.date = date; this.address = address; this.type = type; &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试类测试数据库并且进行增删改查]]></title>
    <url>%2F2016%2F10%2F28%2F%E6%B5%8B%E8%AF%95%E7%B1%BB%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E4%B8%94%E8%BF%9B%E8%A1%8C%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187public class TestCase extends AndroidTestCase &#123; //此时测试框架还没有初始化完毕，没有虚拟上下文对象// private MyOpenHelper oh = new MyOpenHelper(getContext(), &quot;people.db&quot;, null, 1); private MyOpenHelper oh; private SQLiteDatabase db; public void test()&#123; //getContext():获取一个虚拟的上下文 MyOpenHelper oh = new MyOpenHelper(getContext(), &quot;people.db&quot;, null, 1); //如果数据库不存在，先创建数据库，再获取可读可写的数据库对象，如果数据库存在，就直接打开 SQLiteDatabase db = oh.getWritableDatabase(); //如果存储空间满了，那么返回只读数据库对象// SQLiteDatabase db = oh.getReadableDatabase(); &#125; //测试框架初始化完毕之后，在测试方法执行之前，此方法调用 @Override protected void setUp() throws Exception &#123; super.setUp(); oh = new MyOpenHelper(getContext(), &quot;people.db&quot;, null, 1); db = oh.getWritableDatabase(); &#125; //测试方法执行完毕之后，此方法调用 @Override protected void tearDown() throws Exception &#123; // TODO Auto-generated method stub super.tearDown(); db.close(); &#125; public void insert()&#123;// db.execSQL(&quot;insert into person (name, salary, phone)values(?, ?, ?)&quot;, new Object[]&#123;&quot;小志的老婆[1]&quot;, &quot;13000&quot;, 138438&#125;);// db.execSQL(&quot;insert into person (name, salary, phone)values(?, ?, ?)&quot;, new Object[]&#123;&quot;小志的儿子&quot;, 14000, &quot;13888&quot;&#125;); db.execSQL(&quot;insert into person (name, salary, phone)values(?, ?, ?)&quot;, new Object[]&#123;&quot;小志&quot;, 14000, &quot;13888&quot;&#125;); &#125; public void delete()&#123; db.execSQL(&quot;delete from person where name = ?&quot;, new Object[]&#123;&quot;小志&quot;&#125;); &#125; public void update()&#123; db.execSQL(&quot;update person set phone = ? where name = ?&quot;, new Object[]&#123;186666, &quot;小志的儿子&quot;&#125;); &#125; public void select()&#123; Cursor cursor = db.rawQuery(&quot;select name, salary from person&quot;, null); while(cursor.moveToNext())&#123; //通过列索引获取列的值 String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;)); String salary = cursor.getString(1); System.out.println(name + &quot;;&quot; + salary); &#125; &#125; public void insertApi()&#123; //把要插入的数据全部封装至ContentValues对象 ContentValues values = new ContentValues(); values.put(&quot;name&quot;, &quot;游天龙&quot;); values.put(&quot;phone&quot;, &quot;15999&quot;); values.put(&quot;salary&quot;, 16000); db.insert(&quot;person&quot;, null, values); &#125; public void deleteApi()&#123; int i = db.delete(&quot;person&quot;, &quot;name = ? and _id = ?&quot;, new String[]&#123;&quot;小志的儿子&quot;, &quot;3&quot;&#125;); System.out.println(i); &#125; public void updateApi()&#123; ContentValues values = new ContentValues(); values.put(&quot;salary&quot;, 26000); int i = db.update(&quot;person&quot;, values, &quot;name = ?&quot;, new String[]&#123;&quot;游天龙&quot;&#125;); System.out.println(i); &#125; public void selectApi()&#123; Cursor cursor = db.query(&quot;person&quot;, null, null, null, null, null, null, null); while(cursor.moveToNext())&#123; String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;)); String phone = cursor.getString(cursor.getColumnIndex(&quot;phone&quot;)); String salary = cursor.getString(cursor.getColumnIndex(&quot;salary&quot;)); System.out.println(name + &quot;;&quot; + phone + &quot;;&quot; + salary); &#125; &#125; public void transaction()&#123; try&#123; //开启事务 db.beginTransaction(); ContentValues values = new ContentValues(); values.put(&quot;salary&quot;, 12000); db.update(&quot;person&quot;, values, &quot;name = ?&quot;, new String[]&#123;&quot;小志&quot;&#125;); values.clear(); values.put(&quot;salary&quot;, 16000); db.update(&quot;person&quot;, values, &quot;name = ?&quot;, new String[]&#123;&quot;小志的儿子&quot;&#125;); int i = 3/0; //设置 事务执行成功 db.setTransactionSuccessful(); &#125; finally&#123; //关闭事务，同时提交，如果已经设置事务执行成功，那么sql语句就生效了，反之，sql语句回滚 db.endTransaction(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主线程阻塞，使用handler方法消息队列 和子线程请求主线程进行ui变化]]></title>
    <url>%2F2016%2F06%2F11%2Fhandler%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class MainActivity extends AppCompatActivity &#123;static ImageView iv;static MainActivity ma;static Handler handler = new Handler() &#123;@Overridepublic void handleMessage(Message msg) &#123;switch (msg.what) &#123;case 1:iv.setImageBitmap((Bitmap) msg.obj);break;case 2: Toast.makeText(ma, &quot;请求失败&quot;, Toast.LENGTH_SHORT).show();break; &#125; &#125; &#125;;protected void onCreate(Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState); setContentView(R.layout.activity_main);iv = (ImageView) findViewById(R.id.iv);ma = this; &#125;public void click(View v) &#123;final String path = &quot;http://192.168.74.154:8080/a.jpg&quot;;final File file = new File(getFilesDir(), getPathName(path));if (file.exists()) &#123; Log.d(&quot;======&quot;, &quot;1111 &quot;); Bitmap bm = BitmapFactory.decodeFile(file.getAbsolutePath());iv.setImageBitmap(bm); &#125; else &#123; Thread t = new Thread() &#123;public void run() &#123;try &#123; URL url = new URL(path); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(&quot;GET&quot;); conn.setReadTimeout(5000); conn.setConnectTimeout(5000); conn.connect();if (conn.getResponseCode() == 200) &#123; InputStream is = conn.getInputStream();byte[] b = new byte[1024]; FileOutputStream fos = new FileOutputStream(file);int len = 0;while ((len = is.read(b)) != -1) &#123; fos.write(b, 0, len); &#125; fos.close(); Bitmap bm = BitmapFactory.decodeFile(file.getAbsolutePath()); Message msg = handler.obtainMessage(); msg.obj = bm; msg.what = 1;handler.sendMessage(msg); &#125; else &#123; Message msg = handler.obtainMessage(); msg.what = 1; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;; t.start(); &#125; &#125;public String getPathName(String path) &#123;int index = path.lastIndexOf(&quot;/&quot;);return path.substring(index + 1); &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
</search>
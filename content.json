[{"title":"bitmap上写字","date":"2017-04-17T13:01:30.000Z","path":"2017/04/17/bitmap上写字/","text":"网易云的锁屏歌词是如何实现的？？学长突然问了我这个问题，是啊，怎麼实现的呢？貌似google并没有给我们这个接口，可是这些巨头却实现了，考虑了半天，也百度 google了一会，最后才知道 这些歌词是通过bitmap的实时渲染文字更新呢，可是这又有个问题，如果使用bitmap的话，那么多图片肯定会内存爆炸的！ 所以这里用到了个软引用（我觉得弱引用也可以） 所以话不过说，开写！ 界面非常简单就一个按钮和图片 可是我们要实现歌词的实时变换，怎麼实现呢。。我这就简化了下，用了个定时气 timer； 没个3秒钟就会自己自动渲染。 1234567891011imageView = (ImageView) findViewById(R.id.img);button = (Button) findViewById(R.id.button);button.setOnClickListener(this);list = new ArrayList&lt;&gt;();list.add(&quot;陪你把沿路感想活出了答案&quot;);list.add(&quot;陪你把独自孤单变成了勇敢&quot;);list.add(&quot;一次次失去又重来 我没离开&quot;);list.add(&quot;陪伴是 最长情的告白&quot;);list.add(&quot;陪你把想念的酸 拥抱成温暖&quot;);list.add(&quot;未来多漫长 再漫长 还有期待&quot;);list.add(&quot;陪伴你 一直到 故事给说完&quot;); list 就是歌词了，这里简化了 12345678910111213141516171819202122232425@Override public void onClick(View v) &#123; final Timer timer = new Timer(); final Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.ic_b33); timer.schedule(new TimerTask() &#123; int i = 0; @Override public void run() &#123; i++; if (i == list.size()) &#123; //timer.cancel(); i=0; &#125; Message message = new Message(); message.obj = getNewBitMap(list.get(i), bitmap,i); handler.sendMessage(message); &#125; &#125;, 200, 3000); &#125; 这是点击事件 这是 渲染图片的方法。 123456789101112131415161718192021222324public Bitmap getNewBitMap(String text, Bitmap bitmap,int i) &#123; if (mImageCache.containsKey(i))&#123; if (mImageCache.get(i).get()!=null)&#123; Log.d(&quot;===&quot;,&quot;return&quot;); return mImageCache.get(i).get(); &#125; &#125; WindowManager windowManager=getWindowManager(); Bitmap newBitmap = Bitmap.createBitmap(windowManager.getDefaultDisplay().getWidth(),windowManager.getDefaultDisplay().getHeight(), Bitmap.Config.ARGB_4444); Canvas canvas = new Canvas(newBitmap); canvas.drawBitmap(bitmap, 0, 0, null); TextPaint textPaint = new TextPaint(); textPaint.setAntiAlias(true); textPaint.setTextSize(160F); StaticLayout sl = new StaticLayout(text, textPaint, newBitmap.getWidth(), Layout.Alignment.ALIGN_CENTER, 1.0f, 0.0f, false); canvas.translate(6, 40); sl.draw(canvas); mImageCache.put(i,new SoftReference&lt;Bitmap&gt;(newBitmap)); return newBitmap; &#125; 还有通过hander 更新画面 123456789Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; Bitmap bitmap = (Bitmap) msg.obj; imageView.setImageBitmap(bitmap); super.handleMessage(msg); &#125; &#125;; 这里的图片方法就比较好理解了，首先new一个新的bitmap对象，它代表新的要加载的bitmap，它是用来加载原来的bitmap和文字的，然后文字卸载上面，填到map中，如果他因为内存原因被回收了，则重新渲染这个图片。。非常好理解！ http://i4.buimg.com/567571/a15846a46351cfc0.jpg http://i4.buimg.com/567571/e0299fd22afae178.jpg","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"自定义view（1）","date":"2017-04-14T02:47:45.000Z","path":"2017/04/14/自定义view（1）/","text":"自定义view开发过程中难免会遇到一些需要自己自定义的view 他可能直接继承某个控件如textview，button等 也可能继承view。 学了这么久安卓，今天终于闲下来搞了搞自定义view。。先从最简单的来我们直接继承view 画一个圆 我们要重写onDraw的方法，就要了解下这三个东西 Paint ，Canvas，和draw Paint就相当于画笔，有着颜色等属性。 setARGB/setColor 设置颜色 setAlpha 设置透明度 setAntiAlias 设置是否抗锯齿 setShader 设置画笔的填充效果 setShadowLayer 设置阴影 setStyle 设置画笔风格 setStrokeWidth 设置空心边框的宽度 setTextSize 设置绘制文本时文字的大小 setStrokeCap(Paint.Cap.ROUND) 设置为圆角 Canvas就相当于画板或者画纸。有着宽高等属性 draw则相当于画的动作比如画个正方形等。 drawArc 绘制弧 drawBitmap 绘制位图 drawCircle 绘制圆形 drawLine 绘制线 drawOval 绘制椭圆 drawPath 绘制路径 drawPoint 绘制一个点 drawPoints 绘制多个点 drawRect 绘制矩形 drawRoundRect 绘制圆角矩形 drawText 绘制字符串 drawTextOnPath 沿着路径绘制字符串 这些都是draw的一些方法，记住一些常见的就好了，都是英文，很好记，毕竟as的代码提示 ​ 好了，我们先从自己画一个圆开始，首先自己写一个MyView的类继承View 记得三个构造方法！ 然后再onDraw方法里面 1234mPaint = new Paint(); mPaint.setAntiAlias(true);//去掉锯齿 mPaint.setColor(color);设置画笔的颜色 canvas.drawCircle(length, length, length, mPaint); 设置圆的大小 这样我们在自己lyout文件里用上自己自定义view就可以出现了！ 怎么样，很简单吧！ 具体的正方形啥的就不一一去试了 什么？颜色和大小都是写死的。。 嗯，别人的都是可以自定义大小等属性的。于是研究了一下 我们要自定义一个属于我们自己属性 在value下面创建attrs的xml文件 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;Myview&quot;&gt; &lt;attr name=&quot;MyLength&quot; format=&quot;integer&quot;&gt; &lt;/attr&gt; &lt;attr name=&quot;MyColor&quot; format=&quot;color&quot;&gt; &lt;/attr&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 写好我们自定义view的名字和属性类型。 接下来就是去我们自定义view拿到我们的属性了 TypeArray我们可以通过它来获取我们的自定义view。 12345TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.Myview); color = ta.getColor(R.styleable.Myview_MyColor, Color.RED); length = ta.getFloat(R.styleable.Myview_MyLength, 0); Log.d(&quot;===&quot;, color + &quot;...&quot;); ta.recycle(); 通过这个数组我们获取到了我们设置的属性 记得最后一定要回收！ ta.recycle(); 好了接下来去xml文件去设置自己的属性吧，属性名字就是我们的项目名字 12345&lt;rxjavatest.tycoding.com.beziertest.Myview BezierTest:MyLength=&quot;200&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; BezierTest:MyColor=&quot;@color/colorPrimaryDark&quot; /&gt; 像这样，我以为就万事大吉了。。可是tmd，绘制圆不显示。。去构造方法log不出来我们获取的属性。。这就奇了怪了。。于是鼓捣了半个钟头，md！就该自己研究，之前受到网上其他人写的东西的影响，我的其他两个构造方法没有调用我们获取的这个构造方法。 所以一样要这么写出来 1234567891011121314151617public Myview(Context context) &#123; this(context, null); &#125; public Myview(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.Myview); color = ta.getColor(R.styleable.Myview_MyColor, Color.RED); length = ta.getFloat(R.styleable.Myview_MyLength, 0); Log.d(&quot;===&quot;, color + &quot;...&quot;); ta.recycle(); &#125; public Myview(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; this调用构造方法就不说了。。java基础 这样再次打开！！！ 控件的大小和颜色我们可以随心所欲的控制了。 之所以要把那两个构造函数写出来因为 ·public view（Context context） 当在代码中创建对象时会被调用 ·public View (Context context, AttributeSet attrs) 这个是xml来创建new view的对象时候用到所以我们的所有的属性都应该指向我们那个 public Myview(Context context, AttributeSet attrs, int defStyleAttr) ​ 当然这是最基础最简单的东西，，还有很多我学到在记录。","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]},{"title":"svg","date":"2017-04-12T08:25:29.000Z","path":"2017/04/12/svg/","text":"SVG 意为可缩放矢量图形（Scalable Vector Graphics），是使用 XML 来描述二维图形和绘图程序的语言；使用 SVG 的优势在于： 1.SVG 可被非常多的工具读取和修改（比如记事本）,由于使用xml格式定义，所以可以直接被当作文本文件打开，看里面的数据； 2.SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强，SVG 图就相当于保存了关键的数据点，比如要显示一个圆，需要知道圆心和半径，那么SVG 就只保存圆心坐标和半径数据，而平常我们用的位图都是以像素点的形式根据图片大小保存对应个数的像素点，因而SVG尺寸更小； 3.SVG 是可伸缩的，平常使用的位图拉伸会发虚，压缩会变形，而SVG格式图片保存数据进行运算展示，不管多大多少，可以不失真显示； 4.SVG 图像可在任何的分辨率下被高质量地打印; 5.SVG 可在图像质量不下降的情况下被放大; 6.SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图）; 7.SVG 可以与 Java 技术一起运行; 8.SVG 是开放的标准; 9.SVG 文件是纯粹的 XML; 指令12345678910M = moveto 相当于 android Path 里的moveTo(),用于移动起始点 L = lineto 相当于 android Path 里的lineTo()，用于画线 H = horizontal lineto 用于画水平线 V = vertical lineto 用于画竖直线 C = curveto 相当于cubicTo(),三次贝塞尔曲线 S = smooth curveto 同样三次贝塞尔曲线，更平滑 Q = quadratic Belzier curve quadTo()，二次贝塞尔曲线 T = smooth quadratic Belzier curveto 同样二次贝塞尔曲线，更平滑 A = elliptical Arc 相当于arcTo()，用于画弧 Z = closepath 相当于closeTo(),关闭path","tags":[{"name":"svg","slug":"svg","permalink":"http://yoursite.com/tags/svg/"}]},{"title":"算法基础","date":"2017-04-10T05:20:32.000Z","path":"2017/04/10/算法基础/","text":"","tags":[]},{"title":"searchview","date":"2017-04-10T04:44:54.000Z","path":"2017/04/10/searchview/","text":"toolbar toolbar自带的搜索框其实非常实用 首先就是穿件menu的菜单！ 1234567891011121314@Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.search, menu); SearchManager searchManager = (SearchManager) getSystemService(Context.SEARCH_SERVICE); searchView = (SearchView) menu.findItem(R.id.ab_search).getActionView(); searchView.setSearchableInfo( searchManager.getSearchableInfo(getComponentName())); searchView.setOnQueryTextListener(this); return true; &#125; search.xml (menu)1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;item android:id=&quot;@+id/ab_search&quot; android:orderInCategory=&quot;60&quot; android:title=&quot;action_search&quot; app:actionViewClass=&quot;android.support.v7.widget.SearchView&quot; app:showAsAction=&quot;ifRoom&quot;/&gt;&lt;/menu&gt; xml12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;searchable xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:label=&quot;@string/app_name&quot; android:imeOptions=&quot;actionSearch&quot; android:hint=&quot;搜索&quot; /&gt; 上面这三行代码就是为了创建菜单而实现的。 12searchView.setOnQueryTextListener(this);实现setOnQueryTextListener接口判断数据的变化 和listview或者recycleview实现实时数据的搜索！这个刚开始觉得挺难的，试着写了一下，其实还可以！ 这需要adapter实现 filter的接口 重写 publishResults 和performFiltering方法！ 1234567891011121314151617181920212223242526@Override public Filter getFilter() &#123; return new Filter() &#123; @Override protected FilterResults performFiltering(CharSequence constraint) &#123; FilterResults results = new FilterResults(); List&lt;Map&lt;String, String&gt;&gt; datalist = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; mlist.size(); i++) &#123; if (mlist.get(i).get(&quot;title&quot;).contains(constraint)) &#123; datalist.add(mlist.get(i)); &#125; &#125; results.values = datalist; return results; &#125; @Override protected void publishResults(CharSequence constraint, FilterResults results) &#123; list=((List&lt;Map&lt;String, String&gt;&gt;) results.values); notifyDataSetChanged(); &#125; &#125;; 这里需要注意一下！因为你的数据实在实时刷新的，所以一旦回删数据的时候会导致数据恢复不了，所以初始化数据的时候一定要注意初始化一个 mdatalist 用来存放所有的数据，list用来实时更新加载数据！","tags":[{"name":"toolbar的搜索框","slug":"toolbar的搜索框","permalink":"http://yoursite.com/tags/toolbar的搜索框/"}]},{"title":"Android头像缓存","date":"2017-04-08T11:04:34.000Z","path":"2017/04/08/Android头像缓存/","text":"其实没那么难！之前一直抵触写这些东西，而且很多都是直接百度的，根本没有去想怎么回事。这不，今天下午有遇到这些问题了，无奈找了个网上的例子，看似很简单，可是使用中却发现根本不是那回事！ 当我们遇到listview 或者recycleview加载图片或者头像的时候 如果直接在getview的方法里面写一个异步的方法来加载图片的话写起来是简单，但是这样会导致item每次被重绘的时候都会去执行这个异步任务！导致app变卡，以及耗费流量等等有损用户体验的事情！ 于是今天下午自己逼着自己写了一个！才发现其实根本没有那么难。。。 思想其实就是每次加载的时候去你的本地文件夹判断是否有这个图片，如果有就直接加载，如果没有就去网络获取加载，在保存到本地！ 123456789String path=context.getExternalFilesDir(Environment.DIRECTORY_PICTURES).getPath(); imageView.setBackgroundResource(R.drawable.ic_img_load); final File file = new File(path + &quot;/iv2ex&quot;); String u = url.replace(&quot;/&quot;, &quot;!&quot;); u = u.replace(&quot;.&quot;, &quot;!&quot;); if (!file.exists()) &#123; file.mkdirs(); &#125; final File f = new File(file, u ); 这是文件夹的判断，如果没有父类文件夹直接创建！，然后记得吧图片的地址给转义下里面的“ /”不然会导致找不到文件。然后如果文件存在直接加载 12345678910if (f.exists()) &#123; try &#123; FileInputStream fos = new FileInputStream(f); Bitmap bitmap = BitmapFactory.decodeStream(fos); Drawable drawable = new BitmapDrawable(bitmap); imageView.setImageDrawable(drawable); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); imageView.setBackgroundResource(R.drawable.ic_person_outline_black_24dp); &#125; 如果文件不存在！ 1234567891011URL picUrl = null; try &#123; picUrl = new URL(url); Bitmap bitmap = BitmapFactory.decodeStream(picUrl.openStream()); OutputStream os = new FileOutputStream(f); bitmap.compress(Bitmap.CompressFormat.JPEG, 100, os); os.flush(); os.close(); subscriber.onNext(bitmap); subscriber.onCompleted(); 12Drawable drable = new BitmapDrawable(bitmap); imageView.setImageDrawable(drable); 我的异步任务是用rxjava写的。。很方便链式的。。 到这里就结束了，其实真的很简单，之前总是把事情想的非常复杂。。","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"系统分享","date":"2017-04-04T11:49:06.000Z","path":"2017/04/04/系统分享/","text":"系统分享Android手机调用系统分享是个很常见的事情，所以今天来总结下分享的功能。 当分享单个文本的时候 1234567Intent shareIntent = new Intent(); shareIntent.setAction(Intent.ACTION_SEND); shareIntent.putExtra(Intent.EXTRA_TEXT, &quot;你要分享的文本&quot;); shareIntent.setType(&quot;text/plain&quot;); //设置分享列表的标题，并且每次都显示分享列表 startActivity(Intent.createChooser(shareIntent, &quot;分享到&quot;));//分享的标题 分享单个照片的时候 12345678910String imagePath =&quot;-------------&quot;//由文件得到uriUri imageUri = Uri.fromFile(new File(imagePath));Log.d(&quot;share&quot;, &quot;uri:&quot; + imageUri); //输出：Intent shareIntent = new Intent();shareIntent.setAction(Intent.ACTION_SEND);shareIntent.putExtra(Intent.EXTRA_STREAM, imageUri);shareIntent.setType(&quot;image/*&quot;);startActivity(Intent.createChooser(shareIntent, &quot;分享到&quot;)); 分享多个照片的时候 1234567891011ArrayList&lt;uri&gt; uriList = new ArrayList&lt;&gt;();String path = Environment.getExternalStorageDirectory() + File.separator;uriList.add(Uri.fromFile(new File(path+&quot;1.jpg&quot;)));uriList.add(Uri.fromFile(new File(path+&quot;2.jpg&quot;)));uriList.add(Uri.fromFile(new File(path+&quot;3.jpg&quot;)));Intent shareIntent = new Intent();shareIntent.setAction(Intent.ACTION_SEND_MULTIPLE);shareIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, uriList);shareIntent.setType(&quot;image/*&quot;);startActivity(Intent.createChooser(shareIntent, &quot;分享到&quot;));","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"安卓图库那些事","date":"2017-04-04T11:36:02.000Z","path":"2017/04/04/安卓图库那些事/","text":"相机的调用调用Intent的参数MediaStore.ACTION_IMAGE_CAPTURE实现 然后在startActivityForResult方法实现返回的数据。 12345678Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);//存放相机返回的图片File file = new File(filePath);if(file.exists())&#123;file.delete()&#125;Uri uri = Uri.fromFile(file);intent.putExtra(MediaStore.EXTRA_OUTPUT,uri);startActivityForResult(intent1,TAKE_PHOTO); 调用图库Intent的Action参数Intent.ACTION_GET_CONTENT 实现 12345Intent intent = new Intent(Intent.ACTION_GET_CONTENT);//选择图片格式intent.setType(&quot;image/*&quot;);intent.putExtra(&quot;return-data&quot;,true);startActivityForResult(intent,1); 这里在startActivityForResult 返回的是一个图片的uri； 调用系统的照片剪裁功能1234567891011Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;); intent.setDataAndType(uri, &quot;image/*&quot;); intent.putExtra(&quot;crop&quot;, &quot;true&quot;); intent.putExtra(&quot;aspectX&quot;, background.getWidth());//图片的关高比 intent.putExtra(&quot;aspectY&quot;, background.getHeight()); intent.putExtra(&quot;outputX&quot;, 500); intent.putExtra(&quot;outputY&quot;, 500);//图片的宽高 intent.putExtra(&quot;outputFormat&quot;, Bitmap.CompressFormat.JPEG);输出的图片格式 intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(file));输出的图片位置 intent.putExtra(&quot;return-data&quot;, false);是否有返回值？ startActivityForResult(intent, 3); 这里要注意系统剪裁完的图片会返回一个缩略图，具体为啥会这样因为内存原因，如果内存太大了的话在内存间传递会导致oom，我也是搞了好久才发现，所以不要返回值，直接记住他的uri，然后再回调方法里面去找到图片在进行其他处理。 备注如果存放照片的值出现filenotfound的异常的时候注意看看文件夹的父文件夹是否存在，最好用file.mkdirs()方法。","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"发布了人生第一款应用","date":"2017-03-30T07:19:17.000Z","path":"2017/03/30/发布了人生第一款应用/","text":"","tags":[]},{"title":"downloadmangager的使用","date":"2017-03-29T06:59:36.000Z","path":"2017/03/29/downloadmangager的使用/","text":"downloadmangager这是一个Android 2.3自带的一个下载api，它非常的方便，自动帮你写好了下载，暂停，和下载失败等等需要我们自己写的东西。 简单的使用 调用downloadmanger的requset方法 12DownloadManager.Request request = new DownloadManager.Request (Uri.parse(&quot;http://7xstld.com1.z0.glb.clouddn.com/kechengbiao.apk&quot;));// 字符串网址 request方法： 1setAllowedNetworkTypes\\\\设置允许下载的网络类型 1setNotificationVisibility \\\\设置下载在下拉菜单是否可见 (DownloadManager.Request.VISIBILITY_VISIBLE) 1setTitle 设置标题 1setDescription 设置描述 1setAllowedOverRoaming 设置是否可以被移除 123setDestinationInExternalFilesDir 设置下载地址 因人而异(SettingActivity.this, Environment.DIRECTORY_DOWNLOADS, &quot;kbdown&quot;)； ​ 1DownloadManager downloadManager = (DownloadManager) getSystemService(DOWNLOAD_SERVICE); enqueue 12long id = downloadManager.enqueue(request);// 返回一个id ，可以用这个id来查询下载信息 下载成功后会发出一个DownloadManager.ACTION_DOWNLOAD_COMPLETE这个广播并传递downloadId作为参数。通过接受广播我们可以打开对下载完成的内容进行操作 取消删除下载 1downloadManager.remove(REFERENCE_1, REFERENCE_2, REFERENCE_3); 查询状态 你可以通过查询Download Manager来获得下载任务的状态，进度，以及各种细节，通过query方法返回一个包含了下载任务细节的Cursor。 query方法传递一个DownloadManager.Query对象作为参数，通过DownloadManager.Query对象的setFilterById方法可以筛选我们希望查询的下 载任务的ID。也可以使用setFilterByStatus方法筛选我们希望查询的某一种状态的下载任务，传递的参数是DownloadManager.STATUS_*常量，可以指定 正在进行、暂停、失败、完成四种状态。 Download Manager包含了一系列COLUMN_*静态String常量，可以用来查询Cursor中的结果列索引。我们可以查询到下载任务的各种细节，包括状态， 文件大小，已经下载的字节数，标题，描述，URI，本地文件名和URI，媒体类型以及Media Provider download URI 对于暂停和失败的下载，我们可以通过查询COLUMN_REASON列查询出原因的整数码。对于STATUSPAUSED状态的下载，可以通过DownloadManager.PAUSED静态常量来翻译出原因的整数码，进而判断出下载是由于等待网络连接还是等待WiFi连接还是准备重新下载三种原因而暂停。对于STATUSFAILED状态的下载，我们可以通过DownloadManager.ERROR来判断失败的原因，可能是错误码（失败原因）包括没有存储设备，存储空间不足，重复的文件名，或者HTTP errors。","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"RecyclerView的使用","date":"2017-03-28T11:54:04.000Z","path":"2017/03/28/RecyclerView的使用/","text":"之前写Android程序遇到列表显示都是使用listview，可能因为自己要写的东西比较简单吧，所以一直没去用recycleview。但是今天遇到了个让人恼火的事情，就是listview和CollapsingToolbarLayout不兼容，无法实现toolbar的折叠效果，即使外面裹上了一层NestedScrollView 还要自己去重写listview的方法，非常麻烦，而且貌似在Android5.0有bug？就是他的下面会溢出屏幕一个toolbar的高度，数据显示不全，于是今天去搞了下recyclevierecycleview和listview的思想差不多。虽然他的实现方法和listview差不多，但是还是有很大不同的，而且recycleview比listview比起来优势更多，更适合自定义，而且性能也很好，因为recycleview是直接继承groupview的，减少了图像的一层层的绘制，而listview则继承listview的抽象类。 具体recycle 的实现方法 12345recyclerView= (RecyclerView) findViewById(R.id.Recycle);final LinearLayoutManager manager=new LinearLayoutManager(this);recyclerView.setLayoutManager(manager);recyclerView.setHasFixedSize(true);recyclerView.addItemDecoration(new SpacesItemDecoration(3));//给recycleview添加分割线，因为recycle没有自带类似listview的driver; SpacesItemDecoration方法（下划线）12345678910111213141516171819public class SpacesItemDecoration extends RecyclerView.ItemDecoration &#123; private int space; public SpacesItemDecoration(int space) &#123; this.space = space; &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; outRect.left = space; outRect.right = space; outRect.bottom = space; // Add top margin only for the first item to avoid double space between items if (parent.getChildPosition(view) == 0) outRect.top = space; &#125; &#125; recycleview的adapter12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class GradeRecyclerAdapter extends RecyclerView.Adapter&lt;GradeRecyclerAdapter.ViewHolder&gt; &#123; private List&lt;Map&lt;String, String&gt;&gt; list; private Activity activity; //构造方法 public GradeRecyclerAdapter(List&lt;Map&lt;String, String&gt;&gt; list, Activity activity) &#123; this.list = list; this.activity = activity; &#125;//viewholder @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_list_library, parent,false); ViewHolder viewHolder = new ViewHolder(view); return viewHolder; &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; holder.bookname.setText(list.get(position).get(&quot;name&quot;)); holder.place.setText(list.get(position).get(&quot;palce&quot;)); holder.writer.setText(list.get(position).get(&quot;writer&quot;)); holder.num.setText(list.get(position).get(&quot;num&quot;)); final int a=position; holder.more.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(activity, BookDetalActivity.class); intent.putExtra(&quot;url&quot;, list.get(a).get(&quot;url&quot;)); activity.startActivity(intent); &#125; &#125;); &#125; @Override public int getItemCount() &#123; return list.size(); &#125; public static class ViewHolder extends RecyclerView.ViewHolder &#123; TextView bookname; TextView place; TextView writer; TextView num; TextView more; public ViewHolder(View itemView) &#123; super(itemView); bookname = (TextView) itemView.findViewById(R.id.bookname); place = (TextView) itemView.findViewById(R.id.place); writer = (TextView) itemView.findViewById(R.id.num); num = (TextView) itemView.findViewById(R.id.writer); more = (TextView) itemView.findViewById(R.id.moer); &#125; &#125;&#125; 以上就是recycleview的简单实现啦，很简单。","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"安卓学习路线","date":"2017-03-28T11:05:59.000Z","path":"2017/03/28/安卓学习路线/","text":"学了这么久安卓，忽然发现自己会的太少了，于是在ｖ２ｅｘ上求助，偶然发现好心人推荐的一个博客非常不错，里面总结了很多关于安卓学习用到的东西，今天在这跟大家分享下。 1http://www.jianshu.com/p/af2de05aadff","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Linux环境下搭建hexo博客","date":"2017-03-28T11:03:43.000Z","path":"2017/03/28/Linux环境下搭建hexo博客/","text":"之前一直用windows系统 ，直到前几天换了国产的linux系统deepin，发现这个系统真的不错！很漂亮尤其我这种做安卓开发的，用了deepin之后发现 as的打开速度快乐特别多。好了言归正传，我在这里讲一下如何在linux系统下搭建hexo个人博客。 第一步： 安装git1$ sudo apt-get install git 第二步：安装node.js之前上网google资料的时候走了好多弯路，网上很多人都说最好不用 apt-get的方法可是最后发现这个方法是最省力最方便的。1sudo apt-get install nodejs 1sudo apt-get install npm 直接运行以上两个命令，安装node.js 如果不好使把sudo去掉，或者 1sudo su 这时候让你输入密码然后在root用户下运行命令 如果直接安装的方法不管用了，别急还有另外两种方法去官网下载好node.js文件后 1cd node-***(你的node.js文件)/bin 1./node -v 然后将node命令设置全局可用： 1 ln -s /home/tongyangmysofltware/node-v0.10.28-linux-x64/bin/node /usr/local/bin/node 1ln -s /home/tongyang/mysofltware/node-v0.10.28-linux-x64/bin/npm /usr/local/bin/npm 这个目录根据个人情况而定 第三步：hexo的安装node.js安装完成后我们就可以安装hexo了 1npm install hexo-cli -g 初始化hexo 1hexo init 安装依赖包 1npm install 生成静态页面 1hexo generate （可以简写成 hexo g） 开启本地服务 1hexo server (同理简写成 hexo s) 浏览器打开http://localhost:4000就可以看到自己博客啦，不过现在还没有和自己github关联 第四步：发布自己的博客到github上1检查本地是否存在id1打开git bash，输入命令ls -al ~/.ssh。 如果存在直接跳过 如果没有 1234$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;# Creates a new ssh key using the provided email # Generating public/private rsa key pair. # Enter file in which to save the key (/home/you/.ssh/id_rsa): 直接Enter就行。然后，会提示你输入密码，如下(建议输一个，安全一点，当然不输也行)： 12Enter passphrase (empty for no passphrase): [Type a passphrase] # Enter same passphrase again: [Type passphrase again] 完了之后，大概是这样。 123Your identification has been saved in /home/you/.ssh/id_rsa. # Your public key has been saved in /home/you/.ssh/id_rsa.pub. # The key fingerprint is: # 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@youremail.com 你的秘钥已经生成 知道.shh下面的id_rsa. 或者id_rsa.pub. 复制你的秘钥所有内容 登陆你的github帐户。然后 Account Settings -&gt; 左栏点击 SSH Keys -&gt; 点击 Add SSH key 然后你复制上面的公钥内容，粘贴进“Key”文本域内。 title域，你随便填一个都行。 完了，点击 Add key。 可以使用一下命令查看是否成功 1$ ssh -T git@github.com 如果，看到： 1Hi username! You&apos;ve successfully authenticated, but GitHub does not # provide shell access. 就表示你的设置已经成功了。 至于怎么在github上面生成自己博客页面我就不多说了，不会的百度吧，因为我想作为一个程序员，连基友交友平台都不知道怎么用，那就太尴尬了。 在hexo文件夹的的住配置文件里面拉到最下面修改成这样 1234deploy: type: git repo: git@github.com:tongyangl/tongyangl.github.io.git branch: master 记住这个 repo是你在github上面的地址！ 最后直接在hexo页面执行以下命令 1hexo d 大多数都会成功 如果还不成功提示未找到git也可以用一些麻烦的方法push自己的博客 新建一个文件夹blog 1git clone 你github的博客地址 然后 12hexo ghexo s 删除blog的文件夹的内容 在hexo文件夹的public文件下的所有内容都复制到blog 然后 123git add ×git commit -m 你的commit内容随便你写git push","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"利用序列化器生成xml文件","date":"2016-11-15T11:30:20.000Z","path":"2016/11/15/利用序列化器生成xml文件/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384List&lt;Message&gt; smsList; // 虚拟10条短信 smsList = new ArrayList&lt;Message&gt;(); for (int i = 0; i &lt; 10; i++) &#123; Message sms = new Message(&quot;小志好棒&quot; + i, System.currentTimeMillis() + &quot;&quot;, &quot;138&quot; + i + i, &quot;1&quot;); smsList.add(sms); &#125; &#125; public void click(View v)&#123; //使用xml序列化器生成xml文件 //1.拿到序列化器对象 XmlSerializer xs = Xml.newSerializer(); //2.初始化 File file = new File(&quot;sdcard/sms2.xml&quot;); try &#123; FileOutputStream fos = new FileOutputStream(file); //enconding:指定用什么编码生成xml文件 xs.setOutput(fos, &quot;utf-8&quot;); //3.开始生成xml文件 //enconding:指定头结点中的enconding属性的值 xs.startDocument(&quot;utf-8&quot;, true); xs.startTag(null, &quot;message&quot;); for (Message sms : smsList) &#123; xs.startTag(null, &quot;sms&quot;); xs.startTag(null, &quot;body&quot;); xs.text(sms.getBody() + &quot;&lt;body&gt;&quot;); xs.endTag(null, &quot;body&quot;); xs.endTag(null, &quot;sms&quot;); &#125; xs.endTag(null, &quot;message&quot;); //告诉序列化器，文件生成完毕 xs.endDocument(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;================================================================================================================================================================================================package com.itheima.createxml.domain;public class Message &#123; private String body; private String date; private String address; private String type; public String getBody() &#123; return body; &#125; public void setBody(String body) &#123; this.body = body; &#125; public String getDate() &#123; return date; &#125; public void setDate(String date) &#123; this.date = date; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; public Message(String body, String date, String address, String type) &#123; super(); this.body = body; this.date = date; this.address = address; this.type = type; &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"测试类测试数据库并且进行增删改查","date":"2016-10-28T11:22:03.000Z","path":"2016/10/28/测试类测试数据库并且进行增删改查/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187public class TestCase extends AndroidTestCase &#123; //此时测试框架还没有初始化完毕，没有虚拟上下文对象// private MyOpenHelper oh = new MyOpenHelper(getContext(), &quot;people.db&quot;, null, 1); private MyOpenHelper oh; private SQLiteDatabase db; public void test()&#123; //getContext():获取一个虚拟的上下文 MyOpenHelper oh = new MyOpenHelper(getContext(), &quot;people.db&quot;, null, 1); //如果数据库不存在，先创建数据库，再获取可读可写的数据库对象，如果数据库存在，就直接打开 SQLiteDatabase db = oh.getWritableDatabase(); //如果存储空间满了，那么返回只读数据库对象// SQLiteDatabase db = oh.getReadableDatabase(); &#125; //测试框架初始化完毕之后，在测试方法执行之前，此方法调用 @Override protected void setUp() throws Exception &#123; super.setUp(); oh = new MyOpenHelper(getContext(), &quot;people.db&quot;, null, 1); db = oh.getWritableDatabase(); &#125; //测试方法执行完毕之后，此方法调用 @Override protected void tearDown() throws Exception &#123; // TODO Auto-generated method stub super.tearDown(); db.close(); &#125; public void insert()&#123;// db.execSQL(&quot;insert into person (name, salary, phone)values(?, ?, ?)&quot;, new Object[]&#123;&quot;小志的老婆[1]&quot;, &quot;13000&quot;, 138438&#125;);// db.execSQL(&quot;insert into person (name, salary, phone)values(?, ?, ?)&quot;, new Object[]&#123;&quot;小志的儿子&quot;, 14000, &quot;13888&quot;&#125;); db.execSQL(&quot;insert into person (name, salary, phone)values(?, ?, ?)&quot;, new Object[]&#123;&quot;小志&quot;, 14000, &quot;13888&quot;&#125;); &#125; public void delete()&#123; db.execSQL(&quot;delete from person where name = ?&quot;, new Object[]&#123;&quot;小志&quot;&#125;); &#125; public void update()&#123; db.execSQL(&quot;update person set phone = ? where name = ?&quot;, new Object[]&#123;186666, &quot;小志的儿子&quot;&#125;); &#125; public void select()&#123; Cursor cursor = db.rawQuery(&quot;select name, salary from person&quot;, null); while(cursor.moveToNext())&#123; //通过列索引获取列的值 String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;)); String salary = cursor.getString(1); System.out.println(name + &quot;;&quot; + salary); &#125; &#125; public void insertApi()&#123; //把要插入的数据全部封装至ContentValues对象 ContentValues values = new ContentValues(); values.put(&quot;name&quot;, &quot;游天龙&quot;); values.put(&quot;phone&quot;, &quot;15999&quot;); values.put(&quot;salary&quot;, 16000); db.insert(&quot;person&quot;, null, values); &#125; public void deleteApi()&#123; int i = db.delete(&quot;person&quot;, &quot;name = ? and _id = ?&quot;, new String[]&#123;&quot;小志的儿子&quot;, &quot;3&quot;&#125;); System.out.println(i); &#125; public void updateApi()&#123; ContentValues values = new ContentValues(); values.put(&quot;salary&quot;, 26000); int i = db.update(&quot;person&quot;, values, &quot;name = ?&quot;, new String[]&#123;&quot;游天龙&quot;&#125;); System.out.println(i); &#125; public void selectApi()&#123; Cursor cursor = db.query(&quot;person&quot;, null, null, null, null, null, null, null); while(cursor.moveToNext())&#123; String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;)); String phone = cursor.getString(cursor.getColumnIndex(&quot;phone&quot;)); String salary = cursor.getString(cursor.getColumnIndex(&quot;salary&quot;)); System.out.println(name + &quot;;&quot; + phone + &quot;;&quot; + salary); &#125; &#125; public void transaction()&#123; try&#123; //开启事务 db.beginTransaction(); ContentValues values = new ContentValues(); values.put(&quot;salary&quot;, 12000); db.update(&quot;person&quot;, values, &quot;name = ?&quot;, new String[]&#123;&quot;小志&quot;&#125;); values.clear(); values.put(&quot;salary&quot;, 16000); db.update(&quot;person&quot;, values, &quot;name = ?&quot;, new String[]&#123;&quot;小志的儿子&quot;&#125;); int i = 3/0; //设置 事务执行成功 db.setTransactionSuccessful(); &#125; finally&#123; //关闭事务，同时提交，如果已经设置事务执行成功，那么sql语句就生效了，反之，sql语句回滚 db.endTransaction(); &#125; &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"主线程阻塞，使用handler方法消息队列 和子线程请求主线程进行ui变化","date":"2016-06-11T15:22:24.000Z","path":"2016/06/11/handler/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class MainActivity extends AppCompatActivity &#123;static ImageView iv;static MainActivity ma;static Handler handler = new Handler() &#123;@Overridepublic void handleMessage(Message msg) &#123;switch (msg.what) &#123;case 1:iv.setImageBitmap((Bitmap) msg.obj);break;case 2: Toast.makeText(ma, &quot;请求失败&quot;, Toast.LENGTH_SHORT).show();break; &#125; &#125; &#125;;protected void onCreate(Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState); setContentView(R.layout.activity_main);iv = (ImageView) findViewById(R.id.iv);ma = this; &#125;public void click(View v) &#123;final String path = &quot;http://192.168.74.154:8080/a.jpg&quot;;final File file = new File(getFilesDir(), getPathName(path));if (file.exists()) &#123; Log.d(&quot;======&quot;, &quot;1111 &quot;); Bitmap bm = BitmapFactory.decodeFile(file.getAbsolutePath());iv.setImageBitmap(bm); &#125; else &#123; Thread t = new Thread() &#123;public void run() &#123;try &#123; URL url = new URL(path); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(&quot;GET&quot;); conn.setReadTimeout(5000); conn.setConnectTimeout(5000); conn.connect();if (conn.getResponseCode() == 200) &#123; InputStream is = conn.getInputStream();byte[] b = new byte[1024]; FileOutputStream fos = new FileOutputStream(file);int len = 0;while ((len = is.read(b)) != -1) &#123; fos.write(b, 0, len); &#125; fos.close(); Bitmap bm = BitmapFactory.decodeFile(file.getAbsolutePath()); Message msg = handler.obtainMessage(); msg.obj = bm; msg.what = 1;handler.sendMessage(msg); &#125; else &#123; Message msg = handler.obtainMessage(); msg.what = 1; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;; t.start(); &#125; &#125;public String getPathName(String path) &#123;int index = path.lastIndexOf(&quot;/&quot;);return path.substring(index + 1); &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]}]
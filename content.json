[{"title":"RecyclerView的使用","date":"2017-03-28T11:54:04.000Z","path":"2017/03/28/RecyclerView的使用/","text":"之前写Android程序遇到列表显示都是使用listview，可能因为自己要写的东西比较简单吧，所以一直没去用recycleview。但是今天遇到了个让人恼火的事情，就是listview和CollapsingToolbarLayout不兼容，无法实现toolbar的折叠效果，即使外面裹上了一层NestedScrollView 还要自己去重写listview的方法，非常麻烦，而且貌似在Android5.0有bug？就是他的下面会溢出屏幕一个toolbar的高度，数据显示不全，于是今天去搞了下recyclevierecycleview和listview的思想差不多。虽然他的实现方法和listview差不多，但是还是有很大不同的，而且recycleview比listview比起来优势更多，更适合自定义，而且性能也很好，因为recycleview是直接继承groupview的，减少了图像的一层层的绘制，而listview则继承listview的抽象类。 具体recycle 的实现方法 12345recyclerView= (RecyclerView) findViewById(R.id.Recycle);final LinearLayoutManager manager=new LinearLayoutManager(this);recyclerView.setLayoutManager(manager);recyclerView.setHasFixedSize(true);recyclerView.addItemDecoration(new SpacesItemDecoration(3));//给recycleview添加分割线，因为recycle没有自带类似listview的driver; SpacesItemDecoration方法（下划线）12345678910111213141516171819public class SpacesItemDecoration extends RecyclerView.ItemDecoration &#123; private int space; public SpacesItemDecoration(int space) &#123; this.space = space; &#125; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123; outRect.left = space; outRect.right = space; outRect.bottom = space; // Add top margin only for the first item to avoid double space between items if (parent.getChildPosition(view) == 0) outRect.top = space; &#125; &#125; recycleview的adapter12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class GradeRecyclerAdapter extends RecyclerView.Adapter&lt;GradeRecyclerAdapter.ViewHolder&gt; &#123; private List&lt;Map&lt;String, String&gt;&gt; list; private Activity activity; //构造方法 public GradeRecyclerAdapter(List&lt;Map&lt;String, String&gt;&gt; list, Activity activity) &#123; this.list = list; this.activity = activity; &#125;//viewholder @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_list_library, parent,false); ViewHolder viewHolder = new ViewHolder(view); return viewHolder; &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; holder.bookname.setText(list.get(position).get(&quot;name&quot;)); holder.place.setText(list.get(position).get(&quot;palce&quot;)); holder.writer.setText(list.get(position).get(&quot;writer&quot;)); holder.num.setText(list.get(position).get(&quot;num&quot;)); final int a=position; holder.more.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(activity, BookDetalActivity.class); intent.putExtra(&quot;url&quot;, list.get(a).get(&quot;url&quot;)); activity.startActivity(intent); &#125; &#125;); &#125; @Override public int getItemCount() &#123; return list.size(); &#125; public static class ViewHolder extends RecyclerView.ViewHolder &#123; TextView bookname; TextView place; TextView writer; TextView num; TextView more; public ViewHolder(View itemView) &#123; super(itemView); bookname = (TextView) itemView.findViewById(R.id.bookname); place = (TextView) itemView.findViewById(R.id.place); writer = (TextView) itemView.findViewById(R.id.num); num = (TextView) itemView.findViewById(R.id.writer); more = (TextView) itemView.findViewById(R.id.moer); &#125; &#125;&#125; 以上就是recycleview的简单实现啦，很简单。","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"安卓学习路线","date":"2017-03-28T11:05:59.000Z","path":"2017/03/28/安卓学习路线/","text":"学了这么久安卓，忽然发现自己会的太少了，于是在ｖ２ｅｘ上求助，偶然发现好心人推荐的一个博客非常不错，里面总结了很多关于安卓学习用到的东西，今天在这跟大家分享下。 1http://www.jianshu.com/p/af2de05aadff","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Linux环境下搭建hexo博客","date":"2017-03-28T11:03:43.000Z","path":"2017/03/28/Linux环境下搭建hexo博客/","text":"之前一直用windows系统 ，直到前几天换了国产的linux系统deepin，发现这个系统真的不错！很漂亮尤其我这种做安卓开发的，用了deepin之后发现 as的打开速度快乐特别多。好了言归正传，我在这里讲一下如何在linux系统下搭建hexo个人博客。 第一步： 安装git1$ sudo apt-get install git 第二步：安装node.js之前上网google资料的时候走了好多弯路，网上很多人都说最好不用 apt-get的方法可是最后发现这个方法是最省力最方便的。1sudo apt-get install nodejs 1sudo apt-get install npm 直接运行以上两个命令，安装node.js 如果不好使把sudo去掉，或者 1sudo su 这时候让你输入密码然后在root用户下运行命令 如果直接安装的方法不管用了，别急还有另外两种方法去官网下载好node.js文件后 1cd node-***(你的node.js文件)/bin 1./node -v 然后将node命令设置全局可用： 1 ln -s /home/tongyangmysofltware/node-v0.10.28-linux-x64/bin/node /usr/local/bin/node 1ln -s /home/tongyang/mysofltware/node-v0.10.28-linux-x64/bin/npm /usr/local/bin/npm 这个目录根据个人情况而定 第三步：hexo的安装node.js安装完成后我们就可以安装hexo了 1npm install hexo-cli -g 初始化hexo 1hexo init 安装依赖包 1npm install 生成静态页面 1hexo generate （可以简写成 hexo g） 开启本地服务 1hexo server (同理简写成 hexo s) 浏览器打开http://localhost:4000就可以看到自己博客啦，不过现在还没有和自己github关联 第四步：发布自己的博客到github上1检查本地是否存在id1打开git bash，输入命令ls -al ~/.ssh。 如果存在直接跳过 如果没有 1234$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot;# Creates a new ssh key using the provided email # Generating public/private rsa key pair. # Enter file in which to save the key (/home/you/.ssh/id_rsa): 直接Enter就行。然后，会提示你输入密码，如下(建议输一个，安全一点，当然不输也行)： 12Enter passphrase (empty for no passphrase): [Type a passphrase] # Enter same passphrase again: [Type passphrase again] 完了之后，大概是这样。 123Your identification has been saved in /home/you/.ssh/id_rsa. # Your public key has been saved in /home/you/.ssh/id_rsa.pub. # The key fingerprint is: # 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@youremail.com 你的秘钥已经生成 知道.shh下面的id_rsa. 或者id_rsa.pub. 复制你的秘钥所有内容 登陆你的github帐户。然后 Account Settings -&gt; 左栏点击 SSH Keys -&gt; 点击 Add SSH key 然后你复制上面的公钥内容，粘贴进“Key”文本域内。 title域，你随便填一个都行。 完了，点击 Add key。 可以使用一下命令查看是否成功 1$ ssh -T git@github.com 如果，看到： 1Hi username! You&apos;ve successfully authenticated, but GitHub does not # provide shell access. 就表示你的设置已经成功了。 至于怎么在github上面生成自己博客页面我就不多说了，不会的百度吧，因为我想作为一个程序员，连基友交友平台都不知道怎么用，那就太尴尬了。 在hexo文件夹的的住配置文件里面拉到最下面修改成这样 1234deploy: type: git repo: git@github.com:tongyangl/tongyangl.github.io.git branch: master 记住这个 repo是你在github上面的地址！ 最后直接在hexo页面执行以下命令 1hexo d 大多数都会成功 如果还不成功提示未找到git也可以用一些麻烦的方法push自己的博客 新建一个文件夹blog 1git clone 你github的博客地址 然后 12hexo ghexo s 删除blog的文件夹的内容 在hexo文件夹的public文件下的所有内容都复制到blog 然后 123git add ×git commit -m 你的commit内容随便你写git push","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"利用序列化器生成xml文件","date":"2016-11-15T11:30:20.000Z","path":"2016/11/15/利用序列化器生成xml文件/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384List&lt;Message&gt; smsList; // 虚拟10条短信 smsList = new ArrayList&lt;Message&gt;(); for (int i = 0; i &lt; 10; i++) &#123; Message sms = new Message(&quot;小志好棒&quot; + i, System.currentTimeMillis() + &quot;&quot;, &quot;138&quot; + i + i, &quot;1&quot;); smsList.add(sms); &#125; &#125; public void click(View v)&#123; //使用xml序列化器生成xml文件 //1.拿到序列化器对象 XmlSerializer xs = Xml.newSerializer(); //2.初始化 File file = new File(&quot;sdcard/sms2.xml&quot;); try &#123; FileOutputStream fos = new FileOutputStream(file); //enconding:指定用什么编码生成xml文件 xs.setOutput(fos, &quot;utf-8&quot;); //3.开始生成xml文件 //enconding:指定头结点中的enconding属性的值 xs.startDocument(&quot;utf-8&quot;, true); xs.startTag(null, &quot;message&quot;); for (Message sms : smsList) &#123; xs.startTag(null, &quot;sms&quot;); xs.startTag(null, &quot;body&quot;); xs.text(sms.getBody() + &quot;&lt;body&gt;&quot;); xs.endTag(null, &quot;body&quot;); xs.endTag(null, &quot;sms&quot;); &#125; xs.endTag(null, &quot;message&quot;); //告诉序列化器，文件生成完毕 xs.endDocument(); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;================================================================================================================================================================================================package com.itheima.createxml.domain;public class Message &#123; private String body; private String date; private String address; private String type; public String getBody() &#123; return body; &#125; public void setBody(String body) &#123; this.body = body; &#125; public String getDate() &#123; return date; &#125; public void setDate(String date) &#123; this.date = date; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; public Message(String body, String date, String address, String type) &#123; super(); this.body = body; this.date = date; this.address = address; this.type = type; &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"测试类测试数据库并且进行增删改查","date":"2016-10-28T11:22:03.000Z","path":"2016/10/28/测试类测试数据库并且进行增删改查/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187public class TestCase extends AndroidTestCase &#123; //此时测试框架还没有初始化完毕，没有虚拟上下文对象// private MyOpenHelper oh = new MyOpenHelper(getContext(), &quot;people.db&quot;, null, 1); private MyOpenHelper oh; private SQLiteDatabase db; public void test()&#123; //getContext():获取一个虚拟的上下文 MyOpenHelper oh = new MyOpenHelper(getContext(), &quot;people.db&quot;, null, 1); //如果数据库不存在，先创建数据库，再获取可读可写的数据库对象，如果数据库存在，就直接打开 SQLiteDatabase db = oh.getWritableDatabase(); //如果存储空间满了，那么返回只读数据库对象// SQLiteDatabase db = oh.getReadableDatabase(); &#125; //测试框架初始化完毕之后，在测试方法执行之前，此方法调用 @Override protected void setUp() throws Exception &#123; super.setUp(); oh = new MyOpenHelper(getContext(), &quot;people.db&quot;, null, 1); db = oh.getWritableDatabase(); &#125; //测试方法执行完毕之后，此方法调用 @Override protected void tearDown() throws Exception &#123; // TODO Auto-generated method stub super.tearDown(); db.close(); &#125; public void insert()&#123;// db.execSQL(&quot;insert into person (name, salary, phone)values(?, ?, ?)&quot;, new Object[]&#123;&quot;小志的老婆[1]&quot;, &quot;13000&quot;, 138438&#125;);// db.execSQL(&quot;insert into person (name, salary, phone)values(?, ?, ?)&quot;, new Object[]&#123;&quot;小志的儿子&quot;, 14000, &quot;13888&quot;&#125;); db.execSQL(&quot;insert into person (name, salary, phone)values(?, ?, ?)&quot;, new Object[]&#123;&quot;小志&quot;, 14000, &quot;13888&quot;&#125;); &#125; public void delete()&#123; db.execSQL(&quot;delete from person where name = ?&quot;, new Object[]&#123;&quot;小志&quot;&#125;); &#125; public void update()&#123; db.execSQL(&quot;update person set phone = ? where name = ?&quot;, new Object[]&#123;186666, &quot;小志的儿子&quot;&#125;); &#125; public void select()&#123; Cursor cursor = db.rawQuery(&quot;select name, salary from person&quot;, null); while(cursor.moveToNext())&#123; //通过列索引获取列的值 String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;)); String salary = cursor.getString(1); System.out.println(name + &quot;;&quot; + salary); &#125; &#125; public void insertApi()&#123; //把要插入的数据全部封装至ContentValues对象 ContentValues values = new ContentValues(); values.put(&quot;name&quot;, &quot;游天龙&quot;); values.put(&quot;phone&quot;, &quot;15999&quot;); values.put(&quot;salary&quot;, 16000); db.insert(&quot;person&quot;, null, values); &#125; public void deleteApi()&#123; int i = db.delete(&quot;person&quot;, &quot;name = ? and _id = ?&quot;, new String[]&#123;&quot;小志的儿子&quot;, &quot;3&quot;&#125;); System.out.println(i); &#125; public void updateApi()&#123; ContentValues values = new ContentValues(); values.put(&quot;salary&quot;, 26000); int i = db.update(&quot;person&quot;, values, &quot;name = ?&quot;, new String[]&#123;&quot;游天龙&quot;&#125;); System.out.println(i); &#125; public void selectApi()&#123; Cursor cursor = db.query(&quot;person&quot;, null, null, null, null, null, null, null); while(cursor.moveToNext())&#123; String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;)); String phone = cursor.getString(cursor.getColumnIndex(&quot;phone&quot;)); String salary = cursor.getString(cursor.getColumnIndex(&quot;salary&quot;)); System.out.println(name + &quot;;&quot; + phone + &quot;;&quot; + salary); &#125; &#125; public void transaction()&#123; try&#123; //开启事务 db.beginTransaction(); ContentValues values = new ContentValues(); values.put(&quot;salary&quot;, 12000); db.update(&quot;person&quot;, values, &quot;name = ?&quot;, new String[]&#123;&quot;小志&quot;&#125;); values.clear(); values.put(&quot;salary&quot;, 16000); db.update(&quot;person&quot;, values, &quot;name = ?&quot;, new String[]&#123;&quot;小志的儿子&quot;&#125;); int i = 3/0; //设置 事务执行成功 db.setTransactionSuccessful(); &#125; finally&#123; //关闭事务，同时提交，如果已经设置事务执行成功，那么sql语句就生效了，反之，sql语句回滚 db.endTransaction(); &#125; &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"主线程阻塞，使用handler方法消息队列 和子线程请求主线程进行ui变化","date":"2016-06-11T15:22:24.000Z","path":"2016/06/11/handler/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class MainActivity extends AppCompatActivity &#123;static ImageView iv;static MainActivity ma;static Handler handler = new Handler() &#123;@Overridepublic void handleMessage(Message msg) &#123;switch (msg.what) &#123;case 1:iv.setImageBitmap((Bitmap) msg.obj);break;case 2: Toast.makeText(ma, &quot;请求失败&quot;, Toast.LENGTH_SHORT).show();break; &#125; &#125; &#125;;protected void onCreate(Bundle savedInstanceState) &#123;super.onCreate(savedInstanceState); setContentView(R.layout.activity_main);iv = (ImageView) findViewById(R.id.iv);ma = this; &#125;public void click(View v) &#123;final String path = &quot;http://192.168.74.154:8080/a.jpg&quot;;final File file = new File(getFilesDir(), getPathName(path));if (file.exists()) &#123; Log.d(&quot;======&quot;, &quot;1111 &quot;); Bitmap bm = BitmapFactory.decodeFile(file.getAbsolutePath());iv.setImageBitmap(bm); &#125; else &#123; Thread t = new Thread() &#123;public void run() &#123;try &#123; URL url = new URL(path); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(&quot;GET&quot;); conn.setReadTimeout(5000); conn.setConnectTimeout(5000); conn.connect();if (conn.getResponseCode() == 200) &#123; InputStream is = conn.getInputStream();byte[] b = new byte[1024]; FileOutputStream fos = new FileOutputStream(file);int len = 0;while ((len = is.read(b)) != -1) &#123; fos.write(b, 0, len); &#125; fos.close(); Bitmap bm = BitmapFactory.decodeFile(file.getAbsolutePath()); Message msg = handler.obtainMessage(); msg.obj = bm; msg.what = 1;handler.sendMessage(msg); &#125; else &#123; Message msg = handler.obtainMessage(); msg.what = 1; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;; t.start(); &#125; &#125;public String getPathName(String path) &#123;int index = path.lastIndexOf(&quot;/&quot;);return path.substring(index + 1); &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]}]